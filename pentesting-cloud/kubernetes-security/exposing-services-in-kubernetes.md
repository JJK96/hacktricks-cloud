# Kubernetesでのサービス公開

<details>

<summary><strong>**htARTE（HackTricks AWS Red Team Expert）**</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>**htARTE（HackTricks AWS Red Team Expert）**</strong></a><strong>を使って、ゼロからヒーローまでAWSハッキングを学ぶ！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝**したい場合や**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter**で私をフォローする🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
- **ハッキングテクニックを共有するために、[HackTricks](https://github.com/carlospolop/hacktricks)と[HackTricks Cloud](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。**

</details>

Kubernetesでサービスを公開する**さまざまな方法**があり、**内部**エンドポイントと**外部**エンドポイントの両方がアクセスできるようになります。このKubernetesの構成は非常に重要であり、管理者が**攻撃者にアクセス権を与える可能性**があるため注意が必要です。

### 自動列挙

公開されている方法を列挙する前に、K8sが公開する方法を列挙する前に、名前空間、サービス、イングレスをリストできれば、次のコマンドで公開されているすべてを見つけることができます：
```bash
kubectl get namespace -o custom-columns='NAME:.metadata.name' | grep -v NAME | while IFS='' read -r ns; do
echo "Namespace: $ns"
kubectl get service -n "$ns"
kubectl get ingress -n "$ns"
echo "=============================================="
echo ""
echo ""
done | grep -v "ClusterIP"
# Remove the last '| grep -v "ClusterIP"' to see also type ClusterIP
```
### ClusterIP

**ClusterIP**サービスは**デフォルト**のKubernetes **サービス**です。これは、クラスタ内の他のアプリがアクセスできる**サービス**を提供します。**外部アクセスはありません**。

ただし、これはKubernetesプロキシを使用してアクセスできます：
```bash
kubectl proxy --port=8080
```
以下のスキームを使用して、Kubernetes API を介してサービスにアクセスできます：

`http://localhost:8080/api/v1/proxy/namespaces/<NAMESPACE>/services/<SERVICE-NAME>:<PORT-NAME>/`

例えば、次のURL を使用できます：

`http://localhost:8080/api/v1/proxy/namespaces/default/services/my-internal-service:http/`

このサービスにアクセスします：
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-internal-service
spec:
selector:
app: my-app
type: ClusterIP
ports:
- name: http
port: 80
targetPort: 80
protocol: TCP
```
_この方法を実行するには、`kubectl`を**認証されたユーザー**として実行する必要があります。_

すべての ClusterIP をリストします：

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,PORT(S):.spec.ports[*].port,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep ClusterIP
```
{% endcode %}

### NodePort

**NodePort**を利用すると、すべてのノード（仮想マシンを表す）に指定されたポートが利用可能になります。この特定のポートに向けられた**トラフィック**は、その後サービスにシステマティックに**ルーティング**されます。一般的に、この方法は欠点があるため推奨されていません。

すべてのNodePortをリストアップします：

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,PORT(S):.spec.ports[*].port,NODEPORT(S):.spec.ports[*].nodePort,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep NodePort
```
{% endcode %}

NodePort仕様の例：
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-nodeport-service
spec:
selector:
app: my-app
type: NodePort
ports:
- name: http
port: 80
targetPort: 80
nodePort: 30036
protocol: TCP
```
### LoadBalancer <a href="#id-0d96" id="id-0d96"></a>

サービスを**クラウドプロバイダのロードバランサーを使用して**外部に公開します。GKEでは、これにより[ネットワークロードバランサー](https://cloud.google.com/compute/docs/load-balancing/network/)が起動され、サービスにすべてのトラフィックを転送する単一のIPアドレスが提供されます。AWSでは、ロードバランサーが起動されます。

公開されたサービスごとにロードバランサーを支払う必要があり、これは高額になる可能性があります。

すべてのロードバランサーをリストアップします：
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,EXTERNAL-IP:.status.loadBalancer.ingress[*],PORT(S):.spec.ports[*].port,NODEPORT(S):.spec.ports[*].nodePort,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep LoadBalancer
```
{% endcode %}

### 外部IP <a href="#external-ips" id="external-ips"></a>

{% hint style="success" %}
外部IPは、ロードバランサータイプのサービスによって公開され、一般的には外部クラウドプロバイダーのロードバランサーが使用されている場合に使用されます。

これらを見つけるには、`EXTERNAL-IP`フィールドに値があるロードバランサーを確認してください。
{% endhint %}

**外部IP**（**宛先IP**として）を持つクラスターに入るトラフィックは、サービスポートにルーティングされ、サービスのエンドポイントの1つに到達します。`externalIPs`はKubernetesによって管理されず、クラスター管理者の責任です。

サービスの仕様では、`externalIPs`を`ServiceTypes`のいずれかと共に指定できます。以下の例では、"`my-service`"は"`80.11.12.10:80`"（`externalIP:port`）でクライアントからアクセスできます。
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-service
spec:
selector:
app: MyApp
ports:
- name: http
protocol: TCP
port: 80
targetPort: 9376
externalIPs:
- 80.11.12.10
```
### ExternalName

[**ドキュメントから:**](https://kubernetes.io/docs/concepts/services-networking/service/#externalname) ExternalNameタイプのサービスは、通常のセレクター（`my-service`や`cassandra`など）ではなく、**サービスをDNS名にマップ**します。これらのサービスは、`spec.externalName`パラメーターで指定します。

たとえば、このサービス定義は、`prod`ネームスペース内の`my-service`サービスを`my.database.example.com`にマップします：
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-service
namespace: prod
spec:
type: ExternalName
externalName: my.database.example.com
```
ホスト`my-service.prod.svc.cluster.local`を検索すると、クラスタDNSサービスが値`my.database.example.com`を持つ`CNAME`レコードを返します。`my-service`へのアクセスは他のサービスと同様に機能しますが、重要な違いは**リダイレクトがプロキシングや転送ではなくDNSレベルで発生する**ことです。

すべてのExternalNamesをリストアップします：

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces | grep ExternalName
```
{% endcode %}

### イングレス

上記の例とは異なり、**Ingressはサービスの一種ではありません**。代わりに、**複数のサービスの前に配置され、"スマートルーター"またはクラスターへのエントリーポイントとして機能**します。

Ingressではさまざまなことができ、**異なる機能を持つ多くの種類のIngressコントローラーがあります**。

デフォルトのGKE Ingressコントローラーは、[HTTP(S)ロードバランサー](https://cloud.google.com/compute/docs/load-balancing/http/)を起動します。これにより、パスベースおよびサブドメインベースのルーティングをバックエンドサービスに行うことができます。たとえば、foo.yourdomain.comのすべてをfooサービスに送信したり、yourdomain.com/bar/パスの下のすべてをbarサービスに送信したりできます。

GKE上のIngressオブジェクトのYAMLは、[L7 HTTPロードバランサー](https://cloud.google.com/compute/docs/load-balancing/http/)を使用したものは次のようになります：
```yaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
name: my-ingress
spec:
backend:
serviceName: other
servicePort: 8080
rules:
- host: foo.mydomain.com
http:
paths:
- backend:
serviceName: foo
servicePort: 8080
- host: mydomain.com
http:
paths:
- path: /bar/*
backend:
serviceName: bar
servicePort: 8080
```
すべてのイングレスをリストアップします：

{% code overflow="wrap" %}
```bash
kubectl get ingresses --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,RULES:spec.rules[*],STATUS:status'
```
{% endcode %}

この場合、それぞれの情報を1つずつ取得して、よりよく読む方が良いです。
```bash
kubectl get ingresses --all-namespaces -o=yaml
```
### 参考

* [https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0](https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0)
* [https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/)

<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい** または **HackTricks をPDFでダウンロードしたい** 場合は [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) を発見し、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f) または [**telegramグループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm) をフォローする。**
* **HackTricks** と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) のGitHubリポジトリに PR を提出して、あなたのハッキングテクニックを共有してください。

</details>
