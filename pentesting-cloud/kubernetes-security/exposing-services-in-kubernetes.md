# 쿠버네티스에서 서비스 노출하기

{% hint style="success" %}
AWS 해킹 배우고 실습하기:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCP 해킹 배우고 실습하기: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* 💬 [**디스코드 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) 깃헙 레포지토리에 PR을 제출하여 해킹 트릭을 공유하세요.

</details>
{% endhint %}

**쿠버네티스에서 서비스를 노출하는 다양한 방법**이 있어 내부 엔드포인트와 외부 엔드포인트가 모두 액세스할 수 있습니다. 이 쿠버네티스 구성은 관리자가 **접근해서는 안 되는 서비스에 공격자에게 액세스 권한을 부여**할 수 있기 때문에 매우 중요합니다.

### 자동 열거

공개로 서비스를 노출하는 방법을 열거하기 전에, 네임스페이스, 서비스 및 인그레스를 나열할 수 있다면, 다음 명령어로 공개로 노출된 모든 것을 찾을 수 있습니다:
```bash
kubectl get namespace -o custom-columns='NAME:.metadata.name' | grep -v NAME | while IFS='' read -r ns; do
echo "Namespace: $ns"
kubectl get service -n "$ns"
kubectl get ingress -n "$ns"
echo "=============================================="
echo ""
echo ""
done | grep -v "ClusterIP"
# Remove the last '| grep -v "ClusterIP"' to see also type ClusterIP
```
### ClusterIP

**ClusterIP** 서비스는 **기본** Kubernetes **서비스**입니다. 클러스터 내에서 다른 앱들이 액세스할 수 있는 **서비스**를 제공합니다. **외부 액세스는 없습니다**.

그러나 이는 Kubernetes Proxy를 사용하여 액세스할 수 있습니다:
```bash
kubectl proxy --port=8080
```
이제 다음 체계를 사용하여 Kubernetes API를 통해 서비스에 액세스할 수 있습니다:

`http://localhost:8080/api/v1/proxy/namespaces/<NAMESPACE>/services/<SERVICE-NAME>:<PORT-NAME>/`

예를 들어 다음 URL을 사용할 수 있습니다:

`http://localhost:8080/api/v1/proxy/namespaces/default/services/my-internal-service:http/`

이 서비스에 액세스하려면:
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-internal-service
spec:
selector:
app: my-app
type: ClusterIP
ports:
- name: http
port: 80
targetPort: 80
protocol: TCP
```
_이 방법을 사용하려면 `kubectl`을 **인증된 사용자**로 실행해야 합니다._

모든 ClusterIP 목록:

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,PORT(S):.spec.ports[*].port,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep ClusterIP
```
{% endcode %}

### NodePort

**NodePort**를 사용할 때는 지정된 포트가 모든 노드(가상 머신을 나타냄)에서 사용할 수 있게 됩니다. 이 특정 포트로 전송된 **트래픽**은 그런 다음 **서비스로 라우팅**됩니다. 일반적으로 이 방법은 그 단점 때문에 권장되지 않습니다.

모든 NodePort를 나열합니다:

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,PORT(S):.spec.ports[*].port,NODEPORT(S):.spec.ports[*].nodePort,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep NodePort
```
{% endcode %}

NodePort 사양의 예시:
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-nodeport-service
spec:
selector:
app: my-app
type: NodePort
ports:
- name: http
port: 80
targetPort: 80
nodePort: 30036
protocol: TCP
```
만약 yaml에서 **nodePort**를 **지정하지 않으면** (열릴 포트입니다) **30000-32767 범위**의 포트가 사용됩니다.

### LoadBalancer <a href="#id-0d96" id="id-0d96"></a>

**클라우드 제공업체의 로드 밸런서**를 사용하여 서비스를 외부에 노출합니다. GKE의 경우, 이는 [네트워크 로드 밸런서](https://cloud.google.com/compute/docs/load-balancing/network/)를 생성하여 모든 트래픽을 서비스로 전달할 단일 IP 주소를 제공합니다. AWS의 경우 로드 밸런서를 시작합니다.

노출된 각 서비스당 로드 밸런서를 사용해야 하며, 이는 비용이 많이 들 수 있습니다.

모든 로드 밸런서를 나열합니다:

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,EXTERNAL-IP:.status.loadBalancer.ingress[*],PORT(S):.spec.ports[*].port,NODEPORT(S):.spec.ports[*].nodePort,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep LoadBalancer
```
{% endcode %}

### 외부 IP <a href="#external-ips" id="external-ips"></a>

{% hint style="success" %}
외부 IP는 로드 밸런서 유형의 서비스에 의해 노출되며 일반적으로 외부 클라우드 제공업체 로드 밸런서를 사용할 때 사용됩니다.

외부 IP를 찾으려면 `EXTERNAL-IP` 필드에 값이 있는 로드 밸런서를 확인하십시오.
{% endhint %}

**외부 IP** (대상 IP로) 클러스터로 인입되는 트래픽은 서비스 포트로 라우팅되어 **서비스 엔드포인트 중 하나로 전달**됩니다. `externalIPs`는 Kubernetes에서 관리되지 않으며 클러스터 관리자의 책임입니다.

서비스 사양에서 `externalIPs`는 `ServiceTypes` 중 하나와 함께 지정할 수 있습니다. 아래 예시에서 "`my-service`"는 "`80.11.12.10:80`" (`externalIP:port`)에서 클라이언트가 액세스할 수 있습니다.
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-service
spec:
selector:
app: MyApp
ports:
- name: http
protocol: TCP
port: 80
targetPort: 9376
externalIPs:
- 80.11.12.10
```
### ExternalName

[**문서에서 가져옴:**](https://kubernetes.io/docs/concepts/services-networking/service/#externalname) ExternalName 유형의 서비스는 일반적인 선택기인 `my-service` 또는 `cassandra`가 아닌 DNS 이름에 서비스를 매핑합니다. 이러한 서비스는 `spec.externalName` 매개변수로 지정합니다.

예를 들어, 다음은 `prod` 네임스페이스의 `my-service` 서비스를 `my.database.example.com`에 매핑하는 서비스 정의입니다:
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-service
namespace: prod
spec:
type: ExternalName
externalName: my.database.example.com
```
호스트 `my-service.prod.svc.cluster.local`를 조회할 때, 클러스터 DNS 서비스는 값이 `my.database.example.com`인 `CNAME` 레코드를 반환합니다. `my-service`에 액세스하는 것은 다른 서비스와 동일한 방식으로 작동하지만 중요한 차이점은 **리다이렉션이 프록시 또는 포워딩을 통해가 아닌 DNS 레벨에서 발생한다**는 것입니다.

모든 ExternalNames를 나열하십시오:

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces | grep ExternalName
```
{% endcode %}

### 인그레스

위의 모든 예제와는 달리 **인그레스는 서비스 유형이 아닙니다**. 대신, **여러 서비스 앞에 위치하여 "스마트 라우터" 또는 클러스터로의 진입점 역할을 합니다**.

인그레스를 사용하면 다양한 작업을 수행할 수 있으며, **다양한 기능을 갖춘 여러 유형의 인그레스 컨트롤러가 있습니다**.

기본 GKE 인그레스 컨트롤러는 [HTTP(S) 로드 밸런서](https://cloud.google.com/compute/docs/load-balancing/http/)를 생성합니다. 이를 통해 경로 기반 및 서브도메인 기반의 백엔드 서비스 라우팅을 수행할 수 있습니다. 예를 들어, foo.yourdomain.com의 모든 것을 foo 서비스로 보내고, yourdomain.com/bar/ 경로 아래의 모든 것을 bar 서비스로 보낼 수 있습니다.

GKE에서 [L7 HTTP 로드 밸런서](https://cloud.google.com/compute/docs/load-balancing/http/)를 사용하는 인그레스 객체의 YAML은 다음과 같을 수 있습니다:
```yaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
name: my-ingress
spec:
backend:
serviceName: other
servicePort: 8080
rules:
- host: foo.mydomain.com
http:
paths:
- backend:
serviceName: foo
servicePort: 8080
- host: mydomain.com
http:
paths:
- path: /bar/*
backend:
serviceName: bar
servicePort: 8080
```
모든 인그레스를 나열하십시오:

{% code overflow="wrap" %}
```bash
kubectl get ingresses --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,RULES:spec.rules[*],STATUS:status'
```
{% endcode %}

이 경우에는 각각의 정보를 하나씩 얻어서 더 잘 읽는 것이 좋습니다:
```bash
kubectl get ingresses --all-namespaces -o=yaml
```
### 참고 자료

* [https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0](https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0)
* [https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/)

{% hint style="success" %}
AWS 해킹 학습 및 실습:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCP 해킹 학습 및 실습: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks 지원하기</summary>

* [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* 💬 [**디스코드 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* 해킹 요령을 공유하려면 **HackTricks** 및 **HackTricks Cloud** 깃허브 저장소에 PR을 제출하세요.

</details>
{% endhint %}
