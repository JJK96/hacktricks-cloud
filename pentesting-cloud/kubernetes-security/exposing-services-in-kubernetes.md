# Services in Kubernetes freigeben

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

Es gibt **verschiedene M√∂glichkeiten, Services** in Kubernetes freizugeben, damit sowohl **interne** Endpunkte als auch **externe** Endpunkte darauf zugreifen k√∂nnen. Diese Kubernetes-Konfiguration ist ziemlich kritisch, da der Administrator Angreifern Zugriff auf Services geben k√∂nnte, auf die sie keinen Zugriff haben sollten.

### Automatische Enumeration

Bevor Sie damit beginnen, die M√∂glichkeiten zu enumerieren, die K8s bietet, um Services f√ºr die √ñffentlichkeit freizugeben, wissen Sie, dass Sie, wenn Sie Namespace, Services und Ingresses auflisten k√∂nnen, alles, was der √ñffentlichkeit zug√§nglich ist, finden k√∂nnen mit:
```bash
kubectl get namespace -o custom-columns='NAME:.metadata.name' | grep -v NAME | while IFS='' read -r ns; do
echo "Namespace: $ns"
kubectl get service -n "$ns"
kubectl get ingress -n "$ns"
echo "=============================================="
echo ""
echo ""
done | grep -v "ClusterIP"
# Remove the last '| grep -v "ClusterIP"' to see also type ClusterIP
```
### ClusterIP

Ein **ClusterIP**-Dienst ist der **Standard**-Kubernetes-**Dienst**. Er bietet Ihnen einen **Dienst innerhalb** Ihres Clusters, auf den andere Apps innerhalb Ihres Clusters zugreifen k√∂nnen. Es gibt **keinen externen Zugriff**.

Allerdings kann darauf √ºber den Kubernetes-Proxy zugegriffen werden:
```bash
kubectl proxy --port=8080
```
Nun kannst du durch die Kubernetes API navigieren, um auf Services mit diesem Schema zuzugreifen:

`http://localhost:8080/api/v1/proxy/namespaces/<NAMESPACE>/services/<SERVICE-NAME>:<PORT-NAME>/`

Zum Beispiel k√∂nntest du die folgende URL verwenden:

`http://localhost:8080/api/v1/proxy/namespaces/default/services/my-internal-service:http/`

um auf diesen Service zuzugreifen:
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-internal-service
spec:
selector:
app: my-app
type: ClusterIP
ports:
- name: http
port: 80
targetPort: 80
protocol: TCP
```
_Dieses Verfahren erfordert, dass Sie `kubectl` als **authentifizierter Benutzer** ausf√ºhren._

Liste alle ClusterIPs:

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,PORT(S):.spec.ports[*].port,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep ClusterIP
```
{% endcode %}

### NodePort

Wenn **NodePort** verwendet wird, wird ein bestimmter Port auf allen Nodes (die virtuelle Maschinen repr√§sentieren) zur Verf√ºgung gestellt. Der **Datenverkehr**, der an diesen spezifischen Port gerichtet ist, wird dann systematisch zum Service **geroutet**. In der Regel wird diese Methode aufgrund ihrer Nachteile nicht empfohlen.

Liste alle NodePorts auf: 

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,PORT(S):.spec.ports[*].port,NODEPORT(S):.spec.ports[*].nodePort,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep NodePort
```
{% endcode %}

Ein Beispiel f√ºr die NodePort-Spezifikation:
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-nodeport-service
spec:
selector:
app: my-app
type: NodePort
ports:
- name: http
port: 80
targetPort: 80
nodePort: 30036
protocol: TCP
```
Wenn Sie den **nodePort** nicht in der yaml-Datei angeben (es handelt sich um den Port, der ge√∂ffnet wird), wird ein Port im **Bereich von 30000‚Äì32767** verwendet.

### LoadBalancer <a href="#id-0d96" id="id-0d96"></a>

Stellt den Service extern **unter Verwendung eines Load Balancers des Cloud-Anbieters** bereit. Auf GKE wird dies einen [Network Load Balancer](https://cloud.google.com/compute/docs/load-balancing/network/) starten, der Ihnen eine einzelne IP-Adresse zur Verf√ºgung stellt, die den gesamten Datenverkehr an Ihren Service weiterleitet. Bei AWS wird ein Load Balancer gestartet.

F√ºr jeden freigegebenen Service m√ºssen Sie f√ºr einen LoadBalancer bezahlen, was teuer sein kann.

Liste alle LoadBalancer auf:

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,EXTERNAL-IP:.status.loadBalancer.ingress[*],PORT(S):.spec.ports[*].port,NODEPORT(S):.spec.ports[*].nodePort,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep LoadBalancer
```
{% endcode %}

### Externe IPs <a href="#external-ips" id="external-ips"></a>

{% hint style="success" %}
Externe IPs werden von Diensten des Typs Load Balancers freigelegt und werden in der Regel verwendet, wenn ein externer Cloud-Provider-Load-Balancer verwendet wird.

Um sie zu finden, √ºberpr√ºfen Sie Load Balancer mit Werten im Feld `EXTERNAL-IP`.
{% endhint %}

Der Datenverkehr, der in den Cluster mit der **externen IP** (als **Ziel-IP**) eintritt, wird auf den Serviceport geroutet und an einen der Service-Endpunkte weitergeleitet. `externalIPs` werden nicht von Kubernetes verwaltet und liegen in der Verantwortung des Cluster-Administrators.

Im Service-Spezifikation k√∂nnen `externalIPs` zusammen mit einem der `ServiceTypes` angegeben werden. Im folgenden Beispiel kann auf den Dienst "`my-service`" von Clients unter "`80.11.12.10:80`" (`externalIP:port`) zugegriffen werden.
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-service
spec:
selector:
app: MyApp
ports:
- name: http
protocol: TCP
port: 80
targetPort: 9376
externalIPs:
- 80.11.12.10
```
### ExternalName

[**Aus den Dokumenten:**](https://kubernetes.io/docs/concepts/services-networking/service/#externalname) Services vom Typ ExternalName **ordnen einen Service einem DNS-Namen zu**, nicht einem typischen Selektor wie `my-service` oder `cassandra`. Diese Services werden mit dem Parameter `spec.externalName` spezifiziert.

Diese Service-Definition ordnet beispielsweise den Service `my-service` im Namespace `prod` zu `my.database.example.com` zu:
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-service
namespace: prod
spec:
type: ExternalName
externalName: my.database.example.com
```
Wenn Sie den Host `my-service.prod.svc.cluster.local` nachschlagen, gibt der Cluster-DNS-Dienst einen `CNAME`-Datensatz mit dem Wert `my.database.example.com` zur√ºck. Der Zugriff auf `my-service` funktioniert genauso wie bei anderen Diensten, jedoch mit dem entscheidenden Unterschied, dass **die Umleitung auf DNS-Ebene** statt √ºber Proxying oder Weiterleitung erfolgt.

Liste alle ExternalNames:

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces | grep ExternalName
```
{% endcode %}

### Ingress

Im Gegensatz zu allen obigen Beispielen ist **Ingress KEIN Typ von Service**. Stattdessen sitzt es **vor mehreren Services und fungiert als "intelligenter Router"** oder Einstiegspunkt in Ihren Cluster.

Sie k√∂nnen viele verschiedene Dinge mit einem Ingress tun, und es gibt **viele Arten von Ingress-Controllern, die unterschiedliche F√§higkeiten haben**.

Der Standard GKE Ingress-Controller wird einen [HTTP(S) Load Balancer](https://cloud.google.com/compute/docs/load-balancing/http/) f√ºr Sie starten. Dies erm√∂glicht Ihnen sowohl routing basierend auf Pfaden als auch Subdomains zu Backend-Services. Zum Beispiel k√∂nnen Sie alles auf foo.yourdomain.com zum Foo-Service senden und alles unter dem Pfad yourdomain.com/bar/ zum Bar-Service.

Das YAML f√ºr ein Ingress-Objekt auf GKE mit einem [L7 HTTP Load Balancer](https://cloud.google.com/compute/docs/load-balancing/http/) k√∂nnte so aussehen:
```yaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
name: my-ingress
spec:
backend:
serviceName: other
servicePort: 8080
rules:
- host: foo.mydomain.com
http:
paths:
- backend:
serviceName: foo
servicePort: 8080
- host: mydomain.com
http:
paths:
- path: /bar/*
backend:
serviceName: bar
servicePort: 8080
```
Liste alle Eing√§nge auf: 

{% code overflow="wrap" %}
```bash
kubectl get ingresses --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,RULES:spec.rules[*],STATUS:status'
```
{% endcode %}

Obwohl es in diesem Fall besser ist, die Informationen einzeln abzurufen, um sie besser lesen zu k√∂nnen:
```bash
kubectl get ingresses --all-namespaces -o=yaml
```
### Referenzen

* [https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0](https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0)
* [https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
