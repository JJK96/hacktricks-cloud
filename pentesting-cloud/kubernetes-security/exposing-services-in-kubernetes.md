# Exposer des Services dans Kubernetes

{% hint style="success" %}
Apprenez et pratiquez le Hacking AWS :<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Apprenez et pratiquez le Hacking GCP : <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

Il existe **diff√©rentes fa√ßons d'exposer des services** dans Kubernetes afin que les endpoints **internes** et **externes** puissent y acc√©der. Cette configuration Kubernetes est assez critique car l'administrateur pourrait donner acc√®s √† des **attaquants √† des services auxquels ils ne devraient pas pouvoir acc√©der**.

### √ânum√©ration Automatique

Avant de commencer √† √©num√©rer les fa√ßons dont K8s offre pour exposer des services au public, sachez que si vous pouvez lister les espaces de noms, les services et les ingresses, vous pouvez trouver tout ce qui est expos√© au public avec :
```bash
kubectl get namespace -o custom-columns='NAME:.metadata.name' | grep -v NAME | while IFS='' read -r ns; do
echo "Namespace: $ns"
kubectl get service -n "$ns"
kubectl get ingress -n "$ns"
echo "=============================================="
echo ""
echo ""
done | grep -v "ClusterIP"
# Remove the last '| grep -v "ClusterIP"' to see also type ClusterIP
```
### ClusterIP

Un service **ClusterIP** est le **service** Kubernetes **par d√©faut**. Il vous donne un **service √† l'int√©rieur** de votre cluster auquel d'autres applications √† l'int√©rieur de votre cluster peuvent acc√©der. Il n'y a **pas d'acc√®s externe**.

Cependant, cela peut √™tre acc√©d√© en utilisant le Proxy Kubernetes :
```bash
kubectl proxy --port=8080
```
Maintenant, vous pouvez naviguer √† travers l'API Kubernetes pour acc√©der aux services en utilisant ce sch√©ma :

`http://localhost:8080/api/v1/proxy/namespaces/<NAMESPACE>/services/<SERVICE-NAME>:<PORT-NAME>/`

Par exemple, vous pourriez utiliser l'URL suivante :

`http://localhost:8080/api/v1/proxy/namespaces/default/services/my-internal-service:http/`

pour acc√©der √† ce service :
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-internal-service
spec:
selector:
app: my-app
type: ClusterIP
ports:
- name: http
port: 80
targetPort: 80
protocol: TCP
```
_Cette m√©thode n√©cessite que vous ex√©cutiez `kubectl` en tant qu'**utilisateur authentifi√©**._

Listez tous les ClusterIPs:

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,PORT(S):.spec.ports[*].port,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep ClusterIP
```
{% endcode %}

### NodePort

Lorsque **NodePort** est utilis√©, un port d√©sign√© est rendu disponible sur tous les n≈ìuds (repr√©sentant les machines virtuelles). Le **trafic** dirig√© vers ce port sp√©cifique est ensuite syst√©matiquement **rout√© vers le service**. En g√©n√©ral, cette m√©thode n'est pas recommand√©e en raison de ses inconv√©nients.

Listez tous les NodePorts :

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,PORT(S):.spec.ports[*].port,NODEPORT(S):.spec.ports[*].nodePort,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep NodePort
```
{% endcode %}

Un exemple de sp√©cification NodePort :
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-nodeport-service
spec:
selector:
app: my-app
type: NodePort
ports:
- name: http
port: 80
targetPort: 80
nodePort: 30036
protocol: TCP
```
Si vous **ne sp√©cifiez pas** le **nodePort** dans le fichier yaml (c'est le port qui sera ouvert) un port dans la **plage 30000‚Äì32767 sera utilis√©**.

### LoadBalancer <a href="#id-0d96" id="id-0d96"></a>

Expose le Service de mani√®re externe **en utilisant l'√©quilibreur de charge du fournisseur de cloud**. Sur GKE, cela va mettre en place un [Network Load Balancer](https://cloud.google.com/compute/docs/load-balancing/network/) qui vous donnera une seule adresse IP qui redirigera tout le trafic vers votre service. Sur AWS, cela lancera un √©quilibreur de charge.

Vous devez payer pour un LoadBalancer par service expos√©, ce qui peut √™tre co√ªteux.

Listez tous les LoadBalancers :

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,TYPE:.spec.type,CLUSTER-IP:.spec.clusterIP,EXTERNAL-IP:.status.loadBalancer.ingress[*],PORT(S):.spec.ports[*].port,NODEPORT(S):.spec.ports[*].nodePort,TARGETPORT(S):.spec.ports[*].targetPort,SELECTOR:.spec.selector' | grep LoadBalancer
```
{% endcode %}

### Adresses IP externes <a href="#external-ips" id="external-ips"></a>

{% hint style="success" %}
Les adresses IP externes sont expos√©es par les services de type Load Balancers et sont g√©n√©ralement utilis√©es lorsqu'un Load Balancer externe du fournisseur de cloud est utilis√©.

Pour les trouver, v√©rifiez les Load Balancers avec des valeurs dans le champ `EXTERNAL-IP`.
{% endhint %}

Le trafic qui entre dans le cluster avec l'**adresse IP externe** (comme **adresse IP de destination**), sur le port du Service, sera **rout√© vers l'un des points de terminaison du Service**. Les `externalIPs` ne sont pas g√©r√©es par Kubernetes et rel√®vent de la responsabilit√© de l'administrateur du cluster.

Dans la sp√©cification du Service, les `externalIPs` peuvent √™tre sp√©cifi√©es avec n'importe quel `ServiceTypes`. Dans l'exemple ci-dessous, "`mon-service`" peut √™tre acc√©d√© par les clients sur "`80.11.12.10:80`" (`externalIP:port`)
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-service
spec:
selector:
app: MyApp
ports:
- name: http
protocol: TCP
port: 80
targetPort: 9376
externalIPs:
- 80.11.12.10
```
### ExternalName

[**Depuis la documentation :**](https://kubernetes.io/docs/concepts/services-networking/service/#externalname) Les Services de type ExternalName **font correspondre un Service √† un nom DNS**, et non √† un s√©lecteur typique tel que `mon-service` ou `cassandra`. Vous sp√©cifiez ces Services avec le param√®tre `spec.externalName`.

Cette d√©finition de Service, par exemple, fait correspondre le Service `mon-service` dans l'espace de noms `prod` √† `ma.base.de.donn√©es.exemple.com` :
```yaml
apiVersion: v1
kind: Service
metadata:
name: my-service
namespace: prod
spec:
type: ExternalName
externalName: my.database.example.com
```
Lorsque vous recherchez l'h√¥te `my-service.prod.svc.cluster.local`, le Service DNS du cluster renvoie un enregistrement `CNAME` avec la valeur `my.database.example.com`. Acc√©der √† `my-service` fonctionne de la m√™me mani√®re que pour les autres Services mais avec la diff√©rence cruciale que **la redirection se produit au niveau du DNS** plut√¥t que par l'interm√©diaire d'un proxy ou d'une redirection.

Listez tous les ExternalNames:

{% code overflow="wrap" %}
```bash
kubectl get services --all-namespaces | grep ExternalName
```
{% endcode %}

### Ingress

Contrairement √† tous les exemples ci-dessus, **Ingress N'EST PAS un type de service**. Au lieu de cela, il se trouve **devant plusieurs services et agit comme un "routeur intelligent"** ou un point d'entr√©e dans votre cluster.

Vous pouvez faire beaucoup de choses diff√©rentes avec un Ingress, et il existe **de nombreux types de contr√¥leurs Ingress qui ont des capacit√©s diff√©rentes**.

Le contr√¥leur Ingress par d√©faut de GKE va mettre en place un [r√©partiteur de charge HTTP(S)](https://cloud.google.com/compute/docs/load-balancing/http/) pour vous. Cela vous permettra de faire du routage bas√© sur le chemin et sur les sous-domaines vers les services backend. Par exemple, vous pouvez envoyer tout ce qui se trouve sur foo.votredomaine.com vers le service foo, et tout ce qui est sous le chemin votredomaine.com/bar/ vers le service bar.

Le YAML pour un objet Ingress sur GKE avec un [r√©partiteur de charge HTTP L7](https://cloud.google.com/compute/docs/load-balancing/http/) pourrait ressembler √† ceci:
```yaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
name: my-ingress
spec:
backend:
serviceName: other
servicePort: 8080
rules:
- host: foo.mydomain.com
http:
paths:
- backend:
serviceName: foo
servicePort: 8080
- host: mydomain.com
http:
paths:
- path: /bar/*
backend:
serviceName: bar
servicePort: 8080
```
Listez tous les ingress :

{% code overflow="wrap" %}
```bash
kubectl get ingresses --all-namespaces -o=custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,RULES:spec.rules[*],STATUS:status'
```
{% endcode %}

Bien que dans ce cas, il soit pr√©f√©rable d'obtenir les informations de chacun un par un pour les lire plus facilement :
```bash
kubectl get ingresses --all-namespaces -o=yaml
```
### R√©f√©rences

* [https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0](https://medium.com/google-cloud/kubernetes-nodeport-vs-loadbalancer-vs-ingress-when-should-i-use-what-922f010849e0)
* [https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/)

{% hint style="success" %}
Apprenez et pratiquez le piratage AWS :<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Apprenez et pratiquez le piratage GCP : <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
