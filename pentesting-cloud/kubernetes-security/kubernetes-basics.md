# Osnove Kubernetes-a

## Osnove Kubernetes-a

{% hint style="success" %}
Naučite i vežbajte hakovanje AWS-a:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Naučite i vežbajte hakovanje GCP-a: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

**Originalni autor ove stranice je** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(pročitajte njegov originalni post** [**ovde**](https://sickrov.github.io)**)**

## Arhitektura i Osnove

### Šta radi Kubernetes?

* Omogućava pokretanje kontejnera u kontejner mašini.
* Planira kontejnere kako bi bili efikasni.
* Održava kontejnere aktivnim.
* Omogućava komunikaciju kontejnera.
* Omogućava tehnike implementacije.
* Upravlja obimom informacija.

### Arhitektura

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **Node**: operativni sistem sa podom ili podovima.
* **Pod**: Omotač oko kontejnera ili više kontejnera. Jedan pod treba da sadrži samo jednu aplikaciju (tako da obično, jedan pod pokreće samo 1 kontejner). Pod je način na koji Kubernetes apstrahuje tehnologiju kontejnera koja se izvršava.
* **Servis**: Svaki pod ima 1 internu **IP adresu** iz interne opsega čvora. Međutim, može biti izložen i putem servisa. **Servis takođe ima IP adresu** i njegov cilj je održavanje komunikacije između podova, tako da ako jedan umre, **novi zamena** (sa različitom internom IP adresom) **će biti dostupan** izložen na **isto IP adrese servisa**. Može biti konfigurisan kao interni ili eksterni. Servis takođe deluje kao **balanser opterećenja kada su 2 poda povezana** na isti servis.\
Kada se **servis** **kreira** možete pronaći krajnje tačke svakog servisa pokretanjem `kubectl get endpoints`
* **Kubelet**: Primarni čvorski agent. Komponenta koja uspostavlja komunikaciju između čvora i kubectl-a, i može pokrenuti samo podove (putem API servera). Kubelet ne upravlja kontejnerima koji nisu kreirani od strane Kubernetes-a.
* **Kube-proxy**: je servis zadužen za komunikaciju (servisi) između api servera i čvora. Osnova je IPtables za čvorove. Iskusniji korisnici mogu instalirati druge kube-proksi od drugih dobavljača.
* **Sidecar kontejner**: Sidecar kontejneri su kontejneri koji treba da se pokreću zajedno sa glavnim kontejnerom u podu. Ovaj sidecar obrazac proširuje i poboljšava funkcionalnost trenutnih kontejnera bez njihove promene. Danas znamo da koristimo tehnologiju kontejnera da bismo omotali sve zavisnosti kako bi aplikacija mogla da se izvršava bilo gde. Kontejner radi samo jednu stvar i to radi veoma dobro.
* **Master proces:**
* **API Server:** Način na koji korisnici i podovi komuniciraju sa master procesom. Dozvoljene su samo autentifikovane zahteve.
* **Scheduler**: Planiranje se odnosi na osiguravanje da se Podovi upare sa Čvorovima kako bi Kubelet mogao da ih pokrene. Ima dovoljno inteligencije da odluči koji čvor ima više dostupnih resursa i dodeli novi pod njemu. Napomena da scheduler ne pokreće nove podove, već komunicira sa Kubelet procesom koji se izvršava unutar čvora, koji će pokrenuti novi pod.
* **Kube Controller manager**: Proverava resurse poput replika setova ili implementacija kako bi proverio da li, na primer, tačan broj podova ili čvorova radi. U slučaju nedostatka poda, komuniciraće sa planerom da pokrene novi. Kontroliše replikaciju, tokene i naloge servise API-ju.
* **etcd**: Skladište podataka, trajno, dosledno i distribuirano. To je baza podataka Kubernetes-a i skladište ključ-vrednost gde čuva kompletan stanje klastera (svaka promena je zabeležena ovde). Komponente poput Planera ili Kontrolera zavise od ovih podataka da bi znale koje promene su se desile (dostupni resursi čvorova, broj pokrenutih podova...)
* **Cloud controller manager**: Specifičan kontroler za kontrolu toka i aplikacija, npr: ako imate klaster u AWS-u ili OpenStack-u.

Imajte na umu da može biti više čvorova (koji pokreću više podova), takođe može biti više master procesa čiji pristup Api serveru je balansiran opterećenjem i njihov etcd je sinhronizovan.

**Volumeni:**

Kada pod kreira podatke koji ne smeju biti izgubljeni kada pod nestane, treba ih čuvati u fizičkom volumenu. **Kubernetes omogućava povezivanje volumena sa podom kako bi se podaci sačuvali**. Volumen može biti na lokalnom računaru ili na **udaljenom skladištu**. Ako pokrećete podove na različitim fizičkim čvorovima, trebalo bi koristiti udaljeno skladište kako bi svi podovi mogli da mu pristupe.

**Druge konfiguracije:**

* **ConfigMap**: Možete konfigurisati **URL-ove** za pristup servisima. Pod će dobiti podatke odavde kako bi znao kako da komunicira sa ostalim servisima (podovima). Imajte na umu da ovo nije preporučeno mesto za čuvanje kredencijala!
* **Tajna**: Ovo je mesto za **čuvanje tajnih podataka** poput lozinki, API ključeva... kodiranih u B64. Pod će moći da pristupi ovim podacima kako bi koristio potrebne akreditive.
* **Implementacije**: Ovde se naznačavaju komponente koje će pokrenuti Kubernetes. Korisnik obično neće direktno raditi sa podovima, podovi su apstrahovani u **ReplicaSet-ove** (broj istih replika podova), koji se pokreću putem implementacija. Imajte na umu da su implementacije za **bezstanovne** aplikacije. Minimalna konfiguracija za implementaciju je ime i slika koja će se pokrenuti.
* **StatefulSet**: Ova komponenta je namenjena posebno za aplikacije poput **baza podataka** koje moraju da **pristupe istom skladištu**.
* **Ingress**: Ovo je konfiguracija koja se koristi za **izlaganje aplikacije javno sa URL-om**. Imajte na umu da se to takođe može uraditi korišćenjem spoljnih servisa, ali ovo je ispravan način za izlaganje aplikacije.
* Ako implementirate Ingress, moraćete da kreirate **Ingress kontrolere**. Ingress kontroler je **pod** koji će biti krajnja tačka koja će primati zahteve i proveravati ih i usmeravati ih ka servisima. Ingress kontroler će **slati zahtev na osnovu konfigurisanih pravila Ingress-a**. Imajte na umu da pravila Ingress-a mogu pokazivati na različite putanje ili čak poddomene ka različitim internim kubernetes servisima.
* Bolja praksa za bezbednost bila bi korišćenje cloud balansera opterećenja ili servera posrednika kao ulazne tačke kako ne bi bilo nijednog dela Kubernetes klastera izloženog.
* Kada se primi zahtev koji se ne podudara ni sa jednim pravilom Ingress-a, Ingress kontroler će ga usmeriti ka "**Podrazumevanom pozadini**". Možete `opisati` Ingress kontroler da biste dobili adresu ovog parametra.
* `minikube addons enable ingress`
### PKI infrastruktura - Sertifikacioni autoritet CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* CA je pouzdan koren za sve sertifikate unutar klastera.
* Omogućava komponentama da se međusobno validiraju.
* Svi sertifikati klastera su potpisani od strane CA.
* ETCd ima svoj sertifikat.
* Tipovi:
  * Sertifikat apiservera.
  * Sertifikat kubeleta.
  * Sertifikat planera.

## Osnovne radnje

### Minikube

**Minikube** se može koristiti za obavljanje **brzih testova** na Kubernetesu bez potrebe da se implementira ceo kubernetes okruženje. Pokrenuće **master i node procese na jednom računaru**. Minikube će koristiti virtualbox za pokretanje noda. Pogledajte [**ovde kako ga instalirati**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
😄  minikube v1.19.0 on Ubuntu 20.04
✨  Automatically selected the virtualbox driver. Other choices: none, ssh
💿  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
👍  Starting control plane node minikube in cluster minikube
💾  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
🔥  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
🐳  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
▪ Generating certificates and keys ...
▪ Booting up control plane ...
▪ Configuring RBAC rules ...
🔎  Verifying Kubernetes components...
▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
🌟  Enabled addons: storage-provisioner, default-storageclass
🏄  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
🔥  Deleting "minikube" in virtualbox ...
💀  Removed all traces of the "minikube" cluster
```
### Osnove Kubectl-a

**`Kubectl`** je alat za komandnu liniju za kubernetes klaster. Komunicira sa Api serverom glavnog procesa kako bi obavio radnje u kubernetesu ili zatražio podatke.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube kontrolna tabla

Kontrolna tabla vam omogućava da lakše vidite šta minikube pokreće, možete pronaći URL za pristup u:
```
minikube dashboard --url


🔌  Enabling dashboard ...
▪ Using image kubernetesui/dashboard:v2.3.1
▪ Using image kubernetesui/metrics-scraper:v1.0.7
🤔  Verifying dashboard health ...
🚀  Launching proxy ...
🤔  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### Primeri YAML konfiguracionih fajlova

Svaki konfiguracioni fajl ima 3 dela: **metadata**, **specifikaciju** (šta treba pokrenuti), **status** (željeno stanje).\
Unutar specifikacije konfiguracionog fajla za implementaciju, možete pronaći šablon definisan novom konfiguracionom strukturom koja definiše sliku za pokretanje:

**Primer implementacije + servisa deklarisanih u istom konfiguracionom fajlu (sa** [**ovde**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Pošto je servis obično povezan sa jednom implementacijom, moguće je deklarisati oba u istom konfiguracionom fajlu (servis deklarisan u ovom konfigu je dostupan samo interno):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Primer konfiguracije spoljnog servisa**

Ovaj servis će biti dostupan spolja (proverite atribute `nodePort` i `type: LoadBalancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
{% hint style="info" %}
Ovo je korisno za testiranje, ali za proizvodnju biste trebali imati samo interne usluge i Ingress za izlaganje aplikacije.
{% endhint %}

**Primer konfiguracionog fajla za Ingress**

Ovo će izložiti aplikaciju na `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Primer fajla sa tajnim podacima**

Obratite pažnju kako su lozinke enkodirane u B64 (što nije bezbedno!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Primer ConfigMape**

**ConfigMap** je konfiguracija koja se daje **pod**-ovima kako bi znali kako da pronađu i pristupe drugim uslugama. U ovom slučaju, svaki **pod** će znati da je ime `mongodb-service` adresa **poda** sa kojim mogu komunicirati (ovaj **pod** će izvršavati mongodb):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Zatim, unutar **konfiguracije implementacije** ovu adresu možete navesti na sledeći način kako bi bila učitana unutar okruženja čaure:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Primer konfiguracije zapremine**

Možete pronaći različite primere konfiguracije skladišta u yaml datotekama na [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Imajte na umu da zapremine nisu unutar imenskih prostora**

### Imenski prostori

Kubernetes podržava **višestruke virtuelne klaster** podržane istim fizičkim klasterom. Ovi virtuelni klasteri nazivaju se **imenski prostori**. Namijenjeni su za upotrebu u okruženjima sa mnogo korisnika raspoređenih po više timova ili projekata. Za klaster sa nekoliko desetina korisnika, ne biste trebali morati da kreirate ili razmišljate o imenskim prostorima. Trebali biste početi koristiti imenske prostore kako biste imali bolju kontrolu i organizaciju svakog dela aplikacije implementirane u Kubernetesu.

Imenski prostori pružaju opseg za imena. Imena resursa moraju biti jedinstvena unutar imenskog prostora, ali ne preko imenskih prostora. Imenski prostori ne mogu biti ugniježđeni jedan u drugi i **svaki** Kubernetes **resurs** može biti samo **u** **jednom** **imenskom** **prostoru**.

Postoje 4 imenska prostora podrazumevano ako koristite minikube:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
* **kube-system**: Nije namenjen korisnicima i ne biste trebali da ga dirate. Namijenjen je master i kubectl procesima.
* **kube-public**: Javno dostupni podaci. Sadrži configmap koji sadrži informacije o klasteru.
* **kube-node-lease**: Određuje dostupnost čvora.
* **default**: Prostor imena koji će korisnik koristiti za kreiranje resursa.
```bash
#Create namespace
kubectl create namespace my-namespace
```
{% hint style="info" %}
Imajte na umu da su većina Kubernetes resursa (npr. pods, services, replication controllers i drugi) u nekim namespace-ovima. Međutim, drugi resursi poput namespace resursa i resursa niskog nivoa, kao što su čvorovi i persistenVolumes, nisu u namespace-u. Da biste videli koji Kubernetes resursi jesu, a koji nisu u namespace-u:
```bash
kubectl api-resources --namespaced=true #In a namespace
kubectl api-resources --namespaced=false #Not in a namespace
```
{% endhint %}

Možete sačuvati namespace za sve naredne kubectl komande u tom kontekstu.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm je **menadžer paketa** za Kubernetes. Omogućava pakovanje YAML datoteka i distribuciju istih u javnim i privatnim repozitorijumima. Ovi paketi se nazivaju **Helm Charts**.
```
helm search <keyword>
```
## Kubernetes tajne

**Tajna** je objekat koji **sadrži osetljive podatke** kao što su lozinka, token ili ključ. Takve informacije bi inače mogle biti smeštene u specifikaciji Pod-a ili u slici. Korisnici mogu kreirati Tajne, a sistem takođe kreira Tajne. Ime objekta Tajne mora biti validno **DNS poddomensko ime**. Pročitajte ovde [zvaničnu dokumentaciju](https://kubernetes.io/docs/concepts/configuration/secret/).

Tajne mogu biti stvari poput:

* API, SSH ključevi.
* OAuth tokeni.
* Kredencijali, Lozinke (čisti tekst ili b64 + enkripcija).
* Informacije ili komentari.
* Kod za povezivanje sa bazom podataka, stringovi… .

Postoje različite vrste tajni u Kubernetes-u

| Ugrađena Vrsta                      | Upotreba                                   |
| ----------------------------------- | ----------------------------------------- |
| **Opaq**                            | **proizvoljni podaci definisani od strane korisnika (Podrazumevano)** |
| kubernetes.io/service-account-token | token za servisni nalog                     |
| kubernetes.io/dockercfg             | serijalizovan \~/.dockercfg fajl             |
| kubernetes.io/dockerconfigjson      | serijalizovan \~/.docker/config.json fajl    |
| kubernetes.io/basic-auth            | kredencijali za osnovnu autentikaciju      |
| kubernetes.io/ssh-auth              | kredencijali za SSH autentikaciju        |
| kubernetes.io/tls                   | podaci za TLS klijenta ili server           |
| bootstrap.kubernetes.io/token       | podaci o početnom tokenu                      |

{% hint style="info" %}
**Opaq tip je podrazumevani, tipičan par ključ-vrednost definisan od strane korisnika.**
{% endhint %}

**Kako tajne funkcionišu:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

Sledeći konfiguracioni fajl definiše **tajnu** nazvanu `mysecret` sa 2 parova ključ-vrednost `korisničko_ime: YWRtaW4=` i `lozinka: MWYyZDFlMmU2N2Rm`. Takođe definiše **pod** nazvan `secretpod` koji će imati `korisničko_ime` i `lozinku` definisane u `mysecret` izložene u **promenljivim okruženja** `SECRET_USERNAME` i `SECRET_PASSWOR`. Takođe će **montirati** tajnu `korisničko_ime` unutar `mysecret` na putanju `/etc/foo/my-group/my-username` sa dozvolama `0640`.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```
{% endcode %}
```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Tajne u etcd <a href="#otkrij-tajne-u-etcd" id="otkrij-tajne-u-etcd"></a>

**etcd** je dosledno i visoko dostupno **skladište ključ-vrednost** koje se koristi kao Kubernetes podrška za sve podatke klastera. Hajde da pristupimo tajnama koje su smeštene u etcd:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Videćete da se sertifikati, ključevi i URL-ovi nalaze na FS-u. Kada ih dobijete, bićete u mogućnosti da se povežete sa etcd-om.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Kada uspostavite komunikaciju, bićete u mogućnosti da dobijete tajne:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Dodavanje šifrovanja ETCD-u**

Podrazumevano, svi tajni podaci se **čuvaju u običnom** tekstu unutar etcd-a, osim ako ne primenite sloj šifrovanja. Sledeći primer je zasnovan na [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
{% endcode %}

Nakon toga, morate postaviti `--encryption-provider-config` zastavicu na `kube-apiserver` da pokazuje na lokaciju kreiranog konfiguracionog fajla. Možete izmeniti `/etc/kubernetes/manifest/kube-apiserver.yaml` i dodati sledeće linije:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Pomerite se nadole u volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Pomerite se nadole u volumeMounts do hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Provera da su podaci šifrovani**

Podaci se šifruju prilikom upisa u etcd. Nakon ponovnog pokretanja vašeg `kube-apiserver`, svaki novo kreirani ili ažurirani tajni podatak trebao bi biti šifrovan prilikom čuvanja. Da biste proverili, možete koristiti `etcdctl` komandnu liniju programa da biste dobili sadržaj vaše tajne.

1. Kreirajte novu tajnu nazvanu `secret1` u `default` namespace-u:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```
2. Koristeći etcdctl komandnu liniju, pročitajte tu tajnu iz etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

gde `[...]` moraju biti dodatni argumenti za povezivanje sa etcd serverom.
3. Proverite da li je sačuvana tajna prefiksirana sa `k8s:enc:aescbc:v1:` što ukazuje da je `aescbc` pružalac šifrovao rezultirajuće podatke.
4. Proverite da li je tajna ispravno dešifrovana prilikom dobijanja putem API-ja:

```
kubectl describe secret secret1 -n default
```

trebalo bi da se poklopi sa `mykey: bXlkYXRh`, mydata je kodiran, proverite [dekodiranje tajne](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) da biste potpuno dekodirali tajnu.

**Pošto su tajne šifrovane prilikom upisa, izvršavanje ažuriranja na tajni će šifrovati taj sadržaj:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Konačni saveti:**

* Pokušajte da ne čuvate tajne u FS-u, preuzmite ih sa drugih mesta.
* Posetite [https://www.vaultproject.io/](https://www.vaultproject.io) kako biste dodali više zaštite svojim tajnama.
* [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
* [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm)

## Reference

{% embed url="https://sickrov.github.io/" %}

{% embed url="https://www.youtube.com/watch?v=X48VuDVv0do" %}

{% hint style="success" %}
Naučite i vežbajte hakovanje AWS:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Naučite i vežbajte hakovanje GCP-a: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
