# Kubernetes Basiese

## Kubernetes Basiese

{% hint style="success" %}
Leer & oefen AWS Hack: <img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Leer & oefen GCP Hack: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kontroleer die [**inskrywingsplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** 💬 [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
{% endhint %}

**Die oorspronklike skrywer van hierdie bladsy is** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(lees sy oorspronklike pos** [**hier**](https://sickrov.github.io)**)**

## Argitektuur & Basiese Konsepte

### Wat doen Kubernetes?

* Maak dit moontlik om houer(s) in 'n houermotor te hardloop.
* Skeduleer houers missie-effektief.
* Hou houers aan die gang.
* Maak houer kommunikasie moontlik.
* Maak implementeringstegnieke moontlik.
* Hanteer groot hoeveelhede inligting.

### Argitektuur

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **Node**: bedryfstelsel met 'n peul of peule.
* **Peul**: Omhulsel rondom 'n houer of meerdere houers. 'n Peul behoort slegs een aansoek te bevat (so gewoonlik hardloop 'n peul net 1 houer). Die peul is die manier waarop Kubernetes die houer tegnologie hardloop.
* **Diens**: Elke peul het 1 interne **IP-adres** uit die interne reeks van die node. Dit kan egter ook blootgestel word via 'n diens. Die **diens het ook 'n IP-adres** en die doel daarvan is om die kommunikasie tussen peule te handhaaf sodat as een sterf die **nuwe vervanging** (met 'n ander interne IP) **toeganklik sal wees** blootgestel in dieselfde IP van die diens. Dit kan as intern of ekstern gekonfigureer word. Die diens tree ook op as 'n **laaibalansierder wanneer 2 peule aan dieselfde diens gekoppel is**.\
Wanneer 'n **diens** **geskep** word, kan jy die eindpunte van elke diens vind wat hardloop `kubectl get endpoints`
* **Kubelet**: Primêre node-agent. Die komponent wat kommunikasie tussen node en kubectl vestig, en kan slegs peule hardloop (deur API-bediener). Die kubelet bestuur nie houers wat nie deur Kubernetes geskep is nie.
* **Kube-proxy**: is die diens wat verantwoordelik is vir die kommunikasie (dienste) tussen die API-bediener en die node. Die basis is 'n IP-tabelle vir nodes. Mees ervare gebruikers kan ander kube-proxies van ander verskaffers installeer.
* **Sykamerhouer**: Sykamerhouers is die houers wat saam met die hoofhouer in die peul moet hardloop. Hierdie sykamerpatroon brei uit en verbeter die funksionaliteit van huidige houers sonder om hulle te verander. Vandag weet ons dat ons houertegnologie gebruik om al die afhanklikhede vir die aansoek in te sluit sodat dit oral kan hardloop. 'n Houer doen net een ding en doen daardie ding baie goed.
* **Meesterprosesse:**
* **Api-bediener:** Is die manier waarop gebruikers en peule kommunikeer met die meesterproses. Slegs geoutentiseerde versoek moet toegelaat word.
* **Skeduleerder**: Skedulering verwys na die versekering dat Peule aan Nodes gekoppel word sodat Kubelet hulle kan hardloop. Dit het genoeg intelligensie om te besluit watter node meer beskikbare hulpbronne het om die nuwe peul daaraan toe te ken. Let daarop dat die skeduleerder nie nuwe peule begin nie, dit kommunikeer net met die Kubelet-proses wat binne die node hardloop, wat die nuwe peul sal begin.
* **Kube-beheerder vir kontrole**: Dit kontroleer hulpbronne soos replikasette of implementeringe om te kontroleer of, byvoorbeeld, die regte aantal peule of nodes hardloop. In die geval dat 'n peul ontbreek, sal dit kommunikeer met die skeduleerder om 'n nuwe een te begin. Dit beheer replikasie, tokens, en rekeningsdienste na die API.
* **etcd**: Data berging, volhoubaar, konsekwent, en verspreid. Is Kubernetes se databasis en die sleutel-waarde berging waar dit die volledige toestand van die groepe hou (elke verandering word hier aangeteken). Komponente soos die Skeduleerder of die Beheerder hang af van hierdie datum om te weet watter veranderinge plaasgevind het (beskikbare hulpbronne van die nodes, aantal peule wat hardloop...)
* **Wolkbeheerder vir kontrole**: Is die spesifieke beheerder vir vloeibeheer en aansoeke, bv: as jy groepe in AWS of OpenStack het.

Let daarop dat daar dalk verskeie nodes kan wees (wat verskeie peule hardloop), daar kan ook verskeie meesterprosesse wees waar hul toegang tot die Api-bediener gebalanseer word en hul etcd gesinkroniseer word.

**Volumes:**

Wanneer 'n peul data skep wat nie verlore mag gaan wanneer die peul verdwyn nie, moet dit gestoor word in 'n fisiese volume. **Kubernetes maak dit moontlik om 'n volume aan 'n peul te heg om die data te behou**. Die volume kan op die plaaslike masjien of in 'n **afgeleë berging** wees. As jy peule op verskillende fisiese nodes hardloop, moet jy 'n afgeleë berging gebruik sodat al die peule daartoe toegang kan hê.

**Ander konfigurasies:**

* **ConfigMap**: Jy kan **URL's** konfigureer om dienste te bereik. Die peul sal data hiervandaan verkry om te weet hoe om met die res van die dienste (peule) te kommunikeer. Let daarop dat dit nie die aanbevole plek is om wagwoorde te stoor nie!
* **Geheim**: Dit is die plek om **geheime data** soos wagwoorde, API-sleutels... gekodeer in B64 te stoor. Die peul sal toegang hê tot hierdie data om die vereiste geloofsbriewe te gebruik.
* **Implementeringe**: Dit is waar die komponente wat deur Kubernetes uitgevoer moet word, aangedui word. 'n Gebruiker sal gewoonlik nie direk met peule werk nie, peule word geabstraheer in **ReplicaSets** (aantal dieselfde peule gerepliseer), wat via implementeringe hardloop. Let daarop dat implementeringe vir **stateless** aansoeke is. Die minimum konfigurasie vir 'n implementering is die naam en die beeld om uit te voer.
* **StatefulSet**: Hierdie komponent is spesifiek bedoel vir aansoeke soos **databasisse** wat toegang tot dieselfde berging benodig.
* **Ingress**: Dit is die konfigurasie wat gebruik word om die aansoek openlik met 'n URL bloot te stel. Let daarop dat dit ook gedoen kan word deur eksterne dienste, maar dit is die korrekte manier om die aansoek bloot te stel.
* As jy 'n Ingress implementeer, sal jy **Ingress-beheerders** moet skep. Die Ingress-beheerder is 'n **peul** wat die eindpunt sal wees wat die versoek sal ontvang en sal kontroleer en dit sal laaibalanseer na die dienste. die ingress-beheerder sal die versoek stuur op grond van die ingestelde ingress-reëls. Let daarop dat die ingress-reëls na verskillende paaie of selfs subdomeine na verskillende interne kubernetes-dienste kan verwys.
* 'n Betere veiligheidspraktyk sou wees om 'n wolklaaibalanseerder of 'n proksi-bediener as toegangspunt te gebruik om te voorkom dat enige deel van die Kubernetes-groep blootgestel word.
* Wanneer 'n versoek ontvang word wat nie met enige ingress-reël ooreenstem nie, sal die ingress-beheerder dit na die "**Verstek agterkant**" rig. Jy kan die ingress-beheerder `beskryf` om die adres van hierdie parameter te kry.
* `minikube addons enable ingress`
### PKI-infrastruktuur - Sertifikaatowerheid CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* CA is die vertroude wortel vir alle sertifikate binne die groep.
* Laat komponente toe om aan mekaar te valideer.
* Alle groep sertifikate word deur die CA onderteken.
* ETCd het sy eie sertifikaat.
* tipes:
  * apiserver sert.
  * kubelet sert.
  * skeduleerder sert.

## Basiese Aksies

### Minikube

**Minikube** kan gebruik word om sommige **vinnige toetse** op kubernetes uit te voer sonder om 'n hele kubernetes-omgewing te ontplooi. Dit sal die **meester en node prosesse op een masjien** hardloop. Minikube sal virtualbox gebruik om die node te hardloop. Sien [**hier hoe om dit te installeer**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
😄  minikube v1.19.0 on Ubuntu 20.04
✨  Automatically selected the virtualbox driver. Other choices: none, ssh
💿  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
👍  Starting control plane node minikube in cluster minikube
💾  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
🔥  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
🐳  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
▪ Generating certificates and keys ...
▪ Booting up control plane ...
▪ Configuring RBAC rules ...
🔎  Verifying Kubernetes components...
▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
🌟  Enabled addons: storage-provisioner, default-storageclass
🏄  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
🔥  Deleting "minikube" in virtualbox ...
💀  Removed all traces of the "minikube" cluster
```
### Kubectl Basies

**`Kubectl`** is die opdraggereelwerktuig vir kubernetes-klusters. Dit kommunikeer met die Api-bediener van die meesterproses om aksies in kubernetes uit te voer of om vir data te vra.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube Dashboard

Die dashboard laat jou toe om makliker te sien wat minikube aan die hardloop is, jy kan die URL vind om dit te benader in:
```
minikube dashboard --url


🔌  Enabling dashboard ...
▪ Using image kubernetesui/dashboard:v2.3.1
▪ Using image kubernetesui/metrics-scraper:v1.0.7
🤔  Verifying dashboard health ...
🚀  Launching proxy ...
🤔  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### YAML konfigurasie lêer voorbeelde

Elke konfigurasie lêer het 3 dele: **metadata**, **spesifikasie** (wat moet begin), **status** (gewenste toestand).\
Binne die spesifikasie van die implementeringskonfigurasie lêer kan jy die sjabloon vind wat gedefinieer is met 'n nuwe konfigurasie struktuur wat die beeld om te hardloop definieer:

**Voorbeeld van Implementering + Diens wat in dieselfde konfigurasie lêer verklaar is (van** [**hier**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Aangesien 'n diens gewoonlik verband hou met een implementering, is dit moontlik om beide in dieselfde konfigurasie lêer te verklaar (die diens wat in hierdie konfigurasie verklaar is, is slegs intern toeganklik):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Voorbeeld van eksterne dienskonfigurasie**

Hierdie diens sal eksterne toeganklik wees (kontroleer die `nodePort` en `type: LoadBlancer` eienskappe):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
{% hint style="info" %}
Dit is nuttig vir toetsdoeleindes, maar vir produksie behoort jy slegs interne dienste en 'n Ingress te hê om die aansoek bloot te stel.
{% endhint %}

**Voorbeeld van 'n Ingress konfigurasie lêer**

Dit sal die aansoek blootstel op `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Voorbeeld van geheime konfigurasie lêer**

Merk op hoe die wagwoorde in B64 gekodeer is (wat nie veilig is nie!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Voorbeeld van ConfigMap**

'n **ConfigMap** is die konfigurasie wat aan die pods gegee word sodat hulle weet hoe om ander dienste te vind en toegang te verkry. In hierdie geval sal elke pod weet dat die naam `mongodb-service` die adres van 'n pod is waarmee hulle kan kommunikeer (hierdie pod sal 'n mongodb uitvoer):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Dan, binne 'n **implementeringskonfigurasie** kan hierdie adres op die volgende manier gespesifiseer word sodat dit binne die omgewingsveranderlikes van die houer gelaai word:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Voorbeeld van volume konfigurasie**

Jy kan verskillende voorbeelde van stoor konfigurasie yaml lêers vind in [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Let daarop dat volumes nie binne namespaces is nie**

### Namespaces

Kubernetes ondersteun **meervoudige virtuele groepe** ondersteun deur dieselfde fisiese groep. Hierdie virtuele groepe word **namespaces** genoem. Dit is bedoel vir gebruik in omgewings met baie gebruikers versprei oor verskeie spanne of projekte. Vir groepe met 'n paar tot tientalle gebruikers, behoort jy nie nodig te hê om namespaces te skep of daaroor te dink nie. Jy behoort net namespaces te begin gebruik om 'n beter beheer en organisasie van elke deel van die aansoek wat in kubernetes ontplooi is, te hê.

Namespaces voorsien 'n omvang vir name. Name van hulpbronne moet uniek wees binne 'n namespace, maar nie oor namespaces nie. Namespaces kan nie binne mekaar geneste word nie en **elke** Kubernetes **hulpbron** kan slegs **in** **een** **namespace** wees.

Daar is 4 namespaces standaard as jy minikube gebruik:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
* **kube-system**: Dit is nie bedoel vir die gebruikers om te gebruik nie en jy moet dit nie aanraak nie. Dit is vir meester en kubectl prosesse.
* **kube-public**: Publiek toeganklike data. Bevat 'n configmap wat klasteinligting bevat.
* **kube-node-lease**: Bepaal die beskikbaarheid van 'n node.
* **default**: Die naamruimte wat die gebruiker sal gebruik om hulpbronne te skep.
```bash
#Create namespace
kubectl create namespace my-namespace
```
{% hint style="info" %}
Let daarop dat die meeste Kubernetes-bronne (bv. peule, dienste, replikasie kontroleerders, en ander) in sekere benamings is. Ander bronne soos benamingsbronne en laevlakbronne, soos nodes en volgehoue volumes, is egter nie in 'n benaming nie. Om te sien watter Kubernetes-bronne wel en nie in 'n benaming is nie:
```bash
kubectl api-resources --namespaced=true #In a namespace
kubectl api-resources --namespaced=false #Not in a namespace
```
{% endhint %}

Jy kan die namespace vir alle volgende kubectl-opdragte in daardie konteks stoor.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm is die **pakketbestuurder** vir Kubernetes. Dit maak dit moontlik om YAML-lêers te pakketteer en hulle in openbare en private repositories te versprei. Hierdie pakkette word **Helm-diagramme** genoem.
```
helm search <keyword>
```
## Kubernetes geheime

'n **Geheim** is 'n objek wat **sensitiewe data** soos 'n wagwoord, 'n token of 'n sleutel bevat. Sulke inligting kan andersins in 'n Pod-spesifikasie of in 'n beeld geplaas word. Gebruikers kan Geheime skep en die stelsel skep ook Geheime. Die naam van 'n Geheim objek moet 'n geldige **DNS subdomein naam** wees. Lees hier [die amptelike dokumentasie](https://kubernetes.io/docs/concepts/configuration/secret/).

Geheime kan dinge wees soos:

* API, SSH-sleutels.
* OAuth tokens.
* Gelde, Wagwoorde (plat teks of b64 + enkripsie).
* Inligting of kommentaar.
* Databasis verbindingskode, strings... .

Daar is verskillende tipes geheime in Kubernetes

| Ingeboude Tipe                      | Gebruik                                    |
| ----------------------------------- | ------------------------------------------ |
| **Opaak**                           | **willekeurige gebruiker-gedefinieerde data (Verstek)** |
| kubernetes.io/service-account-token | diensrekening token                       |
| kubernetes.io/dockercfg             | geserializeerde \~/.dockercfg lêer         |
| kubernetes.io/dockerconfigjson      | geserializeerde \~/.docker/config.json lêer|
| kubernetes.io/basic-auth            | geloofsbriewe vir basiese outentifikasie   |
| kubernetes.io/ssh-auth              | geloofsbriewe vir SSH outentifikasie       |
| kubernetes.io/tls                   | data vir 'n TLS-kliënt of bediener         |
| bootstrap.kubernetes.io/token       | opstart token data                         |

{% hint style="info" %}
**Die Opaak tipe is die verstek een, die tipiese sleutel-waarde paar gedefinieer deur gebruikers.**
{% endhint %}

**Hoe geheime werk:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

Die volgende konfigurasie lêer definieer 'n **geheim** genaamd `mysecret` met 2 sleutel-waarde pare `gebruikersnaam: YWRtaW4=` en `wagwoord: MWYyZDFlMmU2N2Rm`. Dit definieer ook 'n **pod** genaamd `secretpod` wat die `gebruikersnaam` en `wagwoord` wat in `mysecret` gedefinieer is, blootgestel sal hê in die **omgewingsveranderlikes** `SECRET_USERNAME` en `SECRET_PASSWOR`. Dit sal ook die `gebruikersnaam` geheim binne `mysecret` monteer in die pad `/etc/foo/my-group/my-username` met `0640` toestemmings.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```
{% endcode %}
```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Geheime in etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** is 'n konsekwente en hoogs beskikbare **sleutel-waarde stoor** wat gebruik word as die Kubernetes agterste stoor vir alle groep data. Laat ons toegang kry tot die geheime wat in etcd gestoor is:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Jy sal sertifikate, sleutels en URL's sien waar hulle in die FS geleë is. Sodra jy dit het, sal jy in staat wees om met etcd te verbind.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Sodra jy kommunikasie tot stand bring, sal jy in staat wees om die geheime te kry:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Voeg versleuteling by die ETCD**

Standaard word alle geheime inligting as **plat teks** binne etcd gestoor tensy jy 'n versleutelingslaag toepas. Die volgende voorbeeld is gebaseer op [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
{% endcode %}

Daarna moet jy die `--encryption-provider-config` vlag instel op die `kube-apiserver` om te wys na die ligging van die geskepte opsetlêer. Jy kan `/etc/kubernetes/manifest/kube-apiserver.yaml` wysig en die volgende lyne byvoeg:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Gly omlaag in die volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Gaan af in die volumeMounts na hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Verifieer dat data versleutel is**

Data is versleutel wanneer dit na etcd geskryf word. Na die heraanvang van jou `kube-apiserver`, behoort enige nuut geskep of opgedateerde geheim versleutel te wees wanneer dit gestoor word. Om te kontroleer, kan jy die `etcdctl` opdraglynprogram gebruik om die inhoud van jou geheim te herwin.

1. Skep 'n nuwe geheim genaamd `secret1` in die `default` namespace:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```
2. Gebruik die etcdctl opdraglyn, lees daardie geheim uit etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

waar `[...]` die bykomende argumente moet wees vir die koppeling met die etcd-bediener.
3. Verifieer dat die gestoorde geheim voorafgegaan word deur `k8s:enc:aescbc:v1:` wat aandui dat die `aescbc` verskaffer die resulterende data versleutel het.
4. Verifieer dat die geheim korrek ontsluit word wanneer dit deur die API herwin word:

```
kubectl describe secret secret1 -n default
```

behoort ooreen te stem met `mykey: bXlkYXRh`, mydata is gekodeer, kontroleer [ontkoding van 'n geheim](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) om die geheim heeltemal te ontsluit.

**Aangesien geheime versleutel word tydens skryf, sal die uitvoer van 'n opdatering op 'n geheim daardie inhoud versleutel:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Laaste wenke:**

* Probeer om nie geheime in die FS te hou nie, kry hulle van ander plekke af.
* Kyk na [https://www.vaultproject.io/](https://www.vaultproject.io) om ekstra beskerming by jou geheime te voeg.
* [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
* [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm)

## Verwysings

{% embed url="https://sickrov.github.io/" %}

{% embed url="https://www.youtube.com/watch?v=X48VuDVv0do" %}

{% hint style="success" %}
Leer & oefen AWS Hack: <img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Leer & oefen GCP Hack: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**inskrywingsplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** 💬 [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacktruuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
