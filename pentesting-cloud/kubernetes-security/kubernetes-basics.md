# Kubernetes Temelleri

## Kubernetes Temelleri

{% hint style="success" %}
AWS Hacking öğrenin ve uygulayın:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Eğitim AWS Kırmızı Takım Uzmanı (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCP Hacking öğrenin ve uygulayın: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Eğitim GCP Kırmızı Takım Uzmanı (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**Abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarını paylaşarak PR'ler göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
{% endhint %}

**Bu sayfanın orijinal yazarı** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(orijinal yazısını** [**buradan**](https://sickrov.github.io)** okuyun)**

## Mimarlık ve Temeller

### Kubernetes'ın Görevleri Nelerdir?

* Bir veya birden fazla konteyneri bir konteyner motorunda çalıştırmayı sağlar.
* Konteynerleri etkin bir şekilde planlar.
* Konteynerleri çalışır durumda tutar.
* Konteynerler arasında iletişimi sağlar.
* Dağıtım tekniklerine izin verir.
* Bilgi hacimlerini yönetir.

### Mimarlık

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **Node**: bir veya birden fazla pod ile işletim sistemi.
* **Pod**: Bir veya birden fazla konteynerle sarılmış bir yapı. Bir pod yalnızca bir uygulama içermelidir (bu nedenle genellikle bir pod yalnızca 1 konteyner çalıştırır). Pod, konteyner teknolojisini çalıştıran Kubernetes'in soyutlama şeklidir.
* **Servis**: Her pod'un, düğümün içindeki dahili bir **IP adresi** vardır. Bununla birlikte, servis aracılığıyla da dışa açılabilir. **Servisin de bir IP adresi vardır** ve amacı podlar arasındaki iletişimi sürdürmektir, böylece biri öldüğünde **yeni bir yedek** (farklı bir dahili IP ile) **servisin aynı IP'sinde erişilebilir olacaktır**. Servis iç veya dış olarak yapılandırılabilir. Servis, 2 pod aynı servise bağlandığında bir **yük dengeleyici olarak da hareket eder**.\
Bir **servis** **oluşturulduğunda**, her servisin uç noktalarını `kubectl get endpoints` komutunu çalıştırarak bulabilirsiniz.
* **Kubelet**: Ana düğüm ajanı. Düğüm ve kubectl arasında iletişim kuran bileşen ve yalnızca podları çalıştırabilir (API sunucusu aracılığıyla). Kubelet, Kubernetes tarafından oluşturulmayan konteynerleri yönetmez.
* **Kube-proxy**: apisunucusu ve düğüm arasındaki iletişimlerden sorumlu olan servistir. Temel olarak düğümler için bir IPtables'tır. Deneyimli kullanıcılar diğer satıcıların kube-proxy'lerini de kurabilir.
* **Sidecar konteyner**: Sidecar konteynerleri, ana konteynerle birlikte çalıştırılması gereken konteynerlerdir. Bu sidecar deseni, mevcut konteynerlerin işlevselliğini genişletir ve geliştirir ve bunları değiştirmeden günceller. Günümüzde, uygulamanın her yerde çalışması için tüm bağımlılıkları sarmak için konteyner teknolojisini kullandığımızı biliyoruz. Bir konteyner yalnızca bir şey yapar ve bu işi çok iyi yapar.
* **Ana işlem:**
* **API Sunucusu:** Kullanıcıların ve podların ana işlemle iletişim kurmak için kullandığı yol. Yalnızca kimlik doğrulama yapılmış isteklere izin verilmelidir.
* **Zamanlayıcı**: Pod'ların Kubelet tarafından çalıştırılabilmesi için Pod'ların Düğümlere eşleştirildiğinden emin olma işlemine atıfta bulunur. Hangi düğümün daha fazla kullanılabilir kaynağa sahip olduğuna karar vermek için yeterli zekaya sahiptir ve yeni pod'u bu düğüme atar. Zamanlayıcı yeni pod başlatmaz, yalnızca yeni pod'u başlatacak olan düğüm içinde çalışan Kubelet işlemiyle iletişim kurar.
* **Kube Denetleyici Yöneticisi**: Örneğin, doğru sayıda pod veya düğümün çalıştırılıp çalıştırılmadığını kontrol etmek için replika setleri veya dağıtımlar gibi kaynakları kontrol eder. Bir pod eksikse, yeni bir tane başlatmak için zamanlayıcıyla iletişim kurar. API'ya replikasyon, belirteçler ve hesap hizmetleri kontrol eder.
* **etcd**: Veri depolama, kalıcı, tutarlı ve dağıtılmıştır. Kubernetes'in veritabanıdır ve kümenin tam durumunu tuttuğu anahtar-değer depolama alanıdır (her değişiklik buraya kaydedilir). Zamanlayıcı veya Denetleyici Yöneticisi gibi bileşenler, hangi değişikliklerin meydana geldiğini bilmek için bu verilere bağımlıdır (düğümlerin mevcut kaynakları, çalışan pod sayısı...).
* **Bulut denetleyici yöneticisi**: Akış kontrolleri ve uygulamalar için özel denetleyicidir, örneğin: AWS veya OpenStack'te kümeleriniz varsa.

Birçok düğüm olabileceği gibi (birçok pod çalıştıran), aynı zamanda yük dengeleyiciye erişimleri yük dengeleyici ve etcd'leri senkronize edilen birkaç ana işlem olabilir.

**Hacimler:**

Bir pod, pod kaybolduğunda kaybolmaması gereken veriler oluşturduğunda, bu verilerin saklanması için bir fiziksel hacme bağlanmasına izin verir. **Kubernetes, verileri korumak için bir pod'a bir hacim eklemeyi sağlar**. Hacim yerel makinede veya **uzak depolama**da olabilir. Farklı fiziksel düğümlerde pod'ları çalıştırıyorsanız, tüm pod'ların buna erişebilmesi için uzak depolama kullanmalısınız.

**Diğer yapılandırmalar:**

* **ConfigMap**: Servislere erişmek için **URL'leri yapılandırabilirsiniz**. Pod, buradan veri alarak diğer servislerle (podlarla) nasıl iletişim kuracağını bilecektir. Bu yer kimlik bilgilerini saklamak için önerilen yer değildir!
* **Secret**: Bu, şifreler, API anahtarları gibi **gizli verileri saklamak için** yerdir, B64 ile kodlanmıştır. Pod, gerekli kimlik bilgilerini kullanmak için bu verilere erişebilecektir.
* **Dağıtımlar**: Kubernetes tarafından çalıştırılacak bileşenlerin belirtildiği yerdir. Bir kullanıcı genellikle doğrudan pod'larla çalışmaz, pod'lar **ReplicaSet'lerde** (çoğaltılan aynı pod sayısı) soyutlanır ve dağıtımlar aracılığıyla çalıştırılır. Dağıtımların **durumsuz** uygulamalar için olduğunu unutmayın. Bir dağıtım için minimum yapılandırma adı ve çalıştırılacak görüntüdür.
* **StatefulSet**: Bu bileşen, **veritabanları** gibi **aynı depolama alanına erişim gerektiren** uygulamalar için özel olarak tasarlanmıştır.
* **Ingress**: Bu, uygulamanın **URL ile halka açılmasını yapılandırmak için** kullanılan yapılandırmadır. Bu, harici servisler kullanılarak da yapılabilir, ancak uygulamanın açılması için doğru yol budur.
* Bir Ingress uygularsanız **Ingress Denetleyicileri** oluşturmanız gerekecektir. Ingress Denetleyicisi, istekleri alacak ve kontrol edecek bir **pod** olacaktır ve bunları hizmetlere yük dengeleyecektir. Ingress denetleyicisi, **yapılandırılan ingress kurallarına göre isteği yönlendirecektir**. Ingress kuralları farklı yollara veya hatta farklı dahili kubernetes servislerine farklı alt alanlara işaret edebilir.
* Daha iyi bir güvenlik uygulaması, Kubernetes kümesinin herhangi bir bölümünün açıkta olmaması için giriş noktası olarak bir bulut yük dengeleyici veya bir proxy sunucusu kullanmaktır.
* Eşleşmeyen bir ingress kuralı alan bir istek alındığında, ingress denetleyicisi bunu "**Varsayılan arka uca**" yönlendirecektir. Bu parametrenin adresini almak için ingress denetleyicisini `describe` edebilirsiniz.
* `minikube addons enable ingress`
### PKI altyapısı - Sertifika Otoritesi CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* CA, küme içindeki tüm sertifikalar için güvenilir köktür.
* Bileşenlerin birbirini doğrulamasına izin verir.
* Tüm küme sertifikaları CA tarafından imzalanmıştır.
* ETCd'nin kendi sertifikası vardır.
* türler:
  * apiserver sertifikası.
  * kubelet sertifikası.
  * scheduler sertifikası.

## Temel Eylemler

### Minikube

**Minikube**, tüm bir kubernetes ortamını dağıtmaya gerek olmadan kubernetes üzerinde bazı **hızlı testler** yapmak için kullanılabilir. **Master ve node işlemlerini aynı makinede çalıştıracaktır**. Minikube, düğümü çalıştırmak için virtualbox'ı kullanacaktır. [**Buradan nasıl kurulacağını**](https://minikube.sigs.k8s.io/docs/start/) görün.
```
$ minikube start
😄  minikube v1.19.0 on Ubuntu 20.04
✨  Automatically selected the virtualbox driver. Other choices: none, ssh
💿  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
👍  Starting control plane node minikube in cluster minikube
💾  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
🔥  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
🐳  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
▪ Generating certificates and keys ...
▪ Booting up control plane ...
▪ Configuring RBAC rules ...
🔎  Verifying Kubernetes components...
▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
🌟  Enabled addons: storage-provisioner, default-storageclass
🏄  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
🔥  Deleting "minikube" in virtualbox ...
💀  Removed all traces of the "minikube" cluster
```
### Kubectl Temelleri

**`Kubectl`**, kubernetes kümeleri için komut satırı aracıdır. Kubernetes'te işlemler gerçekleştirmek veya veri istemek için ana işlem Api sunucusu ile iletişim kurar.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube Kontrol Paneli

Kontrol paneli, minikube'un ne çalıştığını daha kolay görmek için size olanak tanır, erişmek için URL'yi aşağıda bulabilirsiniz:
```
minikube dashboard --url


🔌  Enabling dashboard ...
▪ Using image kubernetesui/dashboard:v2.3.1
▪ Using image kubernetesui/metrics-scraper:v1.0.7
🤔  Verifying dashboard health ...
🚀  Launching proxy ...
🤔  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### YAML yapılandırma dosyaları örnekleri

Her yapılandırma dosyası 3 bölüme sahiptir: **metadata**, **specification** (başlatılması gerekenler), **status** (istenen durum).\
Dağıtım yapılandırma dosyasının özellikleri içinde, çalıştırılacak görüntüyü tanımlayan yeni bir yapılandırma yapısı ile tanımlanan şablonu bulabilirsiniz:

**Aynı yapılandırma dosyasında bildirilen Dağıtım + Servis örneği (buradan** [**buraya**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Bir servis genellikle bir dağıtımla ilişkilidir, bu nedenle her ikisi de aynı yapılandırma dosyasında bildirilebilir (bu yapılandırmada bildirilen servis yalnızca dahili olarak erişilebilir):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Dış hizmet yapılandırmasının bir örneği**

Bu hizmet dışarıdan erişilebilir olacaktır (`nodePort` ve `type: LoadBalancer` özniteliklerini kontrol edin):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
{% hint style="info" %}
Bu test etmek için faydalıdır ancak üretim için yalnızca dahili hizmetlere ve uygulamayı açığa çıkarmak için bir Girişe sahip olmalısınız.
{% endhint %}

**Giriş yapılandırma dosyası örneği**

Bu, uygulamayı `http://dashboard.com` adresinde açığa çıkaracaktır.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Gizli yapılandırma dosyası örneği**

Şifrelerin B64'te kodlandığına dikkat edin (bu güvenli değil!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**ConfigMap Örneği**

Bir **ConfigMap**, pod'lara verilen yapılandırmadır, böylece diğer hizmetlere nasıl erişileceğini ve bulunacağını bilirler. Bu durumda, her bir pod, `mongodb-service` adının, iletişim kurabilecekleri bir podun adresi olduğunu bilecektir (bu pod bir mongodb çalıştıracaktır):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Ardından, bu adres bir **dağıtım yapılandırması** içinde aşağıdaki şekilde belirtilebilir, böylece pod'un env içine yüklenir:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Hacim yapılandırması örneği**

Depolama yapılandırma yaml dosyalarının farklı örneklerini [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes) adresinde bulabilirsiniz.\
**Hacimlerin ad alanlarının içinde olmadığını** unutmayın

### Ad Alanları

Kubernetes, aynı fiziksel küme tarafından desteklenen **çoklu sanal kümeleri** destekler. Bu sanal kümeler **ad alanları** olarak adlandırılır. Bunlar, birçok kullanıcının birden fazla takıma veya projeye yayıldığı ortamlarda kullanılmak üzere tasarlanmıştır. Birkaç ila onlarca kullanıcısı olan kümeler için, ad alanları oluşturmanıza veya düşünmenize gerek yoktur. Kubernetes'te dağıtılan uygulamanın her bölümünü daha iyi kontrol etmek ve düzenlemek için ad alanlarını kullanmaya başlamalısınız.

Ad alanları, isimler için bir kapsam sağlar. Kaynakların isimleri bir ad alanı içinde benzersiz olmalıdır, ancak ad alanları arasında olmamalıdır. Ad alanları birbirinin içine gömülemez ve **her** Kubernetes **kaynağı** yalnızca **bir** **ad alınında** olabilir.

Minikube kullanıyorsanız varsayılan olarak 4 ad alanı bulunmaktadır:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
* **kube-system**: Kullanıcılar için değil, ustalar ve kubectl işlemleri içindir ve dokunulmamalıdır.
* **kube-public**: Genel olarak erişilebilir veriler. Küme bilgilerini içeren bir configmap içerir.
* **kube-node-lease**: Bir düğümün kullanılabilirliğini belirler.
* **default**: Kullanıcının kaynak oluşturmak için kullanacağı ad alanı.
```bash
#Create namespace
kubectl create namespace my-namespace
```
{% hint style="info" %}
Kubernetes kaynaklarının çoğunun (örneğin pod'lar, servisler, replikasyon denetleyicileri ve diğerleri) belirli bir isim alanında olduğunu unutmayın. Bununla birlikte, isim alanı kaynakları gibi diğer kaynaklar ve düşük seviyeli kaynaklar, örneğin düğümler ve kalıcı birimler bir isim alanında değildir. Hangi Kubernetes kaynaklarının bir isim alanında olduğunu ve olmadığını görmek için:
```bash
kubectl api-resources --namespaced=true #In a namespace
kubectl api-resources --namespaced=false #Not in a namespace
```
{% endhint %}

Tüm sonraki kubectl komutları için ad alanını o bağlamda kaydedebilirsiniz.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm, Kubernetes için paket yöneticisidir. YAML dosyalarını paketlemeye ve bunları genel ve özel depolarda dağıtmaya olanak tanır. Bu paketlere **Helm Charts** denir.
```
helm search <keyword>
```
## Kubernetes sırları

Bir **Secret**, bir şifre, bir belirteç veya bir anahtar gibi **duyarlı verileri içeren** bir nesnedir. Bu tür bilgiler aksi takdirde bir Pod belirtimine veya bir görüntüye konulabilir. Kullanıcılar Secrets oluşturabilir ve sistem de Secrets oluşturabilir. Bir Secret nesnesinin adı geçerli bir **DNS alt alan adı** olmalıdır. [Resmi belgelere](https://kubernetes.io/docs/concepts/configuration/secret/) buradan bakabilirsiniz.

Secrets şunlar olabilir:

- API, SSH Anahtarları.
- OAuth belirteçleri.
- Kimlik bilgileri, Parolalar (düz metin veya b64 + şifreleme).
- Bilgi veya yorumlar.
- Veritabanı bağlantı kodu, dizeler… .

Kubernetes'te farklı türde sırlar bulunmaktadır

| Yerleşik Tür                        | Kullanım                                     |
| ----------------------------------- | ----------------------------------------- |
| **Opaque**                          | **keyfi kullanıcı tanımlı veri (Varsayılan)** |
| kubernetes.io/service-account-token | servis hesabı belirteci                     |
| kubernetes.io/dockercfg             | serileştirilmiş \~/.dockercfg dosyası       |
| kubernetes.io/dockerconfigjson      | serileştirilmiş \~/.docker/config.json dosyası |
| kubernetes.io/basic-auth            | temel kimlik doğrulama için kimlik bilgileri |
| kubernetes.io/ssh-auth              | SSH kimlik doğrulama için kimlik bilgileri   |
| kubernetes.io/tls                   | bir TLS istemcisi veya sunucusu için veri   |
| bootstrap.kubernetes.io/token       | başlangıç belirteci verisi                  |

{% hint style="info" %}
**Opaque türü varsayılan türdür, kullanıcılar tarafından tanımlanan tipik anahtar-değer çiftidir.**
{% endhint %}

**Sırlar nasıl çalışır:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

Aşağıdaki yapılandırma dosyası, `username: YWRtaW4=` ve `password: MWYyZDFlMmU2N2Rm` olmak üzere 2 anahtar-değer çiftine sahip `mysecret` adında bir **secret** tanımlar. Ayrıca, `mysecret` içinde tanımlanan `username` ve `password`'un **environment variables** `SECRET_USERNAME` ve `SECRET_PASSWOR` içinde açığa çıkarılacağı `secretpod` adında bir **pod** tanımlar. Ayrıca, `username` sırrını `/etc/foo/my-group/my-username` yolunda `0640` izinleriyle **mount** edecektir.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```
{% endcode %}
```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### etcd'teki Sırlar <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd**, tüm küme verileri için Kubernetes destek deposu olarak kullanılan tutarlı ve yüksek erişilebilirlikte bir **anahtar-değer deposudur**. etcd'de saklanan sırlara erişelim:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Sertifikalar, anahtarlar ve URL'lerin FS içinde bulunduğunu göreceksiniz. Bunu aldığınızda etcd'ye bağlanabileceksiniz.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Bir kez iletişim kurmayı başardığınızda sırlara erişebileceksiniz:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**ETCD'ye Şifreleme Eklemek**

Varsayılan olarak, tüm sırlar, bir şifreleme katmanı uygulamadıkça etcd içinde düz metin olarak saklanır. Aşağıdaki örnek, [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/) adresindeki bilgilere dayanmaktadır.

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
{% endcode %}

Sonrasında, oluşturulan yapılandırma dosyasının konumunu göstermek için `kube-apiserver` üzerinde `--encryption-provider-config` bayrağını ayarlamanız gerekir. `/etc/kubernetes/manifest/kube-apiserver.yaml` dosyasını değiştirerek aşağıdaki satırları ekleyebilirsiniz:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Aşağı kaydırın volumeMounts bölümünde:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Aşağı kaydırın volumeMounts içinde hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Veri şifrelenmiş olduğunu doğrulama**

Veri etcd'ye yazıldığında şifrelenir. `kube-apiserver`'ınızı yeniden başlattıktan sonra, depolandığında yeni oluşturulan veya güncellenen herhangi bir sırrın şifrelenmiş olması gerekir. Kontrol etmek için `etcdctl` komut satırı programını kullanarak sırrınızın içeriğini alabilirsiniz.

1. `default` ad alanında `secret1` adında yeni bir sır oluşturun:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```
2. Etcdctl komut satırını kullanarak, o sırrı etcd'den okuyun:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

`[...]` etcd sunucusuna bağlanmak için ek argümanlar olmalıdır.
3. Depolanan sırrın, sonuç verilerinin şifrelemesini yapan `aescbc` sağlayıcısının şifrelediğini gösteren `k8s:enc:aescbc:v1:` ile başladığını doğrulayın.
4. API aracılığıyla alındığında sırrın doğru bir şekilde şifrelenmediğini doğrulayın:

```
kubectl describe secret secret1 -n default
```

`mykey: bXlkYXRh` ile eşleşmelidir, mydata kodlanmıştır, sırrı tamamen çözmek için [bir sırrı çözme](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) bağlantısına bakın.

**Sırlar yazılırken şifrelendiğinden, bir sırrı güncellemek şifrelemesini sağlayacaktır:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Son ipuçları:**

* FS içinde sırları saklamamaya çalışın, onları başka yerlerden alın.
* Sırlarınıza daha fazla koruma eklemek için [https://www.vaultproject.io/](https://www.vaultproject.io) adresine göz atın.
* [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
* [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm)

## Referanslar

{% embed url="https://sickrov.github.io/" %}

{% embed url="https://www.youtube.com/watch?v=X48VuDVv0do" %}

{% hint style="success" %}
AWS Hacking'i öğrenin ve uygulayın:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Eğitim AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCP Hacking'i öğrenin ve uygulayın: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Eğitim GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**Abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarını paylaşarak PR'ler göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
{% endhint %}
