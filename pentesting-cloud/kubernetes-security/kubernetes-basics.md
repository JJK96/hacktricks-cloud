# Βασικά του Kubernetes

## Βασικά του Kubernetes

{% hint style="success" %}
Μάθε & εξάσκησε στο Hacking του AWS:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**Εκπαίδευση HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Μάθε & εξάσκησε στο Hacking του GCP: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**Εκπαίδευση HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστήριξε το HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Συμμετέχετε** 💬 στην [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Κοινοποιήστε hacking tricks υποβάλλοντας PRs** στα αποθετήρια [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) στο GitHub.

</details>
{% endhint %}

**Ο αρχικός συγγραφέας αυτής της σελίδας είναι** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(διαβάστε την αρχική του ανάρτηση** [**εδώ**](https://sickrov.github.io)**)**

## Αρχιτεκτονική & Βασικά

### Τι κάνει το Kubernetes;

* Επιτρέπει την εκτέλεση ενός ή περισσότερων containers σε έναν container engine.
* Ο προγραμματισμός επιτρέπει την αποστολή containers αποτελεσματικά.
* Διατηρεί τα containers ενεργά.
* Επιτρέπει την επικοινωνία μεταξύ των containers.
* Επιτρέπει τεχνικές αναπτύξεων.
* Διαχειρίζεται όγκους πληροφοριών.

### Αρχιτεκτονική

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **Κόμβος (Node)**: λειτουργικό σύστημα με pod ή pods.
* **Pod**: Περιτύλιγμα γύρω από ένα container ή πολλαπλά containers. Ένα pod θα πρέπει να περιέχει μόνο μία εφαρμογή (συνήθως, ένα pod εκτελεί μόνο ένα container). Το pod είναι ο τρόπος με τον οποίο το Kubernetes αφαιρεί την τεχνολογία container που εκτελείται.
* **Υπηρεσία (Service)**: Κάθε pod έχει 1 εσωτερική διεύθυνση IP από την εσωτερική σειρά του κόμβου. Ωστόσο, μπορεί επίσης να εκτεθεί μέσω μιας υπηρεσίας. Η υπηρεσία έχει επίσης μια διεύθυνση IP και ο στόχος της είναι να διατηρεί την επικοινωνία μεταξύ των pods, έτσι ώστε αν ένα πεθάνει, η νέα αντικατάσταση (με διαφορετική εσωτερική IP) θα είναι προσβάσιμη εκτεθειμένη στην ίδια IP της υπηρεσίας. Μπορεί να ρυθμιστεί ως εσωτερική ή εξωτερική. Η υπηρεσία επίσης λειτουργεί ως ισορροπητής φορτίου όταν 2 pods είναι συνδεδεμένα στην ίδια υπηρεσία.\
Όταν δημιουργείται μια υπηρεσία, μπορείτε να βρείτε τα σημεία άκρων κάθε υπηρεσίας εκτελώντας `kubectl get endpoints`
* **Kubelet**: Κύριος πράκτορας κόμβου. Το στοιχείο που εγκαθιστά την επικοινωνία μεταξύ του κόμβου και του kubectl, και μπορεί να εκτελέσει μόνο pods (μέσω του API server). Το kubelet δεν διαχειρίζεται containers που δεν δημιουργήθηκαν από το Kubernetes.
* **Kube-proxy**: είναι η υπηρεσία που χειρίζεται τις επικοινωνίες (υπηρεσίες) μεταξύ του apiserver και του κόμβου. Η βάση είναι ένα IPtables για τους κόμβους. Οι πιο έμπειροι χρήστες μπορούν να εγκαταστήσουν άλλους kube-proxies από άλλους προμηθευτές.
* **Δοχείο Sidecar**: Τα δοχεία Sidecar είναι τα δοχεία που πρέπει να εκτελούνται μαζί με το κύριο δοχείο στο pod. Αυτό το πρότυπο sidecar επεκτείνει και ενισχύει τη λειτουργικότητα των τρεχόντων δοχείων χωρίς να τα αλλάζει. Σήμερα, γνωρίζουμε ότι χρησιμοποιούμε την τεχνολογία container για να συσκευάσουμε όλες τις εξαρτήσεις που απαιτούνται για την εκτέλεση της εφαρμογής οπουδήποτε. Ένα δοχείο κάνει μόνο μία δουλειά και την κάνει πολύ καλά.
* **Διαδικασία Master:**
* **Διακομιστής Api:** Είναι ο τρόπος με τον οποίο οι χρήστες και τα pods χρησιμοποιούν για να επικοινωνήσουν με τη διαδικασία Master. Πρέπει να επιτρέπονται μόνο πιστοποιημένα αιτήματα.
* **Χρονοδιαγραμματιστής (Scheduler)**: Η προγραμματισμός αναφέρεται στο να βεβαιωθεί ότι τα Pods αντιστοιχούν σε Κόμβους, ώστε ο Kubelet να μπορεί να τα εκτελέσει. Έχει αρκετή ευφυΐα για να αποφασίσει ποιος κόμβος έχει περισσότερους διαθέσιμους πόρους και να αναθέσει το νέο pod σε αυτόν. Σημειώστε ότι ο χρονοδιαγραμματιστής δεν ξεκινά νέα pods, απλώς επικοινωνεί με τη διαδικασία Kubelet που εκτελείται μέσα στον κόμβο, η οποία θα ξεκινήσει το νέο pod.
* **Διαχειριστής ελέγχου Kube (Kube Controller manager)**: Ελέγχει πόρους όπως σύνολα αντιγράφων ή αναπτύξεις για να ελέγξει αν, για παράδειγμα, το σωστό αριθμό των pods ή κόμβων εκτελούνται. Σε περίπτωση που λείπει ένα pod, θα επικοινωνήσει με τον χρονοδιαγραμματιστή για να ξεκινήσει ένα νέο. Ελέγχει την αντιγραφή, τα διακριτικά και τις υπηρεσίες λογαριασμού στο API.
* **etcd**: Αποθήκευση δεδομένων, μόνιμη, συνεπής και κατανεμημένη. Είναι η βάση δεδομένων του Kubernetes και η αποθήκευση κλειδιών-τιμών όπου διατηρεί την πλήρη κατάσταση των συστάδων (κάθε αλλαγή καταγράφεται εδώ). Στοιχεία όπως ο Χρονοδιαγραμματιστής ή ο Διαχειριστής ελέγχου εξαρτώνται από αυτήν την ημερομηνία για να γνωρίζουν ποιες αλλαγές έχουν συμβεί (διαθέσιμοι πόροι των κόμβων, αριθμός των εκτελούμενων pods...)
* **Διαχειριστής ελέγχου Cloud**: Είναι ο συγκεκριμένος ελεγκτής για τον έλεγχο ροών και εφαρμογών, δηλαδή: αν έχετε συστάδες στο AWS ή στο OpenStack.

Σημειώστε ότι καθώς μπορεί να υπάρχουν αρκετοί κόμβοι (που εκτελούν αρκετά pods), μπορεί επίσης να υπάρχουν αρκετές διαδικασίες Master, με την πρόσβασή τους στον διακομιστή Api να ισορροπείται φορτίο και η etcd τους να συγχρονίζεται.

**Όγκοι:**

Όταν ένα pod δημιουργεί δεδομένα που δεν πρέπει να χαθούν όταν το pod εξαφανιστεί, πρέπει να αποθηκεύονται σε ένα φυσικό όγκο. **Το Kubernetes επιτρέπει τη σύνδεση ενός όγκου σε ένα pod για να διατηρηθούν τα δεδομένα**.
### Δομή PKI - Αρχή Πιστοποίησης Πιστοποιητικών CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* Το CA είναι η αξιόπιστη ρίζα για όλα τα πιστοποιητικά μέσα στο cluster.
* Επιτρέπει στα στοιχεία να επικυρώνουν μεταξύ τους.
* Όλα τα πιστοποιητικά του cluster είναι υπογεγραμμένα από το CA.
* Το ETCD έχει το δικό του πιστοποιητικό.
* Τύποι:
  * πιστοποιητικό apiserver.
  * πιστοποιητικό kubelet.
  * πιστοποιητικό scheduler.

## Βασικές Ενέργειες

### Minikube

**Minikube** μπορεί να χρησιμοποιηθεί για να εκτελέσει **γρήγορες δοκιμές** στο Kubernetes χωρίς την ανάγκη να αναπτύξετε ολόκληρο περιβάλλον Kubernetes. Θα εκτελέσει τις διεργασίες **master και node σε ένα μηχάνημα**. Το Minikube θα χρησιμοποιήσει το virtualbox για να εκτελέσει τον κόμβο. Δείτε [**εδώ πώς να το εγκαταστήσετε**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
😄  minikube v1.19.0 on Ubuntu 20.04
✨  Automatically selected the virtualbox driver. Other choices: none, ssh
💿  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
👍  Starting control plane node minikube in cluster minikube
💾  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
🔥  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
🐳  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
▪ Generating certificates and keys ...
▪ Booting up control plane ...
▪ Configuring RBAC rules ...
🔎  Verifying Kubernetes components...
▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
🌟  Enabled addons: storage-provisioner, default-storageclass
🏄  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
🔥  Deleting "minikube" in virtualbox ...
💀  Removed all traces of the "minikube" cluster
```
### Βασικά του Kubectl

**`Kubectl`** είναι το εργαλείο γραμμής εντολών για τα clusters του kubernetes. Επικοινωνεί με τον διακομιστή Api της κύριας διαδικασίας για να εκτελέσει ενέργειες στο kubernetes ή να ζητήσει δεδομένα.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Πίνακας ελέγχου του Minikube

Ο πίνακας ελέγχου σάς επιτρέπει να βλέπετε πιο εύκολα τι εκτελείται στο Minikube, μπορείτε να βρείτε το URL πρόσβασης σε αυτόν στο:
```
minikube dashboard --url


🔌  Enabling dashboard ...
▪ Using image kubernetesui/dashboard:v2.3.1
▪ Using image kubernetesui/metrics-scraper:v1.0.7
🤔  Verifying dashboard health ...
🚀  Launching proxy ...
🤔  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### Παραδείγματα αρχείων ρυθμίσεων YAML

Κάθε αρχείο ρυθμίσεων έχει 3 μέρη: **μεταδεδομένα**, **προδιαγραφή** (τι χρειάζεται να εκκινηθεί), **κατάσταση** (επιθυμητή κατάσταση).\
Μέσα στην προδιαγραφή του αρχείου ρυθμίσεων αναπτύξεων μπορείτε να βρείτε το πρότυπο που έχει οριστεί με μια νέα δομή ρυθμίσεων που ορίζει την εικόνα που θα εκτελεστεί:

**Παράδειγμα αναπτυγμένου + υπηρεσίας που δηλώνεται στο ίδιο αρχείο ρυθμίσεων (από** [**εδώ**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Καθώς μια υπηρεσία συνήθως σχετίζεται με μια ανάπτυξη, είναι δυνατόν να δηλωθούν και τα δύο στο ίδιο αρχείο ρυθμίσεων (η υπηρεσία που δηλώνεται σε αυτήν τη διαμόρφωση είναι προσβάσιμη μόνο εσωτερικά):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Παράδειγμα εξωτερικής διαμόρφωσης υπηρεσίας**

Αυτή η υπηρεσία θα είναι προσβάσιμη εξωτερικά (ελέγξτε τα χαρακτηριστικά `nodePort` και `type: LoadBalancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
{% hint style="info" %}
Αυτό είναι χρήσιμο για δοκιμές, αλλά για παραγωγή θα πρέπει να έχετε μόνο εσωτερικές υπηρεσίες και ένα Ingress για την εκθεση της εφαρμογής.
{% endhint %}

**Παράδειγμα αρχείου ρύθμισης Ingress**

Αυτό θα εκθέσει την εφαρμογή στο `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Παράδειγμα αρχείου ρύθμισης μυστικών**

Σημειώστε πως οι κωδικοί πρόσβασης κωδικοποιούνται σε B64 (το οποίο δεν είναι ασφαλές!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Παράδειγμα του ConfigMap**

Ένα **ConfigMap** είναι η διαμόρφωση που δίνεται στα pods ώστε να ξέρουν πώς να εντοπίσουν και να έχουν πρόσβαση σε άλλες υπηρεσίες. Σε αυτήν την περίπτωση, κάθε pod θα γνωρίζει ότι το όνομα `mongodb-service` είναι η διεύθυνση ενός pod με το οποίο μπορεί να επικοινωνήσει (αυτό το pod θα εκτελεί ένα mongodb):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Στη συνέχεια, μέσα σε ένα **deployment config** αυτή η διεύθυνση μπορεί να καθοριστεί με τον ακόλουθο τρόπο ώστε να φορτωθεί μέσα στο περιβάλλον του pod:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Παράδειγμα ρύθμισης όγκου**

Μπορείτε να βρείτε διαφορετικά παραδείγματα αρχείων ρύθμισης αποθήκευσης σε αρχεία yaml στο [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Σημειώστε ότι οι όγκοι δεν βρίσκονται μέσα σε namespaces**

### Namespaces

Το Kubernetes υποστηρίζει **πολλαπλά εικονικά clusters** υποστηριζόμενα από το ίδιο φυσικό cluster. Αυτά τα εικονικά clusters ονομάζονται **namespaces**. Αυτά προορίζονται για χρήση σε περιβάλλοντα με πολλούς χρήστες που είναι διασπαρμένοι σε πολλές ομάδες ή έργα. Για clusters με λίγους έως δεκάδες χρήστες, δεν θα πρέπει να χρειάζεται να δημιουργήσετε ή να σκεφτείτε για namespaces καθόλου. Θα πρέπει να αρχίσετε να χρησιμοποιείτε namespaces μόνο για να έχετε καλύτερο έλεγχο και οργάνωση κάθε τμήματος της εφαρμογής που έχει αναπτυχθεί στο Kubernetes.

Τα namespaces παρέχουν ένα πεδίο ονομάτων. Τα ονόματα των πόρων πρέπει να είναι μοναδικά μέσα σε ένα namespace, αλλά όχι ανάμεσα σε διαφορετικά namespaces. Τα namespaces δεν μπορούν να είναι ενσωματωμένα το ένα μέσα στο άλλο και **κάθε** πόρος του Kubernetes μπορεί να βρίσκεται μόνο **σε ένα** **namespace**.

Υπάρχουν 4 namespaces από προεπιλογή εάν χρησιμοποιείτε το minikube:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
* **kube-system**: Δεν προορίζεται για χρήση από τους χρήστες και δεν πρέπει να το αγγίξετε. Χρησιμοποιείται για τις διαδικασίες master και kubectl.
* **kube-public**: Δημόσια προσβάσιμα δεδομένα. Περιέχει ένα configmap που περιέχει πληροφορίες συστήματος.
* **kube-node-lease**: Καθορίζει τη διαθεσιμότητα ενός κόμβου.
* **default**: Το namespace που θα χρησιμοποιήσει ο χρήστης για τη δημιουργία πόρων.
```bash
#Create namespace
kubectl create namespace my-namespace
```
{% hint style="info" %}
Σημειώστε ότι το περισσότερο των πόρων του Kubernetes (π.χ. pods, services, replication controllers και άλλοι) βρίσκονται σε κάποιο namespace. Ωστόσο, άλλοι πόροι όπως οι πόροι του namespace και οι χαμηλού επιπέδου πόροι, όπως οι κόμβοι (nodes) και τα μόνιμα volumes (persistenVolumes) δεν βρίσκονται σε κάποιο namespace. Για να δείτε ποιοι πόροι του Kubernetes βρίσκονται σε namespace και ποιοι όχι:
```bash
kubectl api-resources --namespaced=true #In a namespace
kubectl api-resources --namespaced=false #Not in a namespace
```
{% endhint %}

Μπορείτε να αποθηκεύσετε το namespace για όλες τις επόμενες εντολές kubectl σε αυτό το πλαίσιο.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Το Helm είναι ο **διαχειριστής πακέτων** για το Kubernetes. Επιτρέπει τη συσκευασία αρχείων YAML και τη διανομή τους σε δημόσιες και ιδιωτικές αποθήκες. Αυτά τα πακέτα ονομάζονται **Helm Charts**.
```
helm search <keyword>
```
## Μυστικά Kubernetes

Ένα **Μυστικό** είναι ένα αντικείμενο που **περιέχει ευαίσθητα δεδομένα** όπως ένας κωδικός πρόσβασης, ένα τοκέν ή ένα κλειδί. Τέτοιες πληροφορίες θα μπορούσαν αλλιώς να τοποθετηθούν σε μια προδιαγραφή Pod ή σε ένα εικονίδιο. Οι χρήστες μπορούν να δημιουργήσουν Μυστικά και το σύστημα επίσης δημιουργεί Μυστικά. Το όνομα ενός αντικειμένου Μυστικού πρέπει να είναι ένα έγκυρο **όνομα υποτομέα DNS**. Διαβάστε εδώ [την επίσημη τεκμηρίωση](https://kubernetes.io/docs/concepts/configuration/secret/).

Τα Μυστικά μπορεί να είναι πράγματα όπως:

* Κλειδιά API, SSH.
* Διαπιστευτήρια OAuth.
* Διαπιστευτήρια, Κωδικοί πρόσβασης (κείμενο ή b64 + κρυπτογράφηση).
* Πληροφορίες ή σχόλια.
* Κώδικας σύνδεσης βάσης δεδομένων, αλυσίδες... .

Υπάρχουν διαφορετικοί τύποι μυστικών στο Kubernetes

| Ενσωματωμένος Τύπος                  | Χρήση                                     |
| ----------------------------------- | ----------------------------------------- |
| **Opaque**                          | **αυθαίρετα ορισμένα δεδομένα από τον χρήστη (Προεπιλογή)** |
| kubernetes.io/service-account-token | διακριτικό λογαριασμού υπηρεσίας                     |
| kubernetes.io/dockercfg             | σειριοποιημένο αρχείο \~/.dockercfg             |
| kubernetes.io/dockerconfigjson      | σειριοποιημένο αρχείο \~/.docker/config.json    |
| kubernetes.io/basic-auth            | διαπιστευτήρια για βασική πιστοποίηση      |
| kubernetes.io/ssh-auth              | διαπιστευτήρια για πιστοποίηση SSH        |
| kubernetes.io/tls                   | δεδομένα για έναν πελάτη ή διακομιστή TLS           |
| bootstrap.kubernetes.io/token       | δεδομένα τεκμηρίου εκκίνησης                      |

{% hint style="info" %}
**Ο τύπος Opaque είναι ο προεπιλεγμένος, το τυπικό ζεύγος κλειδιού-τιμής που ορίζεται από τους χρήστες.**
{% endhint %}

**Πώς λειτουργούν τα μυστικά:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

Το παρακάτω αρχείο διαμόρφωσης ορίζει ένα **μυστικό** με το όνομα `mysecret` με 2 ζεύγη κλειδιού-τιμής `username: YWRtaW4=` και `password: MWYyZDFlMmU2N2Rm`. Ορίζει επίσης ένα **pod** με το όνομα `secretpod` που θα έχει το `username` και το `password` που ορίζονται στο `mysecret` εκτεθειμένα στις **μεταβλητές περιβάλλοντος** `SECRET_USERNAME` και `SECRET_PASSWOR`. Επίσης θα **προσαρτήσει** το μυστικό `username` μέσα στο `mysecret` στη διαδρομή `/etc/foo/my-group/my-username` με δικαιώματα `0640`.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```
{% endcode %}
```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Μυστικά στο etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** είναι ένα συνεπές και υψηλά διαθέσιμο **key-value store** που χρησιμοποιείται ως αποθήκη υποστήριξης του Kubernetes για όλα τα δεδομένα του cluster. Ας έχουμε πρόσβαση στα μυστικά που αποθηκεύονται στο etcd:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Θα δείτε πιστοποιητικά, κλειδιά και διευθύνσεις URL που βρίσκονται στο σύστημα αρχείων. Μόλις τα αποκτήσετε, θα μπορείτε να συνδεθείτε στο etcd.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Μόλις επιτύχετε να καθιερώσετε την επικοινωνία, θα μπορείτε να λάβετε τα μυστικά:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Προσθήκη κρυπτογράφησης στο ETCD**

Από προεπιλογή, όλα τα μυστικά **αποθηκεύονται σε καθαρή** μορφή μέσα στο etcd εκτός αν εφαρμόσετε ένα επίπεδο κρυπτογράφησης. Το παρακάτω παράδειγμα βασίζεται στο [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
{% endcode %}

Μετά από αυτό, πρέπει να ορίσετε τη σημαία `--encryption-provider-config` στον `kube-apiserver` ώστε να δείχνει στην τοποθεσία του δημιουργημένου αρχείου ρυθμίσεων. Μπορείτε να τροποποιήσετε το `/etc/kubernetes/manifest/kube-apiserver.yaml` και να προσθέσετε τις παρακάτω γραμμές:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Κύλισε προς τα κάτω στο volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Κύλισε προς τα κάτω στα volumeMounts στο hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Επαλήθευση ότι τα δεδομένα είναι κρυπτογραφημένα**

Τα δεδομένα είναι κρυπτογραφημένα όταν γράφονται στο etcd. Μετά την επανεκκίνηση του `kube-apiserver` σας, οποιοδήποτε νεόδημο ή ενημερωμένο μυστικό θα πρέπει να είναι κρυπτογραφημένο όταν αποθηκεύεται. Για να ελέγξετε αυτό, μπορείτε να χρησιμοποιήσετε το πρόγραμμα γραμμής εντολών `etcdctl` για να ανακτήσετε τα περιεχόμενα του μυστικού σας.

1. Δημιουργήστε ένα νέο μυστικό με το όνομα `secret1` στο namespace `default`:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```
2. Χρησιμοποιώντας τη γραμμή εντολών etcdctl, διαβάστε αυτό το μυστικό από το etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

όπου `[...]` πρέπει να είναι τα επιπλέον ορίσματα για τη σύνδεση με τον εξυπηρετητή etcd.
3. Επαληθεύστε ότι το αποθηκευμένο μυστικό έχει προθέμα `k8s:enc:aescbc:v1:` το οποίο υποδηλώνει ότι ο πάροχος `aescbc` έχει κρυπτογραφήσει τα αποτελέσματα δεδομένων.
4. Επαληθεύστε ότι το μυστικό αποκρυπτογραφείται σωστά όταν ανακτάται μέσω του API:

```
kubectl describe secret secret1 -n default
```

πρέπει να ταιριάζει με `mykey: bXlkYXRh`, το mydata είναι κωδικοποιημένο, ελέγξτε το [αποκωδικοποίηση ενός μυστικού](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) για να αποκωδικοποιήσετε πλήρως το μυστικό.

**Δεδομένου ότι τα μυστικά είναι κρυπτογραφημένα κατά την εγγραφή, η εκτέλεση μιας ενημέρωσης σε ένα μυστικό θα κρυπτογραφήσει αυτό το περιεχόμενο:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Τελικές συμβουλές:**

* Προσπαθήστε να μην κρατάτε μυστικά στο FS, αντλήστε τα από άλλα μέρη.
* Ελέγξτε το [https://www.vaultproject.io/](https://www.vaultproject.io) για να προσθέσετε περισσότερη προστασία στα μυστικά σας.
* [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
* [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm)

## Αναφορές

{% embed url="https://sickrov.github.io/" %}

{% embed url="https://www.youtube.com/watch?v=X48VuDVv0do" %}

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**Εκπαίδευση HackTricks AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**Εκπαίδευση HackTricks GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστηρίξτε το HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε** 💬 [**στην ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε κόλπα χάκερ υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο GitHub.

</details>
{% endhint %}
