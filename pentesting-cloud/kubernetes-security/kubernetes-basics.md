# Kubernetes Basics

## Kubernetes Basics

{% hint style="success" %}
AWSハッキングの学習と実践:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCPハッキングの学習と実践: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksのサポート</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出して、ハッキングトリックを共有してください。

</details>
{% endhint %}

**このページの元の著者は** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **です（元の投稿は** [**こちら**](https://sickrov.github.io)**）**

## アーキテクチャと基本

### Kubernetesの役割

* コンテナをコンテナエンジンで実行できるようにします。
* スケジュールによりコンテナを効率的にミッションできます。
* コンテナを生かし続けます。
* コンテナ間の通信を可能にします。
* デプロイメント技術を可能にします。
* 大量の情報を処理します。

### アーキテクチャ

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **ノード**: ポッドまたはポッドを持つオペレーティングシステム。
* **ポッド**: 1つのアプリケーションのみを含むべきであるラッパーであるコンテナまたは複数のコンテナ。通常、1つのポッドは1つのコンテナを実行します。ポッドは、Kubernetesが実行しているコンテナ技術を抽象化する方法です。
* **サービス**: 各ポッドは、ノードの内部範囲から1つの内部**IPアドレス**を持ちます。ただし、サービスを介して公開することもできます。サービスにはIPアドレスもあり、その目的はポッド間の通信を維持することです。したがって、1つがダウンした場合、**新しい置換品**（異なる内部IPを持つ）は、**サービスの同じIPでアクセス可能**に公開されます。内部または外部として構成できます。サービスは、2つのポッドが同じサービスに接続されている場合、**ロードバランサーとして機能**します。\
**サービス**が**作成**されると、各サービスのエンドポイントを見つけることができます。`kubectl get endpoints`を実行して実行中の各サービスのエンドポイントを見つけることができます。
* **Kubelet**: プライマリノードエージェント。ノードとkubectlの間の通信を確立するコンポーネントであり、ポッドのみを実行できます（APIサーバーを介して）。kubeletは、Kubernetesによって作成されていないコンテナを管理しません。
* **Kube-proxy**: apiserverとノード間の通信（サービス）を担当するサービスです。ベースはノード用のIPtablesです。経験豊富なユーザーは、他のベンダーからの他のkube-proxyをインストールすることができます。
* **サイドカーコンテナ**: サイドカーコンテナは、ポッド内のメインコンテナと一緒に実行する必要があるコンテナです。このサイドカーパターンは、現在のコンテナの機能を拡張および強化しますが、それらを変更しません。現在、アプリケーションがどこでも実行されるようにするために、コンテナ技術を使用してすべての依存関係をラップすることを知っています。コンテナは1つのことだけを行い、そのことを非常によく行います。
* **マスタープロセス:**
* **APIサーバー:** ユーザーとポッドがマスタープロセスと通信する方法です。認証されたリクエストのみが許可されるべきです。
* **スケジューラ**: スケジューリングは、Kubeletがそれらを実行できるように、Podがノードに一致するようにすることを指します。どのノードにより多くの利用可能リソースがあるかを判断し、新しいポッドをそのノードに割り当てるための十分な知能を持っています。スケジューラは新しいポッドを開始するのではなく、新しいポッドを起動するノード内で実行されているKubeletプロセスと通信します。
* **Kube Controller Manager**: レプリカセットやデプロイメントなどのリソースをチェックして、例えば、正しい数のポッドやノードが実行されているかどうかを確認します。ポッドが不足している場合、新しいポッドを起動するためにスケジューラと通信します。APIへのレプリケーション、トークン、およびアカウントサービスを制御します。
* **etcd**: データストレージ、永続的で一貫性があり、分散されています。Kubernetesのデータベースであり、クラスターの完全な状態を保持するキー値ストレージです（各変更はここに記録されます）。スケジューラやコントローラーマネージャーなどのコンポーネントは、変更が発生したことを知るためにこのデータに依存します（ノードの利用可能なリソース、実行中のポッドの数など）。 
* **Cloud Controller Manager**: AWSやOpenStackなどのクラスターがある場合、フロー制御とアプリケーションのための特定のコントローラーです。

複数のノード（複数のポッドを実行しているノード）があるため、複数のマスタープロセスがあり、それらのApiサーバーへのアクセスが負荷分散され、それらのetcdが同期されていることに注意してください。

**ボリューム:**

ポッドが消えても失われてはならないデータを作成する場合、物理ボリュームにデータを保存する必要があります。**Kubernetesはポッドにボリュームをアタッチしてデータを永続化することを可能にします**。ボリュームはローカルマシンまたは**リモートストレージ**にあることができます。異なる物理ノードでポッドを実行している場合は、すべてのポッドがアクセスできるようにリモートストレージを使用する必要があります。

**その他の構成:**

* **ConfigMap**: サービスにアクセスするための**URL**を構成できます。ポッドはここからデータを取得して、他のサービス（ポッド）との通信方法を知ることができます。これは資格情報を保存するための推奨されない場所であることに注意してください！
* **Secret**: これは、パスワード、APIキーなどの秘密データを保存する場所です。B64でエンコードされています。ポッドは必要な資格情報を使用するためにこのデータにアクセスできます。
* **Deployments**: Kubernetesによって実行されるコンポーネントが指定される場所です。通常、ユーザーは直接ポッドと作業しません。ポッドは**ReplicaSets**（複製された同じポッドの数）で抽象化され、デプロイメントを介して実行されます。デプロイメントは**ステートレス**アプリケーション向けです。デプロイメントの最小構成は、名前と実行するイメージです。
* **StatefulSet**: このコンポーネントは、**同じストレージにアクセスする必要がある**データベースなどのアプリケーション向けに特に作成されています。
* **Ingress**: これは、**URLでアプリケーションを公開する**構成です。外部サービスを使用しても同様のことができますが、これがアプリケーションを公開する正しい方法です。
* Ingressを実装する場合は、**Ingress Controllers**を作成する必要があります。Ingress Controllerは、リクエストを受信し、チェックしてサービスにロードバランスする**ポッド**です。Ingress Controllerは、構成されたIngressルールに基づいてリクエストを**送信**します。Ingressルールは、異なるパスやさらには異なる内部Kubernetesサービスへのサブドメインを指すことができます。
* より良いセキュリティ慣行は、Kubernetesクラスターの一部を公開しないように、クラウドロードバランサーやプロキシサーバーをエントリーポイントとして使用することです。
* Ingressルールに一致しないリクエストが受信された場合、Ingress Controllerは「**デフォルトバックエンド**」にそれをリダイレクトします。このパラメータのアドレスを取得するには、Ingress Controllerを`describe`できます。
* `minikube addons enable ingress`
### PKIインフラストラクチャ - 証明書機関CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* CAはクラスタ内のすべての証明書の信頼されるルートです。
* コンポーネントがお互いを検証できるようにします。
* すべてのクラスタ証明書はCAによって署名されています。
* ETCdには独自の証明書があります。
* タイプ:
  * apiserver証明書。
  * kubelet証明書。
  * scheduler証明書。

## 基本的なアクション

### Minikube

**Minikube**は、完全なkubernetes環境を展開する必要なしに、kubernetesでいくつかの**クイックテスト**を実行するために使用できます。**マスターとノードプロセスを1つのマシンで実行**します。Minikubeは、ノードを実行するためにvirtualboxを使用します。[**こちらでインストール方法を確認してください**](https://minikube.sigs.k8s.io/docs/start/)。
```
$ minikube start
😄  minikube v1.19.0 on Ubuntu 20.04
✨  Automatically selected the virtualbox driver. Other choices: none, ssh
💿  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
👍  Starting control plane node minikube in cluster minikube
💾  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
🔥  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
🐳  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
▪ Generating certificates and keys ...
▪ Booting up control plane ...
▪ Configuring RBAC rules ...
🔎  Verifying Kubernetes components...
▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
🌟  Enabled addons: storage-provisioner, default-storageclass
🏄  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
🔥  Deleting "minikube" in virtualbox ...
💀  Removed all traces of the "minikube" cluster
```
### Kubectlの基本

**`Kubectl`**は、kubernetesクラスター用のコマンドラインツールです。これは、kubernetesのアクションを実行したりデータを要求するために、マスタープロセスのApiサーバーと通信します。
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube ダッシュボード

このダッシュボードを使用すると、Minikube が実行している内容をより簡単に確認できます。アクセスするための URL は以下で見つけることができます：
```
minikube dashboard --url


🔌  Enabling dashboard ...
▪ Using image kubernetesui/dashboard:v2.3.1
▪ Using image kubernetesui/metrics-scraper:v1.0.7
🤔  Verifying dashboard health ...
🚀  Launching proxy ...
🤔  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### YAML構成ファイルの例

各構成ファイルには3つの部分があります: **metadata**、**specification** (起動する必要があるもの)、**status** (望ましい状態)。\
デプロイメント構成ファイルの仕様の中で、実行するイメージを定義する新しい構成構造で定義されたテンプレートが見つかります:

**同じ構成ファイルで宣言されたDeployment + Serviceの例 (from** [**here**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

サービスは通常、1つのデプロイメントに関連しているため、同じ構成ファイルで両方を宣言することが可能です (この構成で宣言されたサービスは内部からのみアクセス可能です):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**外部サービス構成の例**

このサービスは外部からアクセス可能になります（`nodePort`と`type: LoadBalancer`属性を確認してください）:
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
{% hint style="info" %}
これはテストには便利ですが、本番用には内部サービスのみと、アプリケーションを公開するためのIngressが必要です。
{% endhint %}

**Ingress構成ファイルの例**

これにより、アプリケーションが `http://dashboard.com` で公開されます。
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**シークレット構成ファイルの例**

パスワードがB64でエンコードされている点に注意してください（これは安全ではありません！）
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**ConfigMap の例**

**ConfigMap** は、ポッドに与えられる構成であり、他のサービスの場所を特定しアクセスする方法を知っています。この場合、各ポッドは、`mongodb-service` という名前が、通信できるポッドのアドレスであることを知っています（このポッドは mongodb を実行しています）:
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
その後、**デプロイメント構成**内で、このアドレスを以下のように指定することで、ポッドの環境変数内に読み込まれるようになります:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**ボリューム構成の例**

[https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes) に、異なるストレージ構成のYAMLファイルの例があります。\
**ボリュームはネームスペース内に存在しないことに注意してください**

### ネームスペース

Kubernetesは、同じ物理クラスターでバックアップされた**複数の仮想クラスター**をサポートしています。これらの仮想クラスターは**ネームスペース**と呼ばれます。これらは、多くのユーザーが複数のチームやプロジェクトにまたがって分散している環境で使用することを意図しています。数人から数十人のユーザーがいるクラスターでは、ネームスペースを作成したり考えたりする必要はありません。Kubernetesにデプロイされたアプリケーションの各部分をよりよく制御し、整理するためにネームスペースを使用するべきです。

ネームスペースは名前のスコープを提供します。リソースの名前はネームスペース内で一意である必要がありますが、ネームスペース間では一意である必要はありません。ネームスペースは互いに入れ子にすることはできず、**各**Kubernetes**リソース**は**1つのネームスペース**にのみ存在できます。

minikubeを使用している場合、デフォルトで4つのネームスペースがあります。
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
* **kube-system**: ユーザーが使用するためではなく、触れてはいけないものです。マスターとkubectlプロセス用です。
* **kube-public**: 公開されているデータ。クラスタ情報を含むconfigmapが含まれています。
* **kube-node-lease**: ノードの可用性を決定します。
* **default**: ユーザーがリソースを作成するために使用する名前空間
```bash
#Create namespace
kubectl create namespace my-namespace
```
{% hint style="info" %}
ほとんどのKubernetesリソース（例：ポッド、サービス、レプリケーションコントローラなど）はいくつかの名前空間にあります。ただし、名前空間リソースやノード、永続ボリュームなどの低レベルリソースなど、他のリソースは名前空間にありません。どのKubernetesリソースが名前空間にあるかどうかを確認するには、次の手順を実行します：
```bash
kubectl api-resources --namespaced=true #In a namespace
kubectl api-resources --namespaced=false #Not in a namespace
```
{% endhint %}

そのコンテキストでのすべての後続のkubectlコマンドのために、名前空間を保存できます。
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

HelmはKubernetesの**パッケージマネージャ**です。これにより、YAMLファイルをパッケージ化して、それらを公開およびプライベートリポジトリで配布することができます。これらのパッケージは**Helm Charts**と呼ばれます。
```
helm search <keyword>
```
## Kubernetesのシークレット

**シークレット**は、パスワード、トークン、またはキーなどの**機密データ**を含むオブジェクトです。このような情報は通常、Podの仕様やイメージに配置される可能性があります。ユーザーはシークレットを作成でき、システムもシークレットを作成します。シークレットオブジェクトの名前は有効な**DNSサブドメイン名**である必要があります。[公式ドキュメント](https://kubernetes.io/docs/concepts/configuration/secret/)を参照してください。

シークレットには次のようなものがあります：

- API、SSHキー。
- OAuthトークン。
- 資格情報、パスワード（平文またはb64 + 暗号化）。
- 情報やコメント。
- データベース接続コード、文字列...。

Kubernetesには異なるタイプのシークレットがあります

| 組み込みタイプ                        | 使用法                                     |
| ----------------------------------- | ----------------------------------------- |
| **Opaque**                          | **任意のユーザー定義データ（デフォルト）** |
| kubernetes.io/service-account-token | サービスアカウントトークン                     |
| kubernetes.io/dockercfg             | シリアル化された\~/.dockercfgファイル             |
| kubernetes.io/dockerconfigjson      | シリアル化された\~/.docker/config.jsonファイル    |
| kubernetes.io/basic-auth            | 基本認証の資格情報      |
| kubernetes.io/ssh-auth              | SSH認証の資格情報        |
| kubernetes.io/tls                   | TLSクライアントまたはサーバーのデータ           |
| bootstrap.kubernetes.io/token       | ブートストラップトークンデータ                      |

{% hint style="info" %}
**Opaqueタイプはデフォルトで、ユーザーによって定義された典型的なキーと値のペアです。**
{% endhint %}

**シークレットの動作方法：**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

次の構成ファイルは、`username: YWRtaW4=`および`password: MWYyZDFlMmU2N2Rm`の2つのキーと値のペアを持つ`mysecret`という**シークレット**を定義しています。また、`mysecret`で定義された`username`と`password`を**環境変数**`SECRET_USERNAME`および`SECRET_PASSWOR`に公開する`secretpod`という**ポッド**を定義しています。また、`username`シークレットを`/etc/foo/my-group/my-username`パスに`0640`の権限で**マウント**します。

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```
{% endcode %}
```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### etcd内のシークレット <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd**は、Kubernetesのバックエンドストアとして使用される一貫性があり高可用性の**キーバリューストア**です。etcdに保存されているシークレットにアクセスしましょう：
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
以下は、FS に配置されている証明書、キー、および URL が表示されます。これらを取得すると、etcd に接続できるようになります。
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
一度コミュニケーションを確立すると、シークレットを取得できるようになります。
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**ETCDへの暗号化の追加**

デフォルトでは、すべてのシークレットはetcd内部に平文で保存されますが、暗号化レイヤーを適用しない限りです。次の例は、[https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)に基づいています。

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
{% endcode %}

その後、作成した構成ファイルの場所を指すように`kube-apiserver`の`--encryption-provider-config`フラグを設定する必要があります。`/etc/kubernetes/manifest/kube-apiserver.yaml`を変更し、次の行を追加します:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
volumeMounts でスクロールダウンしてください。
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
ボリュームマウントをhostPathにスクロールダウンします：
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**データが暗号化されていることを検証する**

データはetcdに書き込まれる際に暗号化されます。`kube-apiserver`を再起動した後、新しく作成されたまたは更新されたシークレットは保存される際に暗号化されるはずです。確認するために、`etcdctl`コマンドラインプログラムを使用してシークレットの内容を取得できます。

1. `default`ネームスペースに`secret1`という新しいシークレットを作成します：

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```
2. etcdctlコマンドラインを使用して、etcdからそのシークレットを読み取ります：

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

ここで`[...]`はetcdサーバーに接続するための追加の引数である必要があります。
3. 保存されたシークレットが`k8s:enc:aescbc:v1:`で始まっていることを確認します。これは`aescbc`プロバイダーが結果データを暗号化したことを示します。
4. APIを介して取得された際にシークレットが正しく復号化されていることを確認します：

```
kubectl describe secret secret1 -n default
```

は`mykey: bXlkYXRh`に一致するはずです。`mydata`はエンコードされています。シークレットを完全にデコードするには、[シークレットのデコード](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret)を確認してください。

**シークレットは書き込み時に暗号化されるため、シークレットの更新を行うとその内容が暗号化されます:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**最終的なヒント:**

- FSに秘密を保管しないようにして、他の場所から取得します。
- 秘密にさらなる保護を追加するために[https://www.vaultproject.io/](https://www.vaultproject.io)をチェックしてください。
- [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
- [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm)

## 参考文献

{% embed url="https://sickrov.github.io/" %}

{% embed url="https://www.youtube.com/watch?v=X48VuDVv0do" %}

{% hint style="success" %}
AWSハッキングの学習と実践:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCPハッキングの学習と実践: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksのサポート</summary>

- [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェック！
- 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
- **ハッキングトリックを共有するために、**[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。

</details>
{% endhint %}
