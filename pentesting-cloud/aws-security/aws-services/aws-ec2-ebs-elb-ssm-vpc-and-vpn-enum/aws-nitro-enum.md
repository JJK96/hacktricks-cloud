# AWS - Nitro Enum

{% hint style="success" %}
Naucz się i ćwicz AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Naucz się i ćwicz GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wspieraj HackTricks</summary>

* Sprawdź [**plany subskrypcji**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel się trikami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na githubie.

</details>
{% endhint %}

## Podstawowe informacje

AWS Nitro to zestaw **innowacyjnych technologii**, które stanowią podstawową platformę dla instancji AWS EC2. Wprowadzony przez Amazon w celu **zwiększenia bezpieczeństwa, wydajności i niezawodności**, Nitro wykorzystuje niestandardowe **komponenty sprzętowe i lekki hipernadzorcę**. Abstrahuje wiele tradycyjnych funkcji wirtualizacji do dedykowanego sprzętu i oprogramowania, **minimalizując powierzchnię ataku** i poprawiając efektywność zasobów. Dzięki przeniesieniu funkcji wirtualizacji, Nitro pozwala instancjom EC2 na dostarczanie **wydajności zbliżonej do wydajności sprzętu fizycznego**, co jest szczególnie korzystne dla aplikacji wymagających dużych zasobów. Dodatkowo, Nitro Security Chip zapewnia **bezpieczeństwo sprzętu i oprogramowania układowego**, co dodatkowo wzmacnia jego solidną architekturę.

### Nitro Enclaves

**AWS Nitro Enclaves** zapewnia bezpieczne, **izolowane środowisko obliczeniowe w ramach instancji Amazon EC2**, specjalnie zaprojektowane do przetwarzania wysoce wrażliwych danych. Wykorzystując system AWS Nitro, te enklawy zapewniają solidną **izolację i bezpieczeństwo**, idealne do **obsługi poufnych informacji** takich jak PII czy dane finansowe. Charakteryzują się minimalistycznym środowiskiem, co znacznie zmniejsza ryzyko wycieku danych. Dodatkowo, Nitro Enclaves wspiera kryptograficzne poświadczenia, pozwalając użytkownikom na weryfikację, że uruchamiany jest tylko autoryzowany kod, co jest kluczowe dla utrzymania ścisłych standardów zgodności i ochrony danych.

{% hint style="danger" %}
Obrazy Nitro Enclave są **uruchamiane wewnątrz instancji EC2** i nie można zobaczyć z konsoli webowej AWS, czy instancja EC2 uruchamia obrazy w Nitro Enclave, czy nie.
{% endhint %}

## Instalacja Nitro Enclave CLI

Postępuj zgodnie ze wszystkimi instrukcjami [**z dokumentacji**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave). Jednakże, te są najważniejsze:
```bash
# Install tools
sudo amazon-linux-extras install aws-nitro-enclaves-cli -y
sudo yum install aws-nitro-enclaves-cli-devel -y

# Config perms
sudo usermod -aG ne $USER
sudo usermod -aG docker $USER

# Check installation
nitro-cli --version

# Start and enable the Nitro Enclaves allocator service.
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service
```
## Nitro Enclave Images

Obrazy, które można uruchomić w Nitro Enclave, są oparte na obrazach docker, więc można tworzyć obrazy Nitro Enclave z obrazów docker, takich jak:
```bash
# You need to have the docker image accesible in your running local registry
# Or indicate the full docker image URL to access the image
nitro-cli build-enclave --docker-uri <docker-img>:<tag> --output-file nitro-img.eif
```
Jak widać, obrazy Nitro Enclave używają rozszerzenia **`eif`** (Enclave Image File).

Wynik będzie wyglądał podobnie do:
```
Using the locally available Docker image...
Enclave Image successfully created.
{
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
```
### Uruchom obraz

Zgodnie z [**dokumentacją**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave), aby uruchomić obraz enclave, musisz przypisać mu pamięć **co najmniej 4 razy większą niż rozmiar pliku `eif`**. Możliwe jest skonfigurowanie domyślnych zasobów do przydzielenia w pliku
```shell
/etc/nitro_enclaves/allocator.yaml
```
{% hint style="danger" %}
Zawsze pamiętaj, że musisz **zarezerwować trochę zasobów dla nadrzędnej instancji EC2**!
{% endhint %}

Po poznaniu zasobów do przydzielenia obrazowi i nawet po modyfikacji pliku konfiguracyjnego możliwe jest uruchomienie obrazu enclave za pomocą:

{% code overflow="wrap" %}
```shell
# Restart the service so the new default values apply
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service

# Indicate the CPUs and memory to give
nitro-cli run-enclave --cpu-count 2 --memory 3072 --eif-path hello.eif --debug-mode --enclave-cid 16
```
{% endcode %}

### Enumerate Enclaves

Jeśli przejmiesz hosta EC2, możliwe jest uzyskanie listy uruchomionych obrazów enclave za pomocą:
```bash
nitro-cli describe-enclaves
```
Nie jest **możliwe uzyskanie powłoki** wewnątrz działającego obrazu enclave, ponieważ to jest główny cel enclave, jednakże, jeśli użyjesz parametru **`--debug-mode`**, możliwe jest uzyskanie **stdout** za pomocą:
```shell
ENCLAVE_ID=$(nitro-cli describe-enclaves | jq -r ".[0].EnclaveID")
nitro-cli console --enclave-id ${ENCLAVE_ID}
```
### Terminate Enclaves

Jeśli atakujący skompromituje instancję EC2, domyślnie nie będzie w stanie uzyskać powłoki wewnątrz nich, ale będzie mógł je **zakończyć** za pomocą:
```shell
nitro-cli terminate-enclave --enclave-id ${ENCLAVE_ID}
```
## Vsocks

Jedynym sposobem komunikacji z obrazem uruchomionym w **enklawie** jest użycie **vsocks**.

**Virtual Socket (vsock)** to rodzina gniazd w systemie Linux, zaprojektowana specjalnie do ułatwienia **komunikacji** między maszynami wirtualnymi (**VMs**) a ich **hipernadzorcami** lub między samymi VMs. Vsock umożliwia efektywną, **dwukierunkową komunikację** bez polegania na stosie sieciowym hosta. Dzięki temu VMs mogą się komunikować nawet bez konfiguracji sieci, **używając 32-bitowego identyfikatora kontekstu (CID) i numerów portów** do identyfikacji i zarządzania połączeniami. API vsock obsługuje zarówno strumieniowe, jak i datagramowe typy gniazd, podobnie jak TCP i UDP, co czyni go wszechstronnym narzędziem dla aplikacji użytkownika w środowiskach wirtualnych.

{% hint style="success" %}
Dlatego adres vsock wygląda tak: `<CID>:<Port>`
{% endhint %}

Aby znaleźć **CIDs** obrazów uruchomionych w enklawie, można wykonać następujące polecenie i uzyskać **`EnclaveCID`**:

<pre class="language-bash"><code class="lang-bash">nitro-cli describe-enclaves

[
{
"EnclaveName": "secure-channel-example",
"EnclaveID": "i-0bc274f83ade02a62-enc18ef3d09c886748",
"ProcessID": 10131,
<strong>    "EnclaveCID": 16,
</strong>    "NumberOfCPUs": 2,
"CPUIDs": [
1,
3
],
"MemoryMiB": 1024,
"State": "RUNNING",
"Flags": "DEBUG_MODE",
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
]
</code></pre>

{% hint style="warning" %}
Zauważ, że z hosta nie ma żadnego sposobu, aby dowiedzieć się, czy CID udostępnia jakikolwiek port! Chyba że użyjesz jakiegoś **skanera portów vsock, takiego jak** [**https://github.com/carlospolop/Vsock-scanner**](https://github.com/carlospolop/Vsock-scanner).
{% endhint %}

### Vsock Server/Listener

Znajdź tutaj kilka przykładów:

* [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py)

<details>

<summary>Prosty Python Listener</summary>
```python
#!/usr/bin/env python3

# From
https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.bind((CID, PORT))
s.listen()
(conn, (remote_cid, remote_port)) = s.accept()

print(f"Connection opened by cid={remote_cid} port={remote_port}")

while True:
buf = conn.recv(64)
if not buf:
break

print(f"Received bytes: {buf}")
```
```markdown
</details>
```
```bash
# Using socat
socat VSOCK-LISTEN:<port>,fork EXEC:"echo Hello from server!"
```
### Vsock Client

Przykłady:

* [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py)

<details>

<summary>Prosty klient Python</summary>
```python
#!/usr/bin/env python3

#From https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.connect((CID, PORT))
s.sendall(b"Hello, world!")
s.close()
```
</details>
```bash
# Using socat
echo "Hello, vsock!" | socat - VSOCK-CONNECT:3:5000
```
### Vsock Proxy

Narzędzie vsock-proxy pozwala na proxy vsock proxy z innym adresem, na przykład:
```bash
vsock-proxy 8001 ip-ranges.amazonaws.com 443 --config your-vsock-proxy.yaml
```
To przekieruje **lokalny port 8001 w vsock** do `ip-ranges.amazonaws.com:443`, a plik **`your-vsock-proxy.yaml`** może zawierać tę treść, umożliwiając dostęp do `ip-ranges.amazonaws.com:443`:
```yaml
allowlist:
- {address: ip-ranges.amazonaws.com, port: 443}
```
Możliwe jest zobaczenie adresów vsock (**`<CID>:<Port>`**) używanych przez hosta EC2 za pomocą (zwróć uwagę na `3:8001`, 3 to CID, a 8001 to port):

{% code overflow="wrap" %}
```bash
sudo ss -l -p -n | grep v_str
v_str LISTEN 0      0                                                                              3:8001                   *:*     users:(("vsock-proxy",pid=9458,fd=3))
```
{% endcode %}

## Nitro Enclave Atestacja & KMS

Nitro Enclaves SDK pozwala enklawie na żądanie **kryptograficznie podpisanego dokumentu atestacyjnego** od Nitro **Hypervisor**, który zawiera **unikalne pomiary** specyficzne dla tej enklawy. Te pomiary, które obejmują **hashe i rejestry konfiguracji platformy (PCRs)**, są używane podczas procesu atestacji do **udowodnienia tożsamości enklawy** i **budowania zaufania z zewnętrznymi usługami**. Dokument atestacyjny zazwyczaj zawiera wartości takie jak PCR0, PCR1 i PCR2, które spotkałeś wcześniej podczas budowania i zapisywania enklawy EIF.

Z [**dokumentacji**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-3-cryptographic-attestation#a-unique-feature-on-nitro-enclaves), oto wartości PCR:

<table><thead><tr><th width="97">PCR</th><th width="221">Hash of ...</th><th>Opis</th></tr></thead><tbody><tr><td>PCR0</td><td>Enclave image file</td><td>Kontynuowany pomiar zawartości pliku obrazu, bez danych sekcji.</td></tr><tr><td>PCR1</td><td>Linux kernel and bootstrap</td><td>Kontynuowany pomiar jądra i danych boot ramfs.</td></tr><tr><td>PCR2</td><td>Application</td><td>Kontynuowany, uporządkowany pomiar aplikacji użytkownika, bez boot ramfs.</td></tr><tr><td>PCR3</td><td>IAM role assigned to the parent instance</td><td>Kontynuowany pomiar roli IAM przypisanej do instancji nadrzędnej. Zapewnia, że proces atestacji zakończy się sukcesem tylko wtedy, gdy instancja nadrzędna ma poprawną rolę IAM.</td></tr><tr><td>PCR4</td><td>Instance ID of the parent instance</td><td>Kontynuowany pomiar ID instancji nadrzędnej. Zapewnia, że proces atestacji zakończy się sukcesem tylko wtedy, gdy instancja nadrzędna ma określone ID instancji.</td></tr><tr><td>PCR8</td><td>Enclave image file signing certificate</td><td>Pomiar certyfikatu podpisującego określonego dla pliku obrazu enklawy. Zapewnia, że proces atestacji zakończy się sukcesem tylko wtedy, gdy enklawa została uruchomiona z pliku obrazu enklawy podpisanego przez określony certyfikat.</td></tr></tbody></table>

Możesz zintegrować **kryptograficzną atestację** ze swoimi aplikacjami i wykorzystać wbudowane integracje z usługami takimi jak **AWS KMS**. AWS KMS może **weryfikować atestacje enklaw** i oferuje klucze warunków oparte na atestacji (`kms:RecipientAttestation:ImageSha384` i `kms:RecipientAttestation:PCR`) w swoich politykach kluczy. Te polityki zapewniają, że AWS KMS zezwala na operacje przy użyciu klucza KMS **tylko wtedy, gdy dokument atestacyjny enklawy jest ważny** i spełnia **określone warunki**.

{% hint style="success" %}
Należy zauważyć, że Enklawy w trybie debugowania (--debug) generują dokumenty atestacyjne z PCRs, które składają się z zer (`000000000000000000000000000000000000000000000000`). Dlatego polityki KMS sprawdzające te wartości zakończą się niepowodzeniem.
{% endhint %}

### PCR Bypass

Z perspektywy atakującego, zauważ, że niektóre PCRs pozwalają na modyfikację niektórych części lub całego obrazu enklawy i nadal będą ważne (na przykład PCR4 sprawdza tylko ID instancji nadrzędnej, więc uruchomienie dowolnego obrazu enklawy w tej EC2 pozwoli spełnić ten potencjalny wymóg PCR).

Dlatego atakujący, który skompromituje instancję EC2, może być w stanie uruchomić inne obrazy enklawy, aby obejść te zabezpieczenia.

Badania nad tym, jak modyfikować/tworzyć nowe obrazy w celu obejścia każdej ochrony (szczególnie te mniej oczywiste) są nadal w toku.

## Referencje

* [https://medium.com/@F.DL/understanding-vsock-684016cf0eb0](https://medium.com/@F.DL/understanding-vsock-684016cf0eb0)
* Wszystkie części samouczka Nitro od AWS: [https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli)

{% hint style="success" %}
Ucz się i ćwicz AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Ucz się i ćwicz GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wspieraj HackTricks</summary>

* Sprawdź [**plany subskrypcji**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel się trikami hakerskimi, przesyłając PR do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>
{% endhint %}
