# AWS - Nitro Enum

{% hint style="success" %}
Impara e pratica AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Impara e pratica GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repository github.

</details>
{% endhint %}

## Informazioni di base

AWS Nitro √® una suite di **tecnologie innovative** che costituiscono la piattaforma sottostante per le istanze AWS EC2. Introdotto da Amazon per **migliorare la sicurezza, le prestazioni e l'affidabilit√†**, Nitro sfrutta componenti **hardware personalizzati e un hypervisor leggero**. Astrae gran parte della funzionalit√† di virtualizzazione tradizionale su hardware e software dedicati, **minimizzando la superficie di attacco** e migliorando l'efficienza delle risorse. Delegando le funzioni di virtualizzazione, Nitro consente alle istanze EC2 di offrire **prestazioni quasi bare-metal**, rendendolo particolarmente vantaggioso per applicazioni ad alta intensit√† di risorse. Inoltre, il Nitro Security Chip garantisce specificamente la **sicurezza dell'hardware e del firmware**, consolidando ulteriormente la sua architettura robusta.

### Nitro Enclaves

**AWS Nitro Enclaves** fornisce un ambiente di calcolo sicuro e **isolato all'interno delle istanze Amazon EC2**, specificamente progettato per elaborare dati altamente sensibili. Sfruttando il sistema AWS Nitro, questi enclavi garantiscono un'**isolamento e sicurezza** robusti, ideali per **gestire informazioni riservate** come PII o registri finanziari. Presentano un ambiente minimalista, riducendo significativamente il rischio di esposizione dei dati. Inoltre, Nitro Enclaves supporta l'attestazione crittografica, consentendo agli utenti di verificare che solo il codice autorizzato sia in esecuzione, cruciale per mantenere standard rigorosi di conformit√† e protezione dei dati.

{% hint style="danger" %}
Le immagini Nitro Enclave sono **eseguite dall'interno delle istanze EC2** e non √® possibile vedere dalla console web AWS se un'istanza EC2 sta eseguendo immagini in Nitro Enclave o meno.
{% endhint %}

## Installazione del CLI Nitro Enclave

Segui tutte le istruzioni [**dalla documentazione**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave). Tuttavia, queste sono le pi√π importanti:
```bash
# Install tools
sudo amazon-linux-extras install aws-nitro-enclaves-cli -y
sudo yum install aws-nitro-enclaves-cli-devel -y

# Config perms
sudo usermod -aG ne $USER
sudo usermod -aG docker $USER

# Check installation
nitro-cli --version

# Start and enable the Nitro Enclaves allocator service.
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service
```
## Nitro Enclave Images

Le immagini che puoi eseguire in Nitro Enclave sono basate su immagini docker, quindi puoi creare le tue immagini Nitro Enclave da immagini docker come:
```bash
# You need to have the docker image accesible in your running local registry
# Or indicate the full docker image URL to access the image
nitro-cli build-enclave --docker-uri <docker-img>:<tag> --output-file nitro-img.eif
```
Come puoi vedere, le immagini Nitro Enclave usano l'estensione **`eif`** (Enclave Image File).

L'output sar√† simile a:
```
Using the locally available Docker image...
Enclave Image successfully created.
{
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
```
### Eseguire un'Immagine

Secondo [**la documentazione**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave), per eseguire un'immagine enclave √® necessario assegnarle una memoria di **almeno 4 volte la dimensione del file `eif`**. √à possibile configurare le risorse predefinite da assegnarle nel file&#x20;
```shell
/etc/nitro_enclaves/allocator.yaml
```
{% hint style="danger" %}
Ricorda sempre che devi **riservare alcune risorse anche per l'istanza EC2 principale**!
{% endhint %}

Dopo aver determinato le risorse da assegnare a un'immagine e aver modificato il file di configurazione, √® possibile eseguire un'immagine enclave con:

{% code overflow="wrap" %}
```shell
# Restart the service so the new default values apply
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service

# Indicate the CPUs and memory to give
nitro-cli run-enclave --cpu-count 2 --memory 3072 --eif-path hello.eif --debug-mode --enclave-cid 16
```
{% endcode %}

### Enumerare Enclavi

Se comprometti un host EC2 √® possibile ottenere un elenco delle immagini enclave in esecuzione con:
```bash
nitro-cli describe-enclaves
```
√à **impossibile ottenere una shell** all'interno di un'immagine enclave in esecuzione perch√© questo √® lo scopo principale dell'enclave, tuttavia, se hai utilizzato il parametro **`--debug-mode`**, √® possibile ottenere il **stdout** con:
```shell
ENCLAVE_ID=$(nitro-cli describe-enclaves | jq -r ".[0].EnclaveID")
nitro-cli console --enclave-id ${ENCLAVE_ID}
```
### Terminate Enclaves

Se un attaccante compromette un'istanza EC2, di default non sar√† in grado di ottenere una shell al suo interno, ma sar√† in grado di **terminarla** con:
```shell
nitro-cli terminate-enclave --enclave-id ${ENCLAVE_ID}
```
## Vsocks

L'unico modo per comunicare con un'immagine in esecuzione in un **enclave** √® utilizzare **vsocks**.

**Virtual Socket (vsock)** √® una famiglia di socket in Linux specificamente progettata per facilitare la **comunicazione** tra macchine virtuali (**VMs**) e i loro **hypervisors**, o tra le VMs **stesse**. Vsock consente una comunicazione **bidirezionale efficiente** senza fare affidamento sullo stack di rete dell'host. Questo rende possibile la comunicazione tra VMs anche senza configurazioni di rete, **utilizzando un ID di contesto (CID) a 32 bit e numeri di porta** per identificare e gestire le connessioni. L'API vsock supporta sia i tipi di socket stream che datagram, simili a TCP e UDP, fornendo uno strumento versatile per le applicazioni a livello utente negli ambienti virtuali.

{% hint style="success" %}
Pertanto, un indirizzo vsock appare cos√¨: `<CID>:<Port>`
{% endhint %}

Per trovare i **CIDs** delle immagini in esecuzione nell'enclave, √® possibile eseguire il seguente comando e ottenere il **`EnclaveCID`**:

<pre class="language-bash"><code class="lang-bash">nitro-cli describe-enclaves

[
{
"EnclaveName": "secure-channel-example",
"EnclaveID": "i-0bc274f83ade02a62-enc18ef3d09c886748",
"ProcessID": 10131,
<strong>    "EnclaveCID": 16,
</strong>    "NumberOfCPUs": 2,
"CPUIDs": [
1,
3
],
"MemoryMiB": 1024,
"State": "RUNNING",
"Flags": "DEBUG_MODE",
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
]
</code></pre>

{% hint style="warning" %}
Nota che dall'host non c'√® modo di sapere se un CID sta esponendo una porta! A meno che non si utilizzi uno **scanner di porte vsock come** [**https://github.com/carlospolop/Vsock-scanner**](https://github.com/carlospolop/Vsock-scanner).
{% endhint %}

### Vsock Server/Listener

Trova qui un paio di esempi:

* [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py)

<details>

<summary>Listener Python Semplice</summary>
```python
#!/usr/bin/env python3

# From
https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.bind((CID, PORT))
s.listen()
(conn, (remote_cid, remote_port)) = s.accept()

print(f"Connection opened by cid={remote_cid} port={remote_port}")

while True:
buf = conn.recv(64)
if not buf:
break

print(f"Received bytes: {buf}")
```
</details>
```bash
# Using socat
socat VSOCK-LISTEN:<port>,fork EXEC:"echo Hello from server!"
```
### Vsock Client

Esempi:

* [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py)

<details>

<summary>Semplice Client Python</summary>
```python
#!/usr/bin/env python3

#From https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.connect((CID, PORT))
s.sendall(b"Hello, world!")
s.close()
```
</details>
```bash
# Using socat
echo "Hello, vsock!" | socat - VSOCK-CONNECT:3:5000
```
### Vsock Proxy

Lo strumento vsock-proxy consente di proxy un vsock proxy con un altro indirizzo, ad esempio:
```bash
vsock-proxy 8001 ip-ranges.amazonaws.com 443 --config your-vsock-proxy.yaml
```
Questo inoltrer√† la **porta locale 8001 in vsock** a `ip-ranges.amazonaws.com:443` e il file **`your-vsock-proxy.yaml`** potrebbe avere questo contenuto che consente di accedere a `ip-ranges.amazonaws.com:443`:
```yaml
allowlist:
- {address: ip-ranges.amazonaws.com, port: 443}
```
√à possibile vedere gli indirizzi vsock (**`<CID>:<Port>`**) utilizzati dall'host EC2 con (nota il `3:8001`, 3 √® il CID e 8001 la porta):

{% code overflow="wrap" %}
```bash
sudo ss -l -p -n | grep v_str
v_str LISTEN 0      0                                                                              3:8001                   *:*     users:(("vsock-proxy",pid=9458,fd=3))
```
{% endcode %}

## Nitro Enclave Attestazione & KMS

Il Nitro Enclaves SDK consente a un enclave di richiedere un **documento di attestazione crittograficamente firmato** dal **Hypervisor** Nitro, che include **misurazioni uniche** specifiche per quell'enclave. Queste misurazioni, che includono **hash e registri di configurazione della piattaforma (PCR)**, vengono utilizzate durante il processo di attestazione per **provare l'identit√† dell'enclave** e **costruire fiducia con i servizi esterni**. Il documento di attestazione contiene tipicamente valori come PCR0, PCR1 e PCR2, che hai gi√† incontrato quando hai costruito e salvato un enclave EIF.

Dai [**docs**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-3-cryptographic-attestation#a-unique-feature-on-nitro-enclaves), questi sono i valori PCR:

<table><thead><tr><th width="97">PCR</th><th width="221">Hash di ...</th><th>Descrizione</th></tr></thead><tbody><tr><td>PCR0</td><td>Enclave image file</td><td>Una misura continua del contenuto del file immagine, senza i dati della sezione.</td></tr><tr><td>PCR1</td><td>Linux kernel e bootstrap</td><td>Una misura continua del kernel e dei dati boot ramfs.</td></tr><tr><td>PCR2</td><td>Applicazione</td><td>Una misura continua e in ordine delle applicazioni utente, senza il boot ramfs.</td></tr><tr><td>PCR3</td><td>Ruolo IAM assegnato all'istanza principale</td><td>Una misura continua del ruolo IAM assegnato all'istanza principale. Garantisce che il processo di attestazione abbia successo solo quando l'istanza principale ha il ruolo IAM corretto.</td></tr><tr><td>PCR4</td><td>ID dell'istanza principale</td><td>Una misura continua dell'ID dell'istanza principale. Garantisce che il processo di attestazione abbia successo solo quando l'istanza principale ha un ID specifico.</td></tr><tr><td>PCR8</td><td>Certificato di firma del file immagine dell'enclave</td><td>Una misura del certificato di firma specificato per il file immagine dell'enclave. Garantisce che il processo di attestazione abbia successo solo quando l'enclave √® stata avviata da un file immagine dell'enclave firmato da un certificato specifico.</td></tr></tbody></table>

Puoi integrare l'**attestazione crittografica** nelle tue applicazioni e sfruttare le integrazioni predefinite con servizi come **AWS KMS**. AWS KMS pu√≤ **validare le attestazioni dell'enclave** e offre chiavi di condizione basate sull'attestazione (`kms:RecipientAttestation:ImageSha384` e `kms:RecipientAttestation:PCR`) nelle sue politiche chiave. Queste politiche garantiscono che AWS KMS permetta operazioni utilizzando la chiave KMS **solo se il documento di attestazione dell'enclave √® valido** e soddisfa le **condizioni specificate**.

{% hint style="success" %}
Nota che le Enclaves in modalit√† debug (--debug) generano documenti di attestazione con PCR composti da zeri (`000000000000000000000000000000000000000000000000`). Pertanto, le politiche KMS che controllano questi valori falliranno.
{% endhint %}

### Bypass PCR

Dal punto di vista di un attaccante, nota che alcuni PCR permetterebbero di modificare alcune parti o tutto il file immagine dell'enclave e sarebbero ancora validi (ad esempio, PCR4 controlla solo l'ID dell'istanza principale, quindi eseguire qualsiasi file immagine dell'enclave in quell'EC2 permetter√† di soddisfare questo potenziale requisito PCR).

Pertanto, un attaccante che compromette l'istanza EC2 potrebbe essere in grado di eseguire altre immagini dell'enclave per bypassare queste protezioni.

La ricerca su come modificare/creare nuove immagini per bypassare ogni protezione (specialmente quelle non cos√¨ ovvie) √® ancora DA FARE.

## Riferimenti

* [https://medium.com/@F.DL/understanding-vsock-684016cf0eb0](https://medium.com/@F.DL/understanding-vsock-684016cf0eb0)
* Tutte le parti del tutorial Nitro da AWS: [https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli)

{% hint style="success" %}
Impara e pratica AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Impara e pratica GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github repos.**

</details>
{% endhint %}
