# AWS - Nitro Enum

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## 기본 정보

AWS Nitro는 AWS EC2 인스턴스의 기본 플랫폼을 구성하는 **혁신적인 기술** 모음입니다. Amazon이 **보안, 성능 및 신뢰성을 향상**시키기 위해 도입한 Nitro는 맞춤형 **하드웨어 구성 요소와 경량 하이퍼바이저**를 활용합니다. 전통적인 가상화 기능의 많은 부분을 전용 하드웨어와 소프트웨어로 추상화하여 **공격 표면을 최소화**하고 자원 효율성을 향상시킵니다. 가상화 기능을 오프로드함으로써 Nitro는 EC2 인스턴스가 **거의 베어 메탈 성능**을 제공할 수 있게 하여 자원 집약적인 애플리케이션에 특히 유리합니다. 또한, Nitro 보안 칩은 **하드웨어 및 펌웨어의 보안**을 보장하여 견고한 아키텍처를 더욱 강화합니다.

### Nitro Enclaves

**AWS Nitro Enclaves**는 Amazon EC2 인스턴스 내에서 **고도로 민감한 데이터를 처리**하기 위해 설계된 안전하고 **격리된 컴퓨팅 환경**을 제공합니다. AWS Nitro 시스템을 활용하여 이러한 엔클레이브는 강력한 **격리 및 보안**을 보장하며, **PII나 금융 기록**과 같은 기밀 정보를 처리하는 데 이상적입니다. 최소한의 환경을 제공하여 데이터 노출 위험을 크게 줄입니다. 또한, Nitro Enclaves는 암호화 인증을 지원하여 사용자가 승인된 코드만 실행되고 있음을 확인할 수 있게 하여 엄격한 준수 및 데이터 보호 표준을 유지하는 데 필수적입니다.

{% hint style="danger" %}
Nitro Enclave 이미지는 **EC2 인스턴스 내부에서 실행**되며, AWS 웹 콘솔에서는 EC2 인스턴스가 Nitro Enclave에서 이미지를 실행 중인지 여부를 확인할 수 없습니다.
{% endhint %}

## Nitro Enclave CLI 설치

모든 지침을 [**문서에서**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave) 따르십시오. 그러나, 다음이 가장 중요한 지침입니다:
```bash
# Install tools
sudo amazon-linux-extras install aws-nitro-enclaves-cli -y
sudo yum install aws-nitro-enclaves-cli-devel -y

# Config perms
sudo usermod -aG ne $USER
sudo usermod -aG docker $USER

# Check installation
nitro-cli --version

# Start and enable the Nitro Enclaves allocator service.
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service
```
## Nitro Enclave Images

Nitro Enclave에서 실행할 수 있는 이미지는 docker 이미지 기반이므로 다음과 같은 docker 이미지에서 Nitro Enclave 이미지를 생성할 수 있습니다:
```bash
# You need to have the docker image accesible in your running local registry
# Or indicate the full docker image URL to access the image
nitro-cli build-enclave --docker-uri <docker-img>:<tag> --output-file nitro-img.eif
```
Nitro Enclave 이미지가 **`eif`** (Enclave Image File) 확장자를 사용하는 것을 볼 수 있습니다.

출력은 다음과 유사하게 보일 것입니다:
```
Using the locally available Docker image...
Enclave Image successfully created.
{
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
```
### Run an Image

[**문서**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave)에 따르면, enclave 이미지를 실행하려면 **`eif` 파일 크기의 최소 4배의 메모리**를 할당해야 합니다. 파일에서 기본 리소스를 구성하여 할당할 수 있습니다.
```shell
/etc/nitro_enclaves/allocator.yaml
```
{% hint style="danger" %}
항상 **부모 EC2** 인스턴스를 위해 일부 리소스를 예약해야 한다는 것을 기억하세요!
{% endhint %}

이미지에 제공할 리소스를 알고 구성 파일을 수정한 후에도 enclave 이미지를 실행할 수 있습니다:

{% code overflow="wrap" %}
```shell
# Restart the service so the new default values apply
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service

# Indicate the CPUs and memory to give
nitro-cli run-enclave --cpu-count 2 --memory 3072 --eif-path hello.eif --debug-mode --enclave-cid 16
```
{% endcode %}

### Enclaves 열거

EC2 호스트를 손상시키면 다음을 통해 실행 중인 enclave 이미지 목록을 얻을 수 있습니다:
```bash
nitro-cli describe-enclaves
```
실행 중인 enclave 이미지 내부에 **shell을 얻는 것은 불가능**합니다. 이는 enclave의 주요 목적이기 때문입니다. 그러나 **`--debug-mode`** 매개변수를 사용하면, 다음과 같이 **stdout**을 얻는 것이 가능합니다:
```shell
ENCLAVE_ID=$(nitro-cli describe-enclaves | jq -r ".[0].EnclaveID")
nitro-cli console --enclave-id ${ENCLAVE_ID}
```
### Terminate Enclaves

공격자가 기본적으로 EC2 인스턴스를 손상시키면 내부에 셸을 얻을 수는 없지만, 다음과 같이 **종료**할 수 있습니다:
```shell
nitro-cli terminate-enclave --enclave-id ${ENCLAVE_ID}
```
## Vsocks

**enclave** 실행 이미지를 통신하는 유일한 방법은 **vsocks**를 사용하는 것입니다.

**Virtual Socket (vsock)**은 가상 머신(**VMs**)과 그 **하이퍼바이저** 또는 VMs 간의 **통신**을 용이하게 하기 위해 Linux에서 특별히 설계된 소켓 패밀리입니다. Vsock은 호스트의 네트워킹 스택에 의존하지 않고 효율적이고 **양방향 통신**을 가능하게 합니다. 이를 통해 네트워크 구성 없이도 VMs 간의 통신이 가능하며, **32비트 Context ID (CID)와 포트 번호**를 사용하여 연결을 식별하고 관리합니다. vsock API는 TCP와 UDP와 유사하게 스트림 및 데이터그램 소켓 유형을 모두 지원하여 가상 환경에서 사용자 수준 애플리케이션에 유연한 도구를 제공합니다.

{% hint style="success" %}
따라서 vsock 주소는 다음과 같이 보입니다: `<CID>:<Port>`
{% endhint %}

**enclave** 실행 이미지의 **CIDs**를 찾으려면 다음 명령어를 실행하고 **`EnclaveCID`**를 확인하면 됩니다:

<pre class="language-bash"><code class="lang-bash">nitro-cli describe-enclaves

[
{
"EnclaveName": "secure-channel-example",
"EnclaveID": "i-0bc274f83ade02a62-enc18ef3d09c886748",
"ProcessID": 10131,
<strong>    "EnclaveCID": 16,
</strong>    "NumberOfCPUs": 2,
"CPUIDs": [
1,
3
],
"MemoryMiB": 1024,
"State": "RUNNING",
"Flags": "DEBUG_MODE",
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
]
</code></pre>

{% hint style="warning" %}
호스트에서 CID가 포트를 노출하고 있는지 알 수 있는 방법은 없습니다! **vsock 포트 스캐너** [**https://github.com/carlospolop/Vsock-scanner**](https://github.com/carlospolop/Vsock-scanner)와 같은 도구를 사용하지 않는 한.
{% endhint %}

### Vsock Server/Listener

여기 몇 가지 예시가 있습니다:

* [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py)

<details>

<summary>Simple Python Listener</summary>
```python
#!/usr/bin/env python3

# From
https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.bind((CID, PORT))
s.listen()
(conn, (remote_cid, remote_port)) = s.accept()

print(f"Connection opened by cid={remote_cid} port={remote_port}")

while True:
buf = conn.recv(64)
if not buf:
break

print(f"Received bytes: {buf}")
```
</details>
```bash
# Using socat
socat VSOCK-LISTEN:<port>,fork EXEC:"echo Hello from server!"
```
### Vsock Client

예시:

* [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py)

<details>

<summary>간단한 Python Client</summary>
```python
#!/usr/bin/env python3

#From https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.connect((CID, PORT))
s.sendall(b"Hello, world!")
s.close()
```
</details>
```bash
# Using socat
echo "Hello, vsock!" | socat - VSOCK-CONNECT:3:5000
```
### Vsock Proxy

vsock-proxy 도구는 다른 주소로 vsock 프록시를 프록시할 수 있게 해줍니다. 예를 들어:
```bash
vsock-proxy 8001 ip-ranges.amazonaws.com 443 --config your-vsock-proxy.yaml
```
이것은 **vsock의 로컬 포트 8001**을 `ip-ranges.amazonaws.com:443`로 포워딩하며, 파일 **`your-vsock-proxy.yaml`**은 `ip-ranges.amazonaws.com:443`에 접근할 수 있도록 다음과 같은 내용을 포함할 수 있습니다:
```yaml
allowlist:
- {address: ip-ranges.amazonaws.com, port: 443}
```
EC2 호스트에서 사용되는 vsock 주소(**`<CID>:<Port>`**)를 볼 수 있습니다 (`3:8001`에 주목하십시오. 3은 CID이고 8001은 포트입니다):

{% code overflow="wrap" %}
```bash
sudo ss -l -p -n | grep v_str
v_str LISTEN 0      0                                                                              3:8001                   *:*     users:(("vsock-proxy",pid=9458,fd=3))
```
{% endcode %}

## Nitro Enclave Atestation & KMS

Nitro Enclaves SDK는 enclave가 Nitro **Hypervisor**로부터 **암호학적으로 서명된 attestation 문서**를 요청할 수 있게 합니다. 이 문서에는 해당 enclave에 고유한 **측정값**이 포함됩니다. 이러한 측정값은 **해시 및 플랫폼 구성 레지스터(PCR)**를 포함하며, attestation 과정에서 **enclave의 신원을 증명**하고 **외부 서비스와의 신뢰를 구축**하는 데 사용됩니다. attestation 문서에는 일반적으로 PCR0, PCR1, PCR2와 같은 값이 포함되며, 이는 enclave EIF를 구축하고 저장할 때 접하게 되는 값입니다.

[**문서**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-3-cryptographic-attestation#a-unique-feature-on-nitro-enclaves)에 따르면, 다음은 PCR 값입니다:

<table><thead><tr><th width="97">PCR</th><th width="221">Hash of ...</th><th>Description</th></tr></thead><tbody><tr><td>PCR0</td><td>Enclave image file</td><td>이미지 파일의 내용의 연속적인 측정값, 섹션 데이터 제외.</td></tr><tr><td>PCR1</td><td>Linux kernel and bootstrap</td><td>커널 및 부트 ramfs 데이터의 연속적인 측정값.</td></tr><tr><td>PCR2</td><td>Application</td><td>부트 ramfs를 제외한 사용자 애플리케이션의 연속적이고 순차적인 측정값.</td></tr><tr><td>PCR3</td><td>IAM role assigned to the parent instance</td><td>상위 인스턴스에 할당된 IAM 역할의 연속적인 측정값. 상위 인스턴스에 올바른 IAM 역할이 할당된 경우에만 attestation 과정이 성공하도록 보장.</td></tr><tr><td>PCR4</td><td>Instance ID of the parent instance</td><td>상위 인스턴스의 ID의 연속적인 측정값. 상위 인스턴스에 특정 인스턴스 ID가 있는 경우에만 attestation 과정이 성공하도록 보장.</td></tr><tr><td>PCR8</td><td>Enclave image file signing certificate</td><td>enclave 이미지 파일에 지정된 서명 인증서의 측정값. 특정 인증서로 서명된 enclave 이미지 파일에서 부팅된 경우에만 attestation 과정이 성공하도록 보장.</td></tr></tbody></table>

**암호학적 attestation**을 애플리케이션에 통합하고 **AWS KMS**와 같은 서비스와의 사전 구축된 통합을 활용할 수 있습니다. AWS KMS는 **enclave attestation을 검증**할 수 있으며, 키 정책에서 attestation 기반 조건 키(`kms:RecipientAttestation:ImageSha384` 및 `kms:RecipientAttestation:PCR`)를 제공합니다. 이러한 정책은 AWS KMS가 **enclave의 attestation 문서가 유효하고** 지정된 조건을 충족하는 경우에만 KMS 키를 사용한 작업을 허용하도록 보장합니다.

{% hint style="success" %}
디버그 모드(--debug)에서 Enclaves는 PCR이 모두 0으로 구성된(`000000000000000000000000000000000000000000000000`) attestation 문서를 생성합니다. 따라서 이러한 값을 확인하는 KMS 정책은 실패할 것입니다.
{% endhint %}

### PCR Bypass

공격자의 관점에서 보면, 일부 PCR은 enclave 이미지의 일부 또는 전체를 수정해도 여전히 유효할 수 있습니다(예: PCR4는 상위 인스턴스의 ID만 확인하므로 해당 EC2에서 어떤 enclave 이미지를 실행해도 이 PCR 요구 사항을 충족할 수 있습니다).

따라서 EC2 인스턴스를 손상시킨 공격자는 이러한 보호를 우회하기 위해 다른 enclave 이미지를 실행할 수 있습니다.

각 보호를 우회하기 위해 이미지를 수정/생성하는 방법에 대한 연구는 아직 진행 중입니다.

## References

* [https://medium.com/@F.DL/understanding-vsock-684016cf0eb0](https://medium.com/@F.DL/understanding-vsock-684016cf0eb0)
* AWS의 Nitro 튜토리얼 모든 부분: [https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli)

{% hint style="success" %}
AWS Hacking 학습 및 연습:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCP Hacking 학습 및 연습: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks 지원</summary>

* [**구독 플랜**](https://github.com/sponsors/carlospolop)을 확인하세요!
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**telegram 그룹**](https://t.me/peass)에 가입하거나 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)을 팔로우하세요.
* **PR을 제출하여** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 해킹 트릭을 공유하세요.

</details>
{% endhint %}
