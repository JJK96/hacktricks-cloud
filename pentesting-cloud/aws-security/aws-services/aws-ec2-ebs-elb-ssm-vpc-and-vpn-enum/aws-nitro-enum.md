# AWS - Nitro Enum

{% hint style="success" %}
学习和练习 AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
学习和练习 GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或 **关注** 我们的 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **通过提交 PRs 分享黑客技巧到** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库。

</details>
{% endhint %}

## 基本信息

AWS Nitro 是一套**创新技术**，构成了 AWS EC2 实例的基础平台。由 Amazon 推出以**增强安全性、性能和可靠性**，Nitro 利用定制的**硬件组件和轻量级的 hypervisor**。它将传统虚拟化功能的大部分抽象到专用硬件和软件中，**最小化攻击面**并提高资源效率。通过卸载虚拟化功能，Nitro 使 EC2 实例能够提供**接近裸机的性能**，这对资源密集型应用特别有利。此外，Nitro 安全芯片专门确保**硬件和固件的安全性**，进一步巩固其强大的架构。

### Nitro Enclaves

**AWS Nitro Enclaves** 提供一个安全的、**隔离的计算环境**，位于 Amazon EC2 实例内，专为处理高度敏感的数据而设计。利用 AWS Nitro 系统，这些 enclaves 确保了强大的**隔离和安全性**，非常适合**处理机密信息**，如 PII 或财务记录。它们具有极简环境，显著降低了数据暴露的风险。此外，Nitro Enclaves 支持加密认证，允许用户验证只有授权代码在运行，这对于保持严格的合规性和数据保护标准至关重要。

{% hint style="danger" %}
Nitro Enclave 镜像**从 EC2 实例内部运行**，你无法从 AWS web 控制台看到 EC2 实例是否在 Nitro Enclave 中运行镜像。
{% endhint %}

## Nitro Enclave CLI 安装

按照[**文档**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave)中的所有说明进行操作。然而，以下是最重要的部分：
```bash
# Install tools
sudo amazon-linux-extras install aws-nitro-enclaves-cli -y
sudo yum install aws-nitro-enclaves-cli-devel -y

# Config perms
sudo usermod -aG ne $USER
sudo usermod -aG docker $USER

# Check installation
nitro-cli --version

# Start and enable the Nitro Enclaves allocator service.
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service
```
## Nitro Enclave Images

你可以在 Nitro Enclave 中运行的镜像是基于 docker 镜像的，所以你可以从 docker 镜像创建你的 Nitro Enclave 镜像，如：
```bash
# You need to have the docker image accesible in your running local registry
# Or indicate the full docker image URL to access the image
nitro-cli build-enclave --docker-uri <docker-img>:<tag> --output-file nitro-img.eif
```
如你所见，Nitro Enclave 镜像使用扩展名 **`eif`**（Enclave Image File）。

输出将类似于：
```
Using the locally available Docker image...
Enclave Image successfully created.
{
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
```
### 运行一个镜像

根据[**文档**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli#run-connect-and-terminate-the-enclave)，为了运行一个enclave镜像，你需要分配**至少是`eif`文件大小4倍的内存**。可以在文件中配置默认资源给它
```shell
/etc/nitro_enclaves/allocator.yaml
```
{% hint style="danger" %}
请务必记住，您还需要为**父 EC2 实例保留一些资源**！
{% endhint %}

在了解了要分配给镜像的资源并修改了配置文件后，可以运行一个 enclave 镜像：

{% code overflow="wrap" %}
```shell
# Restart the service so the new default values apply
sudo systemctl start nitro-enclaves-allocator.service && sudo systemctl enable nitro-enclaves-allocator.service

# Indicate the CPUs and memory to give
nitro-cli run-enclave --cpu-count 2 --memory 3072 --eif-path hello.eif --debug-mode --enclave-cid 16
```
{% endcode %}

### 枚举 Enclaves

如果你攻破了一个 EC2 主机，可以使用以下命令获取正在运行的 enclave 镜像列表：
```bash
nitro-cli describe-enclaves
```
在运行的enclave镜像中**无法获取shell**，因为这是enclave的主要目的，但是，如果你使用了参数**`--debug-mode`**，可以通过以下方式获取它的**stdout**：
```shell
ENCLAVE_ID=$(nitro-cli describe-enclaves | jq -r ".[0].EnclaveID")
nitro-cli console --enclave-id ${ENCLAVE_ID}
```
### Terminate Enclaves

如果攻击者默认情况下攻陷了一个EC2实例，他将无法在其中获取shell，但他将能够**终止它们**，使用以下命令：
```shell
nitro-cli terminate-enclave --enclave-id ${ENCLAVE_ID}
```
## Vsocks

与运行中的**enclave**镜像通信的唯一方式是使用**vsocks**。

**Virtual Socket (vsock)** 是 Linux 中专门设计用于促进虚拟机（**VMs**）与其**hypervisors**之间或虚拟机**之间**通信的套接字家族。Vsock 使得在不依赖主机网络堆栈的情况下实现高效的**双向通信**成为可能。这使得即使没有网络配置，虚拟机也可以通信，**使用 32 位上下文 ID (CID) 和端口号**来识别和管理连接。Vsock API 支持流和数据报套接字类型，类似于 TCP 和 UDP，为虚拟环境中的用户级应用程序提供了多功能工具。

{% hint style="success" %}
因此，vsock 地址看起来像这样：`<CID>:<Port>`
{% endhint %}

要查找运行中的 enclave 镜像的 **CIDs**，只需执行以下命令并获取 **`EnclaveCID`**：

<pre class="language-bash"><code class="lang-bash">nitro-cli describe-enclaves

[
{
"EnclaveName": "secure-channel-example",
"EnclaveID": "i-0bc274f83ade02a62-enc18ef3d09c886748",
"ProcessID": 10131,
<strong>    "EnclaveCID": 16,
</strong>    "NumberOfCPUs": 2,
"CPUIDs": [
1,
3
],
"MemoryMiB": 1024,
"State": "RUNNING",
"Flags": "DEBUG_MODE",
"Measurements": {
"HashAlgorithm": "Sha384 { ... }",
"PCR0": "e199261541a944a93129a52a8909d29435dd89e31299b59c371158fc9ab3017d9c450b0a580a487e330b4ac691943284",
"PCR1": "bcdf05fefccaa8e55bf2c8d6dee9e79bbff31e34bf28a99aa19e6b29c37ee80b214a414b7607236edf26fcb78654e63f",
"PCR2": "2e1fca1dbb84622ec141557dfa971b4f8ea2127031b264136a20278c43d1bba6c75fea286cd4de9f00450b6a8db0e6d3"
}
}
]
</code></pre>

{% hint style="warning" %}
请注意，从主机上无法知道 CID 是否暴露了任何端口！除非使用一些**vsock 端口扫描器，如** [**https://github.com/carlospolop/Vsock-scanner**](https://github.com/carlospolop/Vsock-scanner)。
{% endhint %}

### Vsock Server/Listener

这里有几个示例：

* [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/server.py)

<details>

<summary>Simple Python Listener</summary>
```python
#!/usr/bin/env python3

# From
https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.bind((CID, PORT))
s.listen()
(conn, (remote_cid, remote_port)) = s.accept()

print(f"Connection opened by cid={remote_cid} port={remote_port}")

while True:
buf = conn.recv(64)
if not buf:
break

print(f"Received bytes: {buf}")
```
</details>
```bash
# Using socat
socat VSOCK-LISTEN:<port>,fork EXEC:"echo Hello from server!"
```
### Vsock Client

示例:

* [https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py](https://github.com/aws-samples/aws-nitro-enclaves-workshop/blob/main/resources/code/my-first-enclave/secure-local-channel/client.py)

<details>

<summary>简单的Python客户端</summary>
```python
#!/usr/bin/env python3

#From https://medium.com/@F.DL/understanding-vsock-684016cf0eb0

import socket

CID = socket.VMADDR_CID_HOST
PORT = 9999

s = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM)
s.connect((CID, PORT))
s.sendall(b"Hello, world!")
s.close()
```
</details>
```bash
# Using socat
echo "Hello, vsock!" | socat - VSOCK-CONNECT:3:5000
```
### Vsock Proxy

工具 vsock-proxy 允许将 vsock 代理与另一个地址代理，例如：
```bash
vsock-proxy 8001 ip-ranges.amazonaws.com 443 --config your-vsock-proxy.yaml
```
这将把**vsock中的本地端口8001**转发到`ip-ranges.amazonaws.com:443`，文件**`your-vsock-proxy.yaml`**可能包含以下内容，允许访问`ip-ranges.amazonaws.com:443`：
```yaml
allowlist:
- {address: ip-ranges.amazonaws.com, port: 443}
```
可以查看 EC2 主机使用的 vsock 地址（**`<CID>:<Port>`**）（注意 `3:8001`，3 是 CID，8001 是端口）：

{% code overflow="wrap" %}
```bash
sudo ss -l -p -n | grep v_str
v_str LISTEN 0      0                                                                              3:8001                   *:*     users:(("vsock-proxy",pid=9458,fd=3))
```
{% endcode %}

## Nitro Enclave 证明与 KMS

Nitro Enclaves SDK 允许 enclave 从 Nitro **Hypervisor** 请求一个**加密签名的证明文档**，其中包括特定于该 enclave 的**唯一测量值**。这些测量值包括**哈希和平台配置寄存器 (PCRs)**，在证明过程中用于**证明 enclave 的身份**并**与外部服务建立信任**。证明文档通常包含像 PCR0、PCR1 和 PCR2 这样的值，这些值在构建和保存 enclave EIF 时已经遇到过。

从[**文档**](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-3-cryptographic-attestation#a-unique-feature-on-nitro-enclaves)中，这些是 PCR 值：

<table><thead><tr><th width="97">PCR</th><th width="221">哈希的内容</th><th>描述</th></tr></thead><tbody><tr><td>PCR0</td><td>Enclave 镜像文件</td><td>镜像文件内容的连续测量，不包括节数据。</td></tr><tr><td>PCR1</td><td>Linux 内核和引导程序</td><td>内核和引导 ramfs 数据的连续测量。</td></tr><tr><td>PCR2</td><td>应用程序</td><td>用户应用程序的连续、有序测量，不包括引导 ramfs。</td></tr><tr><td>PCR3</td><td>分配给父实例的 IAM 角色</td><td>分配给父实例的 IAM 角色的连续测量。确保只有当父实例具有正确的 IAM 角色时，证明过程才会成功。</td></tr><tr><td>PCR4</td><td>父实例的实例 ID</td><td>父实例 ID 的连续测量。确保只有当父实例具有特定实例 ID 时，证明过程才会成功。</td></tr><tr><td>PCR8</td><td>Enclave 镜像文件签名证书</td><td>指定给 enclave 镜像文件的签名证书的测量。确保只有当 enclave 从由特定证书签名的 enclave 镜像文件启动时，证明过程才会成功。</td></tr></tbody></table>

你可以将**加密证明**集成到你的应用程序中，并利用与**AWS KMS**等服务的预构建集成。AWS KMS 可以**验证 enclave 证明**，并在其密钥策略中提供基于证明的条件键 (`kms:RecipientAttestation:ImageSha384` 和 `kms:RecipientAttestation:PCR`)。这些策略确保 AWS KMS 仅在 enclave 的证明文档有效并满足**指定条件**时允许使用 KMS 密钥进行操作。

{% hint style="success" %}
请注意，调试模式（--debug）下的 Enclaves 生成的证明文档中的 PCR 值全为零 (`000000000000000000000000000000000000000000000000`)。因此，检查这些值的 KMS 策略将会失败。
{% endhint %}

### PCR 绕过

从攻击者的角度来看，注意到某些 PCR 允许修改部分或全部 enclave 镜像并仍然有效（例如，PCR4 只检查父实例的 ID，因此在该 EC2 上运行任何 enclave 镜像都可以满足这个潜在的 PCR 要求）。

因此，攻击者如果攻陷了 EC2 实例，可能能够运行其他 enclave 镜像以绕过这些保护。

关于如何修改/创建新镜像以绕过每个保护（特别是那些不太明显的保护）的研究仍在进行中。

## 参考资料

* [https://medium.com/@F.DL/understanding-vsock-684016cf0eb0](https://medium.com/@F.DL/understanding-vsock-684016cf0eb0)
* AWS 的 Nitro 教程的所有部分：[https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli](https://catalog.us-east-1.prod.workshops.aws/event/dashboard/en-US/workshop/1-my-first-enclave/1-1-nitro-enclaves-cli)

{% hint style="success" %}
学习和实践 AWS Hacking：<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
学习和实践 GCP Hacking：<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或 **关注** 我们的 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* **通过提交 PRs 到** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github 仓库来分享黑客技巧**。

</details>
{% endhint %}
