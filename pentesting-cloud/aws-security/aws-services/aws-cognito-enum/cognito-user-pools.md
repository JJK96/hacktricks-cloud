# Cognito User Pools

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Basic Information

사용자 풀은 Amazon Cognito의 사용자 디렉토리입니다. 사용자 풀을 사용하면 사용자가 Amazon Cognito를 통해 웹 또는 모바일 앱에 **로그인**하거나 **타사** ID 공급자(IdP)를 통해 **연합**할 수 있습니다. 사용자가 직접 로그인하든 타사를 통해 로그인하든, 사용자 풀의 모든 구성원은 SDK를 통해 액세스할 수 있는 디렉토리 프로필을 갖습니다.

사용자 풀은 다음을 제공합니다:

* 가입 및 로그인 서비스.
* 사용자를 로그인시키기 위한 내장형 맞춤형 웹 UI.
* Facebook, Google, Amazon 로그인 및 Apple 로그인, SAML 및 OIDC ID 공급자를 통한 소셜 로그인.
* 사용자 디렉토리 관리 및 사용자 프로필.
* 다중 인증(MFA), 손상된 자격 증명 확인, 계정 탈취 방지, 전화 및 이메일 확인과 같은 보안 기능.
* AWS Lambda 트리거를 통한 맞춤형 워크플로우 및 사용자 마이그레이션.

애플리케이션의 **소스 코드**에는 일반적으로 **사용자 풀 ID**와 **클라이언트 애플리케이션 ID**(때로는 **애플리케이션 비밀**도 포함될 수 있음)가 포함되어 있으며, 이는 사용자가 Cognito 사용자 풀에 **로그인**하는 데 필요합니다.

### Potential attacks

* **Registration**: 기본적으로 사용자는 스스로 등록할 수 있으므로 자신을 위한 사용자를 생성할 수 있습니다.
* **User enumeration**: 등록 기능을 사용하여 이미 존재하는 사용자 이름을 찾을 수 있습니다. 이 정보는 무차별 대입 공격에 유용할 수 있습니다.
* **Login brute-force**: [**Authentication**](cognito-user-pools.md#authentication) 섹션에는 사용자가 **로그인**하는 모든 **방법**이 나와 있으며, 이를 통해 무차별 대입 공격을 시도하여 **유효한 자격 증명**을 찾을 수 있습니다.

### Tools for pentesting

* [Pacu](https://github.com/RhinoSecurityLabs/pacu), AWS 익스플로잇 프레임워크는 이제 계정의 모든 Cognito 자산을 자동으로 열거하고 약한 구성, 액세스 제어에 사용되는 사용자 속성 등을 플래그하는 "cognito\_\_enum" 및 "cognito\_\_attack" 모듈을 포함하며, 사용자 생성(MFA 지원 포함) 및 수정 가능한 사용자 정의 속성, 사용 가능한 ID 풀 자격 증명, id 토큰에서 가정할 수 있는 역할 등을 기반으로 한 권한 상승도 자동화합니다.

모듈 기능에 대한 설명은 [블로그 게시물](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2) 2부를 참조하십시오. 설치 지침은 [Pacu](https://github.com/RhinoSecurityLabs/pacu) 메인 페이지를 참조하십시오.

#### Usage

주어진 ID 풀 및 사용자 풀 클라이언트에 대해 사용자 생성 및 모든 권한 상승 벡터를 시도하는 샘플 cognito\_\_attack 사용법:
```bash
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
현재 AWS 계정에서 볼 수 있는 모든 사용자 풀, 사용자 풀 클라이언트, ID 풀, 사용자 등을 수집하기 위한 cognito\_\_enum 사용 예시:
```bash
Pacu (new:test) > run cognito__enum
```
* [Cognito Scanner](https://github.com/padok-team/cognito-scanner)는 원하지 않는 계정 생성 및 계정 오라클을 포함한 다양한 공격을 구현하는 python의 CLI 도구입니다.

#### Installation (설치)
```bash
$ pip install cognito-scanner
```
#### 사용법
```bash
$ cognito-scanner --help
```
For more information check https://github.com/padok-team/cognito-scanner

## Registration

User Pools는 **기본적으로** **새 사용자 등록**을 허용합니다.
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### 누구나 등록할 수 있는 경우

사용자에 대한 **더 많은 세부 정보를 제공**해야 한다는 오류가 발생할 수 있습니다:
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
```markdown
필요한 세부 정보를 JSON으로 제공할 수 있습니다:
```
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
이 기능을 사용하여 **기존 사용자를 열거할 수 있습니다.** 다음은 해당 이름으로 사용자가 이미 존재할 때의 오류 메시지입니다:
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
{% hint style="info" %}
이전 명령에서 **사용자 지정 속성은 "custom:"으로 시작**하는 것을 주목하십시오.\
또한 등록할 때 **사용자에게 새로운 사용자 지정 속성을 생성할 수 없다는 것**을 알아두십시오. **기본 속성**(필수 사항이 아니더라도)과 **지정된 사용자 지정 속성**에만 값을 부여할 수 있습니다.
{% endhint %}

또는 클라이언트 ID가 존재하는지 테스트하기 위해서입니다. 클라이언트 ID가 존재하지 않을 경우의 오류는 다음과 같습니다:
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### If only admin can register users

관리자만 사용자를 등록할 수 있는 경우, 다음과 같은 오류가 발생하며 사용자를 등록하거나 열거할 수 없습니다:
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### Verifying Registration

Cognito는 **이메일 또는 전화번호를 확인하여 새 사용자를 검증**할 수 있습니다. 따라서 사용자를 생성할 때 일반적으로 최소한 사용자 이름과 비밀번호, 그리고 **이메일 및/또는 전화번호**가 필요합니다. **제어할 수 있는** 하나를 설정하여 새로 생성된 사용자 **계정을** 다음과 같이 **검증**할 수 있는 코드를 받게 됩니다:
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
{% hint style="warning" %}
**같은 이메일**과 전화번호를 사용할 수 있을 것처럼 보이더라도, 생성된 사용자를 확인해야 할 때 Cognito는 동일한 정보를 사용하는 것에 대해 불평하며 **계정을 확인할 수 없게 합니다**.
{% endhint %}

### Privilege Escalation / Updating Attributes

기본적으로 사용자는 다음과 같이 **자신의 속성 값을 수정할 수 있습니다**:
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### Custom attribute privesc

{% hint style="danger" %}
**커스텀 속성**이 사용되고 있는 것을 발견할 수 있습니다 (예: `isAdmin`). 기본적으로 자신의 속성 값을 **변경할 수 있기 때문에** 값을 변경하여 **권한을 상승**시킬 수 있습니다!
{% endhint %}

#### Email/username modification privesc

이를 사용하여 사용자의 **이메일과 전화번호를 수정**할 수 있습니다. 그러나 계정이 검증된 상태로 남아 있더라도, 해당 속성은 **미검증 상태**로 설정됩니다 (다시 검증해야 합니다).

{% hint style="warning" %}
이메일이나 전화번호를 검증하기 전까지는 **이메일이나 전화번호로 로그인할 수 없지만**, **사용자 이름으로는 로그인할 수 있습니다**.\
이메일이 수정되고 검증되지 않았더라도 **ID 토큰**의 **`email`** **필드**에 나타나며, **`email_verified`** 필드는 **false**로 설정됩니다. 그러나 앱이 이를 확인하지 않는다면 **다른 사용자를 가장할 수 있습니다**.

또한, **`name`** 필드에 **이름 속성**을 수정하여 아무 것이나 넣을 수 있습니다. 앱이 **이메일** (또는 다른 속성) 대신 **그** 필드를 **확인**하는 경우, **다른 사용자를 가장할 수 있습니다**.
{% endhint %}

어쨌든, 예를 들어 새로운 이메일로 변경한 경우, 해당 이메일 주소로 받은 코드를 사용하여 **이메일을 확인**할 수 있습니다:
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
**`phone_number`**를 **`email`** 대신 사용하여 **새 전화번호**를 변경/확인하세요.

{% hint style="info" %}
관리자는 **사용자가 선호하는 사용자 이름으로 로그인**하는 옵션을 활성화할 수도 있습니다. 다른 사용자를 가장하기 위해 **이미 사용 중인 사용자 이름 또는 선호하는 사용자 이름**으로 이 값을 변경할 수 없다는 점에 유의하세요.
{% endhint %}

### 비밀번호 복구/변경

사용자 이름(또는 이메일 또는 전화번호가 허용됨)을 알고 있고 해당 코드가 전송될 곳에 접근할 수 있다면 비밀번호를 복구하는 것이 가능합니다:
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
{% hint style="info" %}
서버의 응답은 항상 긍정적일 것입니다. 마치 사용자가 존재하는 것처럼 보입니다. 이 방법을 사용하여 사용자를 열거할 수 없습니다.
{% endhint %}

코드를 사용하여 비밀번호를 변경할 수 있습니다:
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
비밀번호를 변경하려면 **이전 비밀번호를 알아야 합니다**:
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## Authentication

사용자 풀은 **다양한 인증 방법**을 지원합니다. **사용자 이름과 비밀번호**가 있는 경우에도 **다양한 로그인 방법**이 지원됩니다.\
또한, 사용자가 풀에서 인증되면 **3가지 유형의 토큰이 제공**됩니다: **ID 토큰**, **액세스 토큰** 및 **리프레시 토큰**.

* [**ID Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html): **인증된 사용자의 신원**에 대한 클레임을 포함합니다, 예를 들어 `name`, `email`, `phone_number` 등이 있습니다. ID 토큰은 **리소스 서버나 서버 애플리케이션에 사용자를 인증**하는 데 사용할 수 있습니다. 외부 애플리케이션에서 ID 토큰을 사용할 경우, ID 토큰 내부의 클레임을 신뢰하기 전에 **ID 토큰의 서명을 검증**해야 합니다.
* ID 토큰은 **사용자의 속성 값을 포함**하는 토큰입니다, 사용자 정의 속성까지도 포함됩니다.
* [**Access Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html): 인증된 사용자에 대한 클레임, **사용자 그룹 목록 및 범위 목록**을 포함합니다. 액세스 토큰의 목적은 사용자 풀 내에서 **API 작업을 승인**하는 것입니다. 예를 들어, 액세스 토큰을 사용하여 사용자가 사용자 속성을 추가, 변경 또는 삭제할 수 있는 **권한을 부여**할 수 있습니다.
* [**Refresh Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html): 리프레시 토큰을 사용하면 **새로운 ID 토큰 및 액세스 토큰을** 리프레시 토큰이 **유효하지 않을 때까지** 얻을 수 있습니다. **기본적으로**, 리프레시 토큰은 **사용자가 사용자 풀에 로그인한 후 30일 후에 만료**됩니다. 사용자 풀에 대한 애플리케이션을 만들 때, 애플리케이션의 리프레시 토큰 만료 시간을 **60분에서 10년 사이의 값으로 설정**할 수 있습니다.

### ADMIN\_NO\_SRP\_AUTH & ADMIN\_USER\_PASSWORD\_AUTH

이것은 서버 측 인증 흐름입니다:

* 서버 측 앱이 **`AdminInitiateAuth` API 작업**을 호출합니다 (`InitiateAuth` 대신). 이 작업은 **`cognito-idp:AdminInitiateAuth`** 및 **`cognito-idp:AdminRespondToAuthChallenge`** 권한을 포함하는 AWS 자격 증명이 필요합니다. 이 작업은 필요한 인증 매개변수를 반환합니다.
* 서버 측 앱이 **인증 매개변수**를 얻은 후, **`AdminRespondToAuthChallenge` API 작업**을 호출합니다. `AdminRespondToAuthChallenge` API 작업은 AWS 자격 증명을 제공할 때만 성공합니다.

이 **방법은 기본적으로 활성화되지 않습니다**.

**로그인**하려면 다음이 **필요**합니다:

* 사용자 풀 ID
* 클라이언트 ID
* 사용자 이름
* 비밀번호
* 클라이언트 비밀 (앱이 비밀을 사용하도록 구성된 경우에만)

{% hint style="info" %}
이 방법으로 **로그인할 수 있으려면** 애플리케이션이 `ALLOW_ADMIN_USER_PASSWORD_AUTH`로 로그인할 수 있어야 합니다.\
또한, 이 작업을 수행하려면 **`cognito-idp:AdminInitiateAuth`** 및 **`cognito-idp:AdminRespondToAuthChallenge`** 권한이 있는 자격 증명이 필요합니다.
{% endhint %}
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>로그인 코드</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_PASSWORD\_AUTH

이 방법은 또 다른 간단하고 **전통적인 사용자 & 비밀번호 인증** 흐름입니다. **전통적인** 인증 방법을 **Cognito로 마이그레이션**하고, 그 후에 이를 **비활성화**하고 **ALLOW\_USER\_SRP\_AUTH** 방법을 사용하는 것이 **권장**됩니다 (이 방법은 비밀번호를 네트워크를 통해 전송하지 않기 때문입니다).\
이 **방법은 기본적으로 활성화되어 있지 않습니다**.

코드 내에서 **이전 인증 방법**과의 **주요 차이점**은 **사용자 풀 ID를 알 필요가 없고**, Cognito 사용자 풀에서 **추가 권한이 필요하지 않다는 것**입니다.

**로그인**하려면 다음을 **알아야 합니다**:

* client id
* username
* password
* client secret (앱이 비밀을 사용하도록 구성된 경우에만)

{% hint style="info" %}
이 방법으로 **로그인할 수 있으려면** 해당 애플리케이션이 ALLOW\_USER\_PASSWORD\_AUTH로 로그인할 수 있도록 허용해야 합니다.
{% endhint %}
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>로그인하는 Python 코드</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_SRP\_AUTH

이 시나리오는 이전 것과 유사하지만 **비밀번호를 네트워크를 통해 보내는 대신** **챌린지 인증이 수행**됩니다 (따라서 비밀번호가 암호화되어 네트워크를 통해 이동하지 않습니다).\
이 **방법은 기본적으로 활성화**되어 있습니다.

**로그인**하려면 다음을 **알아야** 합니다:

* user pool id
* client id
* username
* password
* client secret (앱이 secret을 사용하도록 구성된 경우에만)

<details>

<summary>로그인 코드</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

이 **방법은 항상 유효**합니다 (비활성화할 수 없습니다) 하지만 유효한 refresh token이 필요합니다.
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>코드 새로 고침</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM\_AUTH

이 경우 **인증**은 **람다 함수 실행**을 통해 수행됩니다.

## 추가 보안

### 고급 보안

기본적으로 비활성화되어 있지만, 활성화하면 Cognito는 **계정 탈취를 발견**할 수 있습니다. 확률을 최소화하려면 **같은 도시 내의 네트워크에서 동일한 사용자 에이전트**(가능하면 IP도 사용)로 로그인해야 합니다.

### **MFA 장치 기억**

사용자가 동일한 장치에서 로그인하면 MFA가 우회될 수 있으므로, 동일한 브라우저와 동일한 메타데이터(IP?)를 사용하여 로그인하여 MFA 보호를 우회해 보십시오.

## 사용자 풀 그룹 IAM 역할

**IAM 역할**과 관련된 **사용자 풀** 그룹에 **사용자를 추가**할 수 있습니다.\
또한, **사용자**는 **다른 IAM 역할**이 첨부된 **1개 이상의 그룹**에 할당될 수 있습니다.

그룹이 IAM 역할이 첨부된 그룹 내에 있더라도, 해당 그룹의 IAM 자격 증명에 접근하려면 **사용자 풀이 신원 풀에 의해 신뢰받아야** 합니다(그리고 해당 신원 풀의 세부 정보를 알아야 합니다).

사용자가 사용자 풀에서 인증될 때(`aws cognito-idp initiate-auth...`) **IdToken에 명시된 IAM 역할**을 얻기 위한 또 다른 요건은 **Identity Provider Authentication provider**가 **토큰에서 역할을 선택해야 한다고 명시**해야 한다는 것입니다.

<figure><img src="../../../../.gitbook/assets/image (250).png" alt=""><figcaption></figcaption></figure>

사용자가 접근할 수 있는 **역할**은 **`IdToken` 내에** 있으며, 사용자는 **`aws cognito-identity get-credentials-for-identity`의 `--custom-role-arn`**을 사용하여 **자격 증명을 원하는 역할을 선택**할 수 있습니다.\
그러나 **기본 옵션**이 **구성된**(`기본 역할 사용`) 상태에서 IdToken의 역할에 접근하려고 하면 **오류**가 발생합니다(따라서 이전 구성이 필요합니다):

{% code overflow="wrap" %}
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
{% endcode %}

{% hint style="warning" %}
**User Pool Group**에 할당된 역할은 **User Pool을 신뢰하는 Identity Provider**가 **액세스할 수 있어야 합니다** (IAM 역할 **세션 자격 증명은 여기서 얻어질 것입니다**).
{% endhint %}
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* [**구독 플랜**](https://github.com/sponsors/carlospolop)을 확인하세요!
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**telegram 그룹**](https://t.me/peass)에 가입하거나 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 팔로우하세요.
* PR을 제출하여 [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 해킹 트릭을 공유하세요.

</details>
{% endhint %}
