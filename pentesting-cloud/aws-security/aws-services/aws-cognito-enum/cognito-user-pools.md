# Cognito User Pools

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## 基本情報

ユーザープールはAmazon Cognitoのユーザーディレクトリです。ユーザープールを使用すると、ユーザーはAmazon Cognitoを通じて**ウェブまたはモバイルアプリにサインイン**したり、**サードパーティの**アイデンティティプロバイダー（IdP）を通じて**フェデレーション**することができます。ユーザーが直接サインインするかサードパーティを通じてサインインするかに関わらず、ユーザープールのすべてのメンバーはSDKを通じてアクセスできるディレクトリプロファイルを持っています。

ユーザープールは以下を提供します：

* サインアップおよびサインインサービス。
* ユーザーをサインインさせるための組み込みのカスタマイズ可能なウェブUI。
* Facebook、Google、Amazonでのログイン、Appleでのサインイン、SAMLおよびOIDCアイデンティティプロバイダーを通じたソーシャルサインイン。
* ユーザーディレクトリ管理およびユーザープロファイル。
* 多要素認証（MFA）、漏洩した資格情報のチェック、アカウント乗っ取り保護、電話およびメールの検証などのセキュリティ機能。
* AWS Lambdaトリガーを通じたカスタマイズされたワークフローおよびユーザー移行。

アプリケーションの**ソースコード**には通常、**ユーザープールID**および**クライアントアプリケーションID**（および時には**アプリケーションシークレット**？）が含まれており、これらは**ユーザーがCognito User Poolにログインする**ために必要です。

### 潜在的な攻撃

* **登録**：デフォルトではユーザーは自分で登録できるため、自分自身のユーザーを作成することができます。
* **ユーザー列挙**：登録機能を使用して既存のユーザー名を見つけることができます。この情報はブルートフォース攻撃に役立ちます。
* **ログインブルートフォース**：[**認証**](cognito-user-pools.md#authentication)セクションには、ユーザーが**ログインする**ためのすべての**方法**が記載されており、これらをブルートフォースして**有効な資格情報を見つける**ことができます。

### ペンテスト用ツール

* [Pacu](https://github.com/RhinoSecurityLabs/pacu)、AWSエクスプロイトフレームワークには、アカウント内のすべてのCognito資産の列挙を自動化し、弱い構成、アクセス制御に使用されるユーザー属性などをフラグする「cognito\_\_enum」および「cognito\_\_attack」モジュールが含まれています。また、ユーザー作成（MFAサポートを含む）および変更可能なカスタム属性、使用可能なアイデンティティプール資格情報、idトークン内の引き受け可能なロールに基づく特権昇格を自動化します。

モジュールの機能の説明については、[ブログ記事](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2)のパート2を参照してください。インストール手順については、メインの[Pacu](https://github.com/RhinoSecurityLabs/pacu)ページを参照してください。

#### 使用方法

指定されたアイデンティティプールおよびユーザープールクライアントに対してユーザー作成およびすべての特権昇格ベクトルを試みるためのサンプルcognito\_\_attack使用法：
```bash
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
現在のAWSアカウントで表示されるすべてのユーザープール、ユーザープールクライアント、アイデンティティプール、ユーザーなどを収集するためのcognito\_\_enumの使用例:
```bash
Pacu (new:test) > run cognito__enum
```
* [Cognito Scanner](https://github.com/padok-team/cognito-scanner) は、不要なアカウント作成やアカウントオラクルを含むCognitoへのさまざまな攻撃を実装するpythonのCLIツールです。

#### Installation（インストール）
```bash
$ pip install cognito-scanner
```
#### Usage

```html
<!DOCTYPE html>
<html>
<head>
    <title>aws-cognito-enum</title>
</head>
<body>
    <h1>aws-cognito-enum</h1>
    <p>aws-cognito-enumは、AWS Cognito User Poolsのユーザー名を列挙するためのツールです。</p>
</body>
</html>
```

```bash
$ aws-cognito-enum -u <username> -p <password> -r <region> -c <client_id>
```

#### Example

```bash
$ aws-cognito-enum -u exampleuser -p examplepassword -r us-west-2 -c 1h57kf5cpq17m0eml12EXAMPLE
```

このコマンドは、指定されたユーザー名、パスワード、リージョン、およびクライアントIDを使用してAWS Cognito User Poolsのユーザー名を列挙します。
```bash
$ cognito-scanner --help
```
詳細については、https://github.com/padok-team/cognito-scanner を確認してください。

## Registration

User Poolsは**デフォルト**で**新しいユーザーを登録**することを許可します。
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### 誰でも登録できる場合

ユーザーに関する**詳細情報を提供**する必要があることを示すエラーが表示されることがあります:
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
```markdown
必要な詳細は、次のようなJSONで提供できます：
```
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
この機能を使用して**既存のユーザーを列挙**することもできます。これは、その名前のユーザーが既に存在する場合のエラーメッセージです:
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
{% hint style="info" %}
前のコマンドで、**カスタム属性が "custom:" で始まる**ことに注意してください。\
また、登録時に**新しいカスタム属性をユーザーに作成することはできない**ことも知っておいてください。**デフォルト属性**（必須でなくても）と**指定されたカスタム属性**にのみ値を与えることができます。
{% endhint %}

または、クライアントIDが存在するかどうかをテストするだけです。クライアントIDが存在しない場合のエラーは次のとおりです:
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### If only admin can register users

管理者のみがユーザーを登録できる場合、次のエラーが発生し、ユーザーを登録または列挙することができません:
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### Verifying Registration

Cognitoは**メールまたは電話番号を確認することで新しいユーザーを検証**します。そのため、ユーザーを作成する際には通常、少なくともユーザー名とパスワード、そして**メールアドレスおよび/または電話番号**が必要です。**あなたが管理する**ものを設定するだけで、**新しく作成したユーザーアカウント**を**確認する**ためのコードを受け取ることができます。次のようにします:
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
{% hint style="warning" %}
**同じメールアドレス**や電話番号を使用できるように見えても、作成したユーザーを確認する必要がある場合、Cognitoは同じ情報を使用することについて不満を言い、**アカウントを確認させません**。
{% endhint %}

### 権限昇格 / 属性の更新

デフォルトでは、ユーザーは次のようにして**自分の属性の値を変更**できます:
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### Custom attribute privesc

{% hint style="danger" %}
**カスタム属性**（例えば `isAdmin`）が使用されている場合があります。デフォルトでは**自分の属性の値を変更**できるため、自分で値を変更することで**権限を昇格**できるかもしれません！
{% endhint %}

#### Email/username modification privesc

これを使用してユーザーの**メールアドレスや電話番号を変更**できますが、その後、アカウントが検証済みのままであっても、それらの属性は**未検証のステータス**に設定されます（再度検証する必要があります）。

{% hint style="warning" %}
**メールアドレスや電話番号でログイン**することは**検証するまでできません**が、**ユーザー名でログイン**することは可能です。\
メールアドレスが変更されて未検証のままでも、IDトークン内の**`email`** **フィールド**に表示され、**`email_verified`** フィールドは**false**になりますが、アプリがそれを**チェックしていない場合、他のユーザーになりすます**ことができるかもしれません。

さらに、**`name`** フィールドに何でも入れることができ、**name属性**を変更するだけで済みます。アプリが何らかの理由で**`email`**（または他の属性）ではなく**そのフィールドをチェック**している場合、他のユーザーになりすますことができるかもしれません。
{% endhint %}

いずれにせよ、例えば新しいメールアドレスに変更した場合、そのメールアドレスに届いたコードで**メールを確認**できます：
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
**`phone_number`** を **`email`** の代わりに使用して、**新しい電話番号** を変更/確認します。

{% hint style="info" %}
管理者は、**ユーザーが好むユーザー名でログインする**オプションを有効にすることもできます。この値を**既に使用されている任意のユーザー名または preferred\_username** に変更して、別のユーザーになりすますことはできません。
{% endhint %}

### パスワードの回復/変更

ユーザー名（またはメールや電話番号が受け入れられます）を知っているだけで、そこにコードが送信されるため、パスワードを回復することが可能です:
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
{% hint style="info" %}
サーバーの応答は常に肯定的で、ユーザー名が存在するかのようになります。この方法を使用してユーザーを列挙することはできません。
{% endhint %}

コードを使用してパスワードを変更できます:
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
パスワードを変更するには、**以前のパスワードを知っている必要があります**:
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## 認証

ユーザープールは**異なる認証方法**をサポートしています。**ユーザー名とパスワード**がある場合、ログインをサポートする**異なる方法**もあります。\
さらに、ユーザーがプールで認証されると、**3種類のトークン**が提供されます：**IDトークン**、**アクセストークン**、**リフレッシュトークン**です。

* [**IDトークン**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html): これは、認証されたユーザーの**アイデンティティに関するクレーム**（`name`、`email`、`phone_number`など）を含みます。IDトークンは、**リソースサーバーやサーバーアプリケーションにユーザーを認証するため**にも使用できます。外部アプリケーションで使用する場合、IDトークン内のクレームを信頼する前に、IDトークンの**署名を検証**する必要があります。
* IDトークンは、**ユーザーの属性値**（カスタム属性も含む）を含むトークンです。
* [**アクセストークン**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html): これは、認証されたユーザーに関するクレーム、**ユーザーのグループのリスト、およびスコープのリスト**を含みます。アクセストークンの目的は、ユーザープール内のユーザーのコンテキストで**API操作を認可する**ことです。例えば、アクセストークンを使用して、ユーザーにユーザー属性の追加、変更、削除の**アクセスを許可**することができます。
* [**リフレッシュトークン**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html): リフレッシュトークンを使用すると、**新しいIDトークンとアクセストークンを取得**できます。**リフレッシュトークンが無効になるまで**です。**デフォルトでは**、リフレッシュトークンはユーザーがユーザープールにサインインしてから**30日後に期限切れ**になります。ユーザープール用のアプリケーションを作成する際に、アプリケーションのリフレッシュトークンの有効期限を**60分から10年の間の任意の値に設定**できます。

### ADMIN\_NO\_SRP\_AUTH & ADMIN\_USER\_PASSWORD\_AUTH

これはサーバーサイドの認証フローです：

* サーバーサイドアプリは、**`AdminInitiateAuth` API操作**（`InitiateAuth`の代わり）を呼び出します。この操作には、**`cognito-idp:AdminInitiateAuth`**および**`cognito-idp:AdminRespondToAuthChallenge`**を含む権限を持つAWSクレデンシャルが必要です。この操作は必要な認証パラメータを返します。
* サーバーサイドアプリが**認証パラメータ**を取得した後、**`AdminRespondToAuthChallenge` API操作**を呼び出します。`AdminRespondToAuthChallenge` API操作は、AWSクレデンシャルを提供した場合にのみ成功します。

この**方法はデフォルトでは有効になっていません**。

**ログイン**するには、以下が**必要**です：

* ユーザープールID
* クライアントID
* ユーザー名
* パスワード
* クライアントシークレット（アプリがシークレットを使用するように設定されている場合のみ）

{% hint style="info" %}
この方法で**ログインできるようにするには**、アプリケーションが`ALLOW_ADMIN_USER_PASSWORD_AUTH`でのログインを許可する必要があります。\
さらに、この操作を実行するには、**`cognito-idp:AdminInitiateAuth`**および**`cognito-idp:AdminRespondToAuthChallenge`**の権限を持つクレデンシャルが必要です。
{% endhint %}
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>ログインするためのコード</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_PASSWORD\_AUTH

この方法は、もう一つのシンプルで**伝統的なユーザー＆パスワード認証**フローです。**伝統的な**認証方法を**Cognitoに移行**し、その後**無効化**して**ALLOW\_USER\_SRP\_AUTH**メソッドを使用することが**推奨されます**（この方法ではパスワードがネットワーク上で送信されることはありません）。\
この**方法はデフォルトでは有効化されていません**。

**前の認証方法**との主な**違い**は、**ユーザープールIDを知る必要がない**ことと、Cognito User Poolで**追加の権限が必要ない**ことです。

**ログイン**するために**必要なもの**は以下です：

* client id
* username
* password
* client secret（アプリがシークレットを使用するように設定されている場合のみ）

{% hint style="info" %}
この方法で**ログインできるようにするためには**、アプリケーションがALLOW\_USER\_PASSWORD\_AUTHでのログインを許可する必要があります。
{% endhint %}
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>ログイン用のPythonコード</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_SRP\_AUTH

このシナリオは前のものと似ていますが、**パスワードをネットワーク経由で送信する代わりに**、**チャレンジ認証が行われます**（したがって、パスワードが暗号化されていてもネットを通じて移動しません）。\
この**方法はデフォルトで有効**です。

**ログインする**には以下が**必要**です：

* user pool id
* client id
* username
* password
* client secret（アプリがシークレットを使用するように設定されている場合のみ）

<details>

<summary>ログインのためのコード</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

この**メソッドは常に有効**（無効にすることはできません）ですが、有効なリフレッシュトークンが必要です。
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>コードをリフレッシュ</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM\_AUTH

この場合、**認証**は**Lambda関数の実行**を通じて行われます。

## 追加のセキュリティ

### 高度なセキュリティ

デフォルトでは無効ですが、有効にするとCognitoは**アカウント乗っ取りを検出**できる可能性があります。確率を最小限にするためには、**同じ都市内のネットワークから、同じユーザーエージェント**（可能であればIPも）を使用してログインする必要があります。

### **MFA デバイスの記憶**

ユーザーが同じデバイスからログインすると、MFAがバイパスされる可能性があります。そのため、同じブラウザと同じメタデータ（IP？）を使用してログインを試み、MFA保護をバイパスすることを試みてください。

## ユーザープールグループのIAMロール

**IAMロール**に関連する**ユーザープール**グループに**ユーザーを追加**することが可能です。\
さらに、**ユーザー**は**異なるIAMロール**が付与された**複数のグループ**に割り当てられることができます。

グループがIAMロールを持つグループ内にあっても、そのグループのIAM資格情報にアクセスするためには、**ユーザープールがアイデンティティプールによって信頼されている**（およびそのアイデンティティプールの詳細を知っている）必要があります。

ユーザーがユーザープールで認証される際に（`aws cognito-idp initiate-auth...`）、**IdTokenに示されたIAMロール**を取得するためのもう一つの要件は、**アイデンティティプロバイダー認証プロバイダー**が**トークンからロールを選択する必要がある**ことを示す必要があることです。

<figure><img src="../../../../.gitbook/assets/image (250).png" alt=""><figcaption></figcaption></figure>

ユーザーがアクセスできる**ロール**は**`IdToken`内**にあり、ユーザーは**`aws cognito-identity get-credentials-for-identity`の**`--custom-role-arn`**を使用して**どのロールの資格情報を取得したいかを**選択できます。\
しかし、**デフォルトオプション**が**設定**されている場合（`use default role`）、IdTokenからロールにアクセスしようとすると**エラー**が発生します（そのため、前述の設定が必要です）：

{% code overflow="wrap" %}
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
{% endcode %}

{% hint style="warning" %}
**User Pool Group** に割り当てられたロールは、**User Pool を信頼する Identity Provider** によって**アクセス可能である必要があります**（IAM ロールの**セッション認証情報がそこから取得されるため**）。
{% endhint %}
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
{% hint style="success" %}
AWSハッキングを学び、練習する:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCPハッキングを学び、練習する: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksをサポートする</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェック！
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)をフォローする。
* PRを提出して[**HackTricks**](https://github.com/carlospolop/hacktricks)および[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリでハッキングトリックを共有する。

</details>
{% endhint %}
