# Cognito User Pools

{% hint style="success" %}
Apprenez et pratiquez le Hacking AWS :<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Apprenez et pratiquez le Hacking GCP : <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop)!
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts github.

</details>
{% endhint %}

## Informations de base

Un user pool est un annuaire d'utilisateurs dans Amazon Cognito. Avec un user pool, vos utilisateurs peuvent **se connecter √† votre application web ou mobile** via Amazon Cognito, **ou se f√©d√©rer** via un fournisseur d'identit√© **tiers** (IdP). Que vos utilisateurs se connectent directement ou via un tiers, tous les membres du user pool ont un profil d'annuaire auquel vous pouvez acc√©der via un SDK.

Les user pools fournissent :

* Des services d'inscription et de connexion.
* Une interface web int√©gr√©e et personnalisable pour connecter les utilisateurs.
* Connexion sociale avec Facebook, Google, Login with Amazon, et Sign in with Apple, et via des fournisseurs d'identit√© SAML et OIDC depuis votre user pool.
* Gestion de l'annuaire des utilisateurs et des profils d'utilisateurs.
* Fonctionnalit√©s de s√©curit√© telles que l'authentification multi-facteurs (MFA), les v√©rifications des informations d'identification compromises, la protection contre la prise de contr√¥le de compte, et la v√©rification par t√©l√©phone et email.
* Workflows personnalis√©s et migration des utilisateurs via les d√©clencheurs AWS Lambda.

Le **code source** des applications contiendra g√©n√©ralement √©galement l'**ID du user pool** et l'**ID de l'application client**, (et parfois le **secret de l'application**?) qui sont n√©cessaires pour qu'un **utilisateur se connecte** √† un Cognito User Pool.

### Attaques potentielles

* **Inscription** : Par d√©faut, un utilisateur peut s'inscrire lui-m√™me, il pourrait donc cr√©er un utilisateur pour lui-m√™me.
* **√ânum√©ration des utilisateurs** : La fonctionnalit√© d'inscription peut √™tre utilis√©e pour trouver des noms d'utilisateur qui existent d√©j√†. Cette information peut √™tre utile pour l'attaque par force brute.
* **Force brute de connexion** : Dans la section [**Authentification**](cognito-user-pools.md#authentication), vous avez toutes les **m√©thodes** qu'un utilisateur doit utiliser pour **se connecter**, vous pourriez essayer de les forcer pour **trouver des informations d'identification valides**.

### Outils pour le pentesting

* [Pacu](https://github.com/RhinoSecurityLabs/pacu), le framework d'exploitation AWS, inclut d√©sormais les modules "cognito\_\_enum" et "cognito\_\_attack" qui automatisent l'√©num√©ration de tous les actifs Cognito dans un compte et signalent les configurations faibles, les attributs d'utilisateur utilis√©s pour le contr√¥le d'acc√®s, etc., et automatisent √©galement la cr√©ation d'utilisateurs (y compris le support MFA) et l'escalade de privil√®ges bas√©e sur des attributs personnalisables, des informations d'identit√© utilisables, des r√¥les assumables dans les jetons id, etc.

Pour une description des fonctions des modules, voir la partie 2 du [post de blog](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2). Pour les instructions d'installation, voir la page principale de [Pacu](https://github.com/RhinoSecurityLabs/pacu).

#### Utilisation

Exemple d'utilisation de cognito\_\_attack pour tenter la cr√©ation d'utilisateur et tous les vecteurs privesc contre un identity pool et un client user pool donn√© :
```bash
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
Exemple d'utilisation de cognito\_\_enum pour rassembler tous les pools d'utilisateurs, les clients de pools d'utilisateurs, les pools d'identit√©s, les utilisateurs, etc. visibles dans le compte AWS actuel :
```bash
Pacu (new:test) > run cognito__enum
```
* [Cognito Scanner](https://github.com/padok-team/cognito-scanner) est un outil CLI en python qui impl√©mente diff√©rentes attaques sur Cognito, y compris la cr√©ation de compte non d√©sir√©e et l'oracle de compte.

#### Installation
```bash
$ pip install cognito-scanner
```
#### Utilisation
```bash
$ cognito-scanner --help
```
Pour plus d'informations, consultez https://github.com/padok-team/cognito-scanner

## Registration

User Pools permet par **d√©faut** de **s'enregistrer de nouveaux utilisateurs**.
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### Si n'importe qui peut s'inscrire

Vous pourriez trouver une erreur vous indiquant que vous devez **fournir plus de d√©tails** sur l'utilisateur :
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
Vous pouvez fournir les d√©tails n√©cessaires avec un JSON tel que :
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
Vous pouvez √©galement utiliser cette fonctionnalit√© pour **√©num√©rer les utilisateurs existants.** Voici le message d'erreur lorsqu'un utilisateur existe d√©j√† avec ce nom :
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
{% hint style="info" %}
Notez dans la commande pr√©c√©dente comment les **attributs personnalis√©s commencent par "custom:"**.\
Sachez √©galement que lors de l'enregistrement, vous **ne pouvez pas cr√©er de nouveaux attributs personnalis√©s pour l'utilisateur**. Vous pouvez seulement attribuer une valeur aux **attributs par d√©faut** (m√™me s'ils ne sont pas requis) et aux **attributs personnalis√©s sp√©cifi√©s**.
{% endhint %}

Ou simplement pour tester si un client id existe. Voici l'erreur si le client-id n'existe pas :
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### Si seul l'administrateur peut enregistrer des utilisateurs

Vous trouverez cette erreur et vous ne pourrez pas enregistrer ou √©num√©rer les utilisateurs :
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### V√©rification de l'inscription

Cognito permet de **v√©rifier un nouvel utilisateur en v√©rifiant son email ou num√©ro de t√©l√©phone**. Par cons√©quent, lors de la cr√©ation d'un utilisateur, il vous sera g√©n√©ralement demand√© au moins le nom d'utilisateur et le mot de passe ainsi que **l'email et/ou le num√©ro de t√©l√©phone**. Il suffit d'en d√©finir un **que vous contr√¥lez** afin de recevoir le code pour **v√©rifier votre** compte utilisateur nouvellement cr√©√© comme ceci :
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
{% hint style="warning" %}
M√™me si **on dirait que vous pouvez utiliser le m√™me email** et num√©ro de t√©l√©phone, lorsque vous devez v√©rifier l'utilisateur cr√©√©, Cognito se plaindra de l'utilisation des m√™mes informations et **ne vous laissera pas v√©rifier le compte**.
{% endhint %}

### Escalade de privil√®ges / Mise √† jour des attributs

Par d√©faut, un utilisateur peut **modifier la valeur de ses attributs** avec quelque chose comme :
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### Privesc d'attribut personnalis√©

{% hint style="danger" %}
Vous pourriez trouver des **attributs personnalis√©s** utilis√©s (comme `isAdmin`), car par d√©faut vous pouvez **changer les valeurs de vos propres attributs** et vous pourriez √™tre capable de **faire une escalade de privil√®ges** en changeant la valeur vous-m√™me !
{% endhint %}

#### Privesc de modification d'email/nom d'utilisateur

Vous pouvez utiliser cela pour **modifier l'email et le num√©ro de t√©l√©phone** d'un utilisateur, mais ensuite, m√™me si le compte reste v√©rifi√©, ces attributs sont **d√©finis en statut non v√©rifi√©** (vous devez les v√©rifier √† nouveau).

{% hint style="warning" %}
Vous **ne pourrez pas vous connecter avec l'email ou le num√©ro de t√©l√©phone** jusqu'√† ce que vous les v√©rifiiez, mais vous pourrez **vous connecter avec le nom d'utilisateur**.\
Notez que m√™me si l'email a √©t√© modifi√© et non v√©rifi√©, il appara√Ætra dans le jeton ID √† l'int√©rieur du **champ** **`email`** et le champ **`email_verified`** sera **faux**, mais si l'application **ne v√©rifie pas cela, vous pourriez usurper l'identit√© d'autres utilisateurs**.

De plus, notez que vous pouvez mettre n'importe quoi √† l'int√©rieur du champ **`name`** en modifiant simplement l'**attribut name**. Si une application **v√©rifie** **ce** champ pour une raison quelconque **au lieu de l'`email`** (ou tout autre attribut), vous pourriez √™tre capable d'**usurper l'identit√© d'autres utilisateurs**.
{% endhint %}

Quoi qu'il en soit, si pour une raison quelconque vous avez chang√© votre email par exemple pour un nouveau que vous pouvez acc√©der, vous pouvez **confirmer l'email avec le code que vous avez re√ßu √† cette adresse email** :
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
Utilisez **`phone_number`** au lieu de **`email`** pour changer/v√©rifier un **nouveau num√©ro de t√©l√©phone**.

{% hint style="info" %}
L'administrateur pourrait √©galement activer l'option pour **se connecter avec un nom d'utilisateur pr√©f√©r√© par l'utilisateur**. Notez que vous ne pourrez pas changer cette valeur pour **n'importe quel nom d'utilisateur ou preferred\_username d√©j√† utilis√©** pour usurper l'identit√© d'un autre utilisateur.
{% endhint %}

### R√©cup√©rer/Changer le Mot de Passe

Il est possible de r√©cup√©rer un mot de passe en **connaissant simplement le nom d'utilisateur** (ou l'email ou le t√©l√©phone est accept√©) et en y ayant acc√®s car un code y sera envoy√© :
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
{% hint style="info" %}
La r√©ponse du serveur sera toujours positive, comme si le nom d'utilisateur existait. Vous ne pouvez pas utiliser cette m√©thode pour √©num√©rer les utilisateurs.
{% endhint %}

Avec le code, vous pouvez changer le mot de passe avec :
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
Pour changer le mot de passe, vous devez **conna√Ætre le mot de passe pr√©c√©dent** :
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## Authentification

Un pool d'utilisateurs prend en charge **diff√©rentes fa√ßons de s'authentifier**. Si vous avez un **nom d'utilisateur et un mot de passe**, il existe √©galement **diff√©rentes m√©thodes** prises en charge pour se connecter.\
De plus, lorsqu'un utilisateur est authentifi√© dans le Pool, **3 types de jetons sont donn√©s** : Le **Jeton d'ID**, le **Jeton d'Acc√®s** et le **Jeton de Rafra√Æchissement**.

* [**Jeton d'ID**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html) : Il contient des revendications sur l'**identit√© de l'utilisateur authentifi√©**, telles que `name`, `email`, et `phone_number`. Le jeton d'ID peut √©galement √™tre utilis√© pour **authentifier les utilisateurs √† vos serveurs de ressources ou applications serveur**. Vous devez **v√©rifier** la **signature** du jeton d'ID avant de pouvoir faire confiance √† toute revendication √† l'int√©rieur du jeton d'ID si vous l'utilisez dans des applications externes.
* Le Jeton d'ID est le jeton qui **contient les valeurs des attributs de l'utilisateur**, m√™me les personnalis√©s.
* [**Jeton d'Acc√®s**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html) : Il contient des revendications sur l'utilisateur authentifi√©, une liste des **groupes de l'utilisateur et une liste de port√©es**. Le but du jeton d'acc√®s est d'**autoriser les op√©rations API** dans le contexte de l'utilisateur dans le pool d'utilisateurs. Par exemple, vous pouvez utiliser le jeton d'acc√®s pour **accorder √† votre utilisateur l'acc√®s** √† l'ajout, la modification ou la suppression des attributs de l'utilisateur.
* [**Jeton de Rafra√Æchissement**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html) : Avec les jetons de rafra√Æchissement, vous pouvez **obtenir de nouveaux Jetons d'ID et Jetons d'Acc√®s** pour l'utilisateur jusqu'√† ce que le **jeton de rafra√Æchissement soit invalide**. Par **d√©faut**, le jeton de rafra√Æchissement **expire 30 jours apr√®s** que votre utilisateur d'application se soit connect√© √† votre pool d'utilisateurs. Lorsque vous cr√©ez une application pour votre pool d'utilisateurs, vous pouvez d√©finir l'expiration du jeton de rafra√Æchissement de l'application √† **n'importe quelle valeur entre 60 minutes et 10 ans**.

### ADMIN\_NO\_SRP\_AUTH & ADMIN\_USER\_PASSWORD\_AUTH

Ceci est le flux d'authentification c√¥t√© serveur :

* L'application c√¥t√© serveur appelle l'op√©ration API **`AdminInitiateAuth`** (au lieu de `InitiateAuth`). Cette op√©ration n√©cessite des identifiants AWS avec des permissions incluant **`cognito-idp:AdminInitiateAuth`** et **`cognito-idp:AdminRespondToAuthChallenge`**. L'op√©ration renvoie les param√®tres d'authentification requis.
* Apr√®s que l'application c√¥t√© serveur a les **param√®tres d'authentification**, elle appelle l'op√©ration API **`AdminRespondToAuthChallenge`**. L'op√©ration API `AdminRespondToAuthChallenge` ne r√©ussit que lorsque vous fournissez des identifiants AWS.

Cette **m√©thode n'est PAS activ√©e** par d√©faut.

Pour **se connecter**, vous **devez** conna√Ætre :

* id du pool d'utilisateurs
* id du client
* nom d'utilisateur
* mot de passe
* secret du client (seulement si l'application est configur√©e pour utiliser un secret)

{% hint style="info" %}
Pour **pouvoir se connecter avec cette m√©thode**, cette application doit permettre de se connecter avec `ALLOW_ADMIN_USER_PASSWORD_AUTH`.\
De plus, pour effectuer cette action, vous avez besoin d'identifiants avec les permissions **`cognito-idp:AdminInitiateAuth`** et **`cognito-idp:AdminRespondToAuthChallenge`**
{% endhint %}
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>Code pour se connecter</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_PASSWORD\_AUTH

Cette m√©thode est une autre m√©thode simple et **traditionnelle d'authentification par utilisateur et mot de passe**. Il est recommand√© de **migrer une m√©thode** d'authentification traditionnelle **vers Cognito** et de **d√©sactiver** ensuite cette m√©thode pour **utiliser** la m√©thode **ALLOW\_USER\_SRP\_AUTH** √† la place (car celle-ci n'envoie jamais le mot de passe sur le r√©seau).\
Cette **m√©thode n'est PAS activ√©e** par d√©faut.

La principale **diff√©rence** avec la **m√©thode d'authentification pr√©c√©dente** dans le code est que vous **n'avez pas besoin de conna√Ætre l'ID du user pool** et que vous **n'avez pas besoin de permissions suppl√©mentaires** dans le Cognito User Pool.

Pour **se connecter**, vous **devez** conna√Ætre :

* client id
* username
* password
* client secret (seulement si l'application est configur√©e pour utiliser un secret)

{% hint style="info" %}
Pour **pouvoir se connecter avec cette m√©thode**, l'application doit permettre de se connecter avec ALLOW\_USER\_PASSWORD\_AUTH.
{% endhint %}
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>Code Python pour se connecter</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_SRP\_AUTH

Ce sc√©nario est similaire au pr√©c√©dent mais **au lieu d'envoyer le mot de passe** √† travers le r√©seau pour se connecter, une **authentification par d√©fi est effectu√©e** (donc aucun mot de passe ne navigue m√™me chiffr√© √† travers le r√©seau).\
Cette **m√©thode est activ√©e** par d√©faut.

Pour **se connecter**, vous **devez** conna√Ætre :

* user pool id
* client id
* username
* password
* client secret (seulement si l'application est configur√©e pour utiliser un secret)

<details>

<summary>Code pour se connecter</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

Cette **m√©thode sera toujours valide** (elle ne peut pas √™tre d√©sactiv√©e) mais vous devez avoir un jeton de rafra√Æchissement valide.
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>Code pour actualiser</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM\_AUTH

Dans ce cas, l'**authentification** va √™tre effectu√©e par l'**ex√©cution d'une fonction lambda**.

## S√©curit√© Suppl√©mentaire

### S√©curit√© Avanc√©e

Par d√©faut, elle est d√©sactiv√©e, mais si elle est activ√©e, Cognito pourrait √™tre capable de **d√©tecter des prises de contr√¥le de compte**. Pour minimiser la probabilit√©, vous devriez vous connecter depuis un **r√©seau dans la m√™me ville, en utilisant le m√™me agent utilisateur** (et l'IP si possible)**.**

### **MFA Se souvenir de l'appareil**

Si l'utilisateur se connecte depuis le m√™me appareil, le MFA pourrait √™tre contourn√©, essayez donc de vous connecter depuis le m√™me navigateur avec les m√™mes m√©tadonn√©es (IP ?) pour tenter de contourner la protection MFA.

## R√¥les IAM des Groupes de Pool d'Utilisateurs

Il est possible d'ajouter des **utilisateurs aux groupes de Pool d'Utilisateurs** qui sont li√©s √† un **r√¥le IAM**.\
De plus, les **utilisateurs** peuvent √™tre assign√©s √† **plus d'un groupe avec diff√©rents r√¥les IAM** attach√©s.

Notez que m√™me si un groupe est √† l'int√©rieur d'un groupe avec un r√¥le IAM attach√©, pour pouvoir acc√©der aux informations d'identification IAM de ce groupe, il est n√©cessaire que le **Pool d'Utilisateurs soit approuv√© par un Pool d'Identit√©** (et conna√Ætre les d√©tails de ce Pool d'Identit√©).

Un autre pr√©requis pour obtenir le **r√¥le IAM indiqu√© dans le IdToken** lorsqu'un utilisateur est authentifi√© dans le Pool d'Utilisateurs (`aws cognito-idp initiate-auth...`) est que le **fournisseur d'authentification de l'Identity Provider** doit indiquer que le **r√¥le doit √™tre s√©lectionn√© √† partir du jeton.**

<figure><img src="../../../../.gitbook/assets/image (250).png" alt=""><figcaption></figcaption></figure>

Les **r√¥les** auxquels un utilisateur a acc√®s sont **√† l'int√©rieur du `IdToken`**, et un utilisateur peut **s√©lectionner le r√¥le pour lequel il souhaite des informations d'identification** avec le **`--custom-role-arn`** de `aws cognito-identity get-credentials-for-identity`.\
Cependant, si l'**option par d√©faut** est celle **configur√©e** (`utiliser le r√¥le par d√©faut`), et que vous essayez d'acc√©der √† un r√¥le √† partir du IdToken, vous obtiendrez une **erreur** (c'est pourquoi la configuration pr√©c√©dente est n√©cessaire) :

{% code overflow="wrap" %}
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
{% endcode %}

{% hint style="warning" %}
Notez que le r√¥le attribu√© √† un **User Pool Group** doit √™tre **accessible par le Identity Provider** qui **fait confiance au User Pool** (car les **identifiants de session du r√¥le IAM vont √™tre obtenus √† partir de celui-ci**).
{% endhint %}
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
{% hint style="success" %}
Apprenez et pratiquez le Hacking AWS :<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Apprenez et pratiquez le Hacking GCP : <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Soutenez HackTricks</summary>

* Consultez les [**plans d'abonnement**](https://github.com/sponsors/carlospolop) !
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez des astuces de hacking en soumettant des PRs aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
