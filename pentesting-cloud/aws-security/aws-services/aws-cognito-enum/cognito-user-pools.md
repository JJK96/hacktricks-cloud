# Cognito User Pools

{% hint style="success" %}
学习和练习 AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
学习和练习 GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或 **关注** 我们的 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **通过提交 PRs 分享黑客技巧到** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库。

</details>
{% endhint %}

## 基本信息

用户池是 Amazon Cognito 中的用户目录。通过用户池，您的用户可以通过 Amazon Cognito **登录您的 web 或移动应用程序**，**或通过第三方**身份提供商 (IdP) 进行联合登录。无论您的用户是直接登录还是通过第三方登录，用户池的所有成员都有一个可以通过 SDK 访问的目录配置文件。

用户池提供：

* 注册和登录服务。
* 内置的、可定制的 web UI 以登录用户。
* 通过 Facebook、Google、Login with Amazon 和 Sign in with Apple 进行社交登录，以及通过 SAML 和 OIDC 身份提供商从您的用户池进行登录。
* 用户目录管理和用户配置文件。
* 安全功能，如多因素认证 (MFA)、受损凭证检查、账户接管保护以及电话和电子邮件验证。
* 通过 AWS Lambda 触发器定制工作流和用户迁移。

应用程序的**源代码**通常还包含**用户池 ID**和**客户端应用程序 ID**，（有时还包括**应用程序密钥**？）这些是用户登录到 Cognito 用户池所需的。

### 潜在攻击

* **注册**：默认情况下，用户可以自行注册，因此他可以为自己创建一个用户。
* **用户枚举**：注册功能可用于查找已存在的用户名。此信息对于暴力破解攻击非常有用。
* **登录暴力破解**：在[**认证**](cognito-user-pools.md#authentication)部分，您可以找到用户登录的所有**方法**，您可以尝试暴力破解它们**找到有效凭证**。

### 渗透测试工具

* [Pacu](https://github.com/RhinoSecurityLabs/pacu)，AWS 利用框架，现在包括 "cognito\_\_enum" 和 "cognito\_\_attack" 模块，这些模块自动枚举账户中的所有 Cognito 资产并标记弱配置、用于访问控制的用户属性等，还自动创建用户（包括 MFA 支持）和基于可修改的自定义属性、可用的身份池凭证、id 令牌中可假定的角色等进行权限提升。

有关模块功能的描述，请参见[博客文章](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2)的第 2 部分。有关安装说明，请参见 [Pacu](https://github.com/RhinoSecurityLabs/pacu) 主页面。

#### 用法

示例 cognito\_\_attack 用法，尝试在给定的身份池和用户池客户端上创建用户并进行所有权限提升向量：
```bash
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
示例 cognito\_\_enum 用法，以收集当前 AWS 账户中可见的所有用户池、用户池客户端、身份池、用户等：
```bash
Pacu (new:test) > run cognito__enum
```
* [Cognito Scanner](https://github.com/padok-team/cognito-scanner) 是一个用 Python 编写的 CLI 工具，实施包括不必要的账户创建和账户 oracle 在内的不同攻击。

#### 安装
```bash
$ pip install cognito-scanner
```
#### 使用方法
```bash
$ cognito-scanner --help
```
有关更多信息，请查看 https://github.com/padok-team/cognito-scanner

## Registration

User Pools 默认允许**注册新用户**。
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### 如果任何人都可以注册

你可能会发现一个错误，提示你需要**提供更多关于用户的详细信息**：
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
```json
{
  "UserPoolId": "us-east-1_example",
  "ClientId": "1example23456789"
}
```

```json
{
  "UserPoolId": "us-east-1_example",
  "ClientId": "1example23456789"
}
```
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
你也可以使用此功能来**枚举现有用户。** 当一个用户已经存在时，会出现以下错误消息：
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
{% hint style="info" %}
注意在前面的命令中，**自定义属性以 "custom:" 开头**。\
还要知道在注册时，**不能为用户创建新的自定义属性**。你只能为**默认属性**（即使它们不是必需的）和**指定的自定义属性**赋值。
{% endhint %}

或者只是测试一个 client id 是否存在。如果 client-id 不存在，会出现以下错误：
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### 如果只有管理员可以注册用户

你会发现这个错误，并且你将无法注册或枚举用户：
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### Verifying Registration

Cognito 允许通过验证电子邮件或电话号码来**验证新用户**。因此，在创建用户时，通常需要至少提供用户名和密码以及**电子邮件和/或电话号码**。只需设置一个**你控制的**，这样你就会收到代码来**验证你**新创建的用户**账户**，如下所示：
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
{% hint style="warning" %}
即使**看起来你可以使用相同的电子邮件**和电话号码，当你需要验证创建的用户时，Cognito 会抱怨使用相同的信息并且**不会让你验证账户**。
{% endhint %}

### 权限提升 / 更新属性

默认情况下，用户可以**修改其属性的值**，例如：
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### 自定义属性权限提升

{% hint style="danger" %}
你可能会发现使用了**自定义属性**（例如 `isAdmin`），因为默认情况下你可以**更改自己的属性值**，你可能能够通过自己更改值来**提升权限**！
{% endhint %}

#### 邮箱/用户名修改权限提升

你可以使用此方法**修改用户的邮箱和电话号码**，但即使账户仍然是已验证状态，这些属性也会被**设置为未验证状态**（你需要再次验证它们）。

{% hint style="warning" %}
在你验证之前，你**无法使用邮箱或电话号码登录**，但你可以**使用用户名登录**。\
注意，即使邮箱被修改且未验证，它仍会出现在 ID Token 的 **`email`** **字段**中，并且字段 **`email_verified`** 将为**false**，但如果应用**没有检查这一点，你可能会冒充其他用户**。

此外，注意你可以通过修改**name 属性**在 **`name`** 字段中放入任何内容。如果应用**出于某种原因检查**该字段而不是**`email`**（或任何其他属性），你可能能够**冒充其他用户**。
{% endhint %}

无论如何，如果由于某种原因你将邮箱更改为一个你可以访问的新邮箱，你可以**使用你在该邮箱地址收到的代码确认邮箱**：
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
使用 **`phone_number`** 而不是 **`email`** 来更改/验证一个**新电话号码**。

{% hint style="info" %}
管理员也可以启用**使用用户首选用户名登录**的选项。请注意，您将无法将此值更改为**任何已被使用的用户名或首选\_用户名**来冒充其他用户。
{% endhint %}

### 恢复/更改密码

只需**知道用户名**（或接受电子邮件或电话）并能够访问它，因为代码将发送到那里，就可以恢复密码：
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
{% hint style="info" %}
服务器的响应总是会是正面的，就像用户名存在一样。你不能使用这种方法来枚举用户
{% endhint %}

使用代码你可以更改密码：
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
要更改密码，您需要**知道之前的密码**：
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## 认证

用户池支持**不同的认证方式**。如果你有**用户名和密码**，也有**不同的方法**支持登录。\
此外，当用户在池中认证后，会提供**3种类型的令牌**：**ID 令牌**、**访问令牌**和**刷新令牌**。

* [**ID 令牌**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html)：它包含关于**已认证用户身份**的声明，如 `name`、`email` 和 `phone_number`。ID 令牌还可以用于**认证用户到你的资源服务器或服务器应用程序**。如果在外部应用程序中使用 ID 令牌，必须**验证** ID 令牌的**签名**，才能信任 ID 令牌中的任何声明。
* ID 令牌是**包含用户属性值**的令牌，甚至包括自定义属性。
* [**访问令牌**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html)：它包含关于已认证用户的声明、**用户组列表和范围列表**。访问令牌的目的是**授权 API 操作**，在用户池的上下文中。例如，可以使用访问令牌**授予用户访问权限**，以添加、更改或删除用户属性。
* [**刷新令牌**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html)：使用刷新令牌，可以**获取新的 ID 令牌和访问令牌**，直到**刷新令牌失效**。**默认情况下**，刷新令牌在应用程序用户登录到用户池后**30天后过期**。创建用户池的应用程序时，可以将应用程序的刷新令牌过期时间设置为**60分钟到10年之间的任何值**。

### ADMIN\_NO\_SRP\_AUTH & ADMIN\_USER\_PASSWORD\_AUTH

这是服务器端认证流程：

* 服务器端应用程序调用 **`AdminInitiateAuth` API 操作**（而不是 `InitiateAuth`）。此操作需要具有**`cognito-idp:AdminInitiateAuth`**和**`cognito-idp:AdminRespondToAuthChallenge`**权限的 AWS 凭证。操作返回所需的认证参数。
* 服务器端应用程序获取**认证参数**后，调用 **`AdminRespondToAuthChallenge` API 操作**。`AdminRespondToAuthChallenge` API 操作只有在提供 AWS 凭证时才会成功。

此**方法默认未启用**。

要**登录**，你**需要**知道：

* 用户池 ID
* 客户端 ID
* 用户名
* 密码
* 客户端密钥（仅当应用程序配置为使用密钥时）

{% hint style="info" %}
为了**能够使用此方法登录**，应用程序必须允许使用 `ALLOW_ADMIN_USER_PASSWORD_AUTH` 登录。\
此外，执行此操作需要具有**`cognito-idp:AdminInitiateAuth`**和**`cognito-idp:AdminRespondToAuthChallenge`**权限的凭证。
{% endhint %}
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>登录代码</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_PASSWORD\_AUTH

这种方法是另一种简单且**传统的用户和密码认证**流程。建议**将传统**的认证方法**迁移到 Cognito**，然后**禁用**它，并**使用** **ALLOW\_USER\_SRP\_AUTH** 方法（因为这种方法从不通过网络发送密码）。\
这种**方法默认不启用**。

与**之前的认证方法**相比，主要**区别**在于你**不需要知道用户池 ID**，也**不需要额外的权限**在 Cognito 用户池中。

要**登录**，你**需要**知道：

* client id
* username
* password
* client secret（仅当应用配置为使用 secret 时）

{% hint style="info" %}
为了**能够使用这种方法登录**，应用必须允许使用 ALLOW\_USER\_PASSWORD\_AUTH 登录。
{% endhint %}
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>Python 代码登录</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_SRP\_AUTH

这个场景与前一个类似，但**不是通过网络发送密码**来登录，而是**执行挑战认证**（因此没有密码即使加密也不会通过网络传输）。\
这种**方法默认启用**。

要**登录**，你**需要**知道：

* user pool id
* client id
* username
* password
* client secret（仅当应用配置为使用密钥时）

<details>

<summary>Code to login</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

这个**方法总是有效的**（它不能被禁用），但你需要有一个有效的refresh token。
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>刷新代码</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM\_AUTH

在这种情况下，**认证**将通过**执行一个lambda函数**来进行。

## 额外安全

### 高级安全

默认情况下是禁用的，但如果启用，Cognito可以**发现账户接管**。为了尽量减少这种可能性，你应该从**同一城市内的网络，使用相同的用户代理**（如果可能的话，使用相同的IP）登录。

### **MFA 记住设备**

如果用户从同一设备登录，MFA可能会被绕过，因此尝试从相同的浏览器使用相同的元数据（IP？）登录，以尝试绕过MFA保护。

## 用户池组 IAM 角色

可以将**用户添加到与一个**IAM角色**相关的**用户池组**中。\
此外，**用户**可以被分配到**多个附有不同IAM角色的组**中。

请注意，即使一个组在一个附有IAM角色的组内，为了能够访问该组的IAM凭证，需要**用户池被身份池信任**（并知道该身份池的详细信息）。

当用户在用户池中认证时（`aws cognito-idp initiate-auth...`），要获取**IdToken中指示的IAM角色**，需要**身份提供者认证提供者**指示**角色必须从令牌中选择**。

<figure><img src="../../../../.gitbook/assets/image (250).png" alt=""><figcaption></figcaption></figure>

用户可以访问的**角色**在**`IdToken`**中，用户可以使用**`--custom-role-arn`**从`aws cognito-identity get-credentials-for-identity`中**选择他想要的凭证角色**。\
然而，如果**默认选项**是**配置的**（`使用默认角色`），并且你尝试从IdToken访问一个角色，你将会得到**错误**（这就是为什么需要之前的配置）：

{% code overflow="wrap" %}
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
{% endcode %}

{% hint style="warning" %}
请注意，分配给 **User Pool Group** 的角色需要被 **信任 User Pool 的 Identity Provider** **访问**（因为 IAM 角色的 **会话凭证将从中获取**）。
{% endhint %}
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
{% hint style="success" %}
学习和练习 AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
学习和练习 GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或 **关注** 我们的 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **通过提交 PRs 分享黑客技巧到** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库。

</details>
{% endhint %}
