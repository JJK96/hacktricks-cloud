# Cognito User Pools

{% hint style="success" %}
Naucz się i ćwicz AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Naucz się i ćwicz GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wspieraj HackTricks</summary>

* Sprawdź [**plany subskrypcji**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel się trikami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na githubie.

</details>
{% endhint %}

## Podstawowe informacje

Pula użytkowników to katalog użytkowników w Amazon Cognito. Dzięki puli użytkowników, Twoi użytkownicy mogą **logować się do Twojej aplikacji webowej lub mobilnej** za pośrednictwem Amazon Cognito, **lub federować** się przez **zewnętrznego** dostawcę tożsamości (IdP). Niezależnie od tego, czy użytkownicy logują się bezpośrednio, czy przez stronę trzecią, wszyscy członkowie puli użytkowników mają profil w katalogu, do którego można uzyskać dostęp za pomocą SDK.

Pule użytkowników oferują:

* Usługi rejestracji i logowania.
* Wbudowany, konfigurowalny interfejs webowy do logowania użytkowników.
* Logowanie społecznościowe z Facebook, Google, Login with Amazon i Sign in with Apple oraz przez dostawców tożsamości SAML i OIDC z Twojej puli użytkowników.
* Zarządzanie katalogiem użytkowników i profilami użytkowników.
* Funkcje bezpieczeństwa, takie jak uwierzytelnianie wieloskładnikowe (MFA), sprawdzanie skompromitowanych poświadczeń, ochrona przed przejęciem konta oraz weryfikacja telefonu i e-maila.
* Dostosowane przepływy pracy i migracja użytkowników za pomocą wyzwalaczy AWS Lambda.

**Kod źródłowy** aplikacji zazwyczaj zawiera również **ID puli użytkowników** i **ID aplikacji klienckiej** (a czasami **sekret aplikacji**?), które są potrzebne do **logowania użytkownika** do puli użytkowników Cognito.

### Potencjalne ataki

* **Rejestracja**: Domyślnie użytkownik może zarejestrować się samodzielnie, więc może stworzyć konto dla siebie.
* **Enumeracja użytkowników**: Funkcjonalność rejestracji może być użyta do znalezienia nazw użytkowników, które już istnieją. Ta informacja może być przydatna do ataku brute-force.
* **Brute-force logowania**: W sekcji [**Authentication**](cognito-user-pools.md#authentication) znajdziesz wszystkie **metody**, które użytkownik ma do **logowania**, możesz spróbować brute-force, aby **znaleźć prawidłowe poświadczenia**.

### Narzędzia do pentestingu

* [Pacu](https://github.com/RhinoSecurityLabs/pacu), framework do eksploatacji AWS, teraz zawiera moduły "cognito\_\_enum" i "cognito\_\_attack", które automatyzują enumerację wszystkich zasobów Cognito w koncie i oznaczają słabe konfiguracje, atrybuty użytkowników używane do kontroli dostępu itp., a także automatyzują tworzenie użytkowników (w tym wsparcie MFA) i eskalację uprawnień na podstawie modyfikowalnych atrybutów niestandardowych, używalnych poświadczeń puli tożsamości, ról możliwych do przyjęcia w tokenach id itp.

Opis funkcji modułów znajdziesz w części 2 [postu na blogu](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2). Instrukcje instalacji znajdziesz na głównej stronie [Pacu](https://github.com/RhinoSecurityLabs/pacu).

#### Użycie

Przykładowe użycie cognito\_\_attack do próby tworzenia użytkowników i wszystkich wektorów privesc przeciwko danej puli tożsamości i klientowi puli użytkowników:
```bash
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
Przykład użycia cognito\_\_enum do zebrania wszystkich pul użytkowników, klientów pul użytkowników, pul tożsamości, użytkowników itp. widocznych w bieżącym koncie AWS:
```bash
Pacu (new:test) > run cognito__enum
```
* [Cognito Scanner](https://github.com/padok-team/cognito-scanner) jest narzędziem CLI w pythonie, które implementuje różne ataki na Cognito, w tym niechciane tworzenie kont i konto oracle.

#### Instalacja
```bash
$ pip install cognito-scanner
```
#### Użycie
```bash
$ cognito-scanner --help
```
Aby uzyskać więcej informacji, sprawdź https://github.com/padok-team/cognito-scanner

## Rejestracja

User Pools domyślnie pozwala na **rejestrację nowych użytkowników**.
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### Jeśli każdy może się zarejestrować

Możesz napotkać błąd informujący, że musisz **podać więcej szczegółów** dotyczących użytkownika:
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
Możesz podać potrzebne szczegóły za pomocą JSON, takiego jak:
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
Możesz użyć tej funkcjonalności również do **enumeracji istniejących użytkowników.** To jest komunikat o błędzie, gdy użytkownik o tej nazwie już istnieje:
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
{% hint style="info" %}
Zwróć uwagę w poprzednim poleceniu, jak **niestandardowe atrybuty zaczynają się od "custom:"**.\
Wiedz również, że podczas rejestracji **nie możesz tworzyć nowych niestandardowych atrybutów dla użytkownika**. Możesz jedynie przypisywać wartości do **domyślnych atrybutów** (nawet jeśli nie są wymagane) oraz **określonych niestandardowych atrybutów**.
{% endhint %}

Lub po prostu, aby sprawdzić, czy istnieje client id. To jest błąd, jeśli client-id nie istnieje:
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### Jeśli tylko administrator może rejestrować użytkowników

Znajdziesz ten błąd i nie będziesz w stanie zarejestrować ani wyliczyć użytkowników:
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### Weryfikacja Rejestracji

Cognito pozwala na **weryfikację nowego użytkownika poprzez weryfikację jego adresu email lub numeru telefonu**. Dlatego też, podczas tworzenia użytkownika zazwyczaj wymagane będą przynajmniej nazwa użytkownika i hasło oraz **adres email i/lub numer telefonu**. Ustaw jeden, **który kontrolujesz**, aby otrzymać kod do **weryfikacji swojego** nowo utworzonego **konta użytkownika** w ten sposób:
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
{% hint style="warning" %}
Nawet jeśli **wygląda na to, że możesz użyć tego samego e-maila** i numeru telefonu, gdy będziesz musiał zweryfikować utworzonego użytkownika, Cognito będzie narzekać na użycie tych samych informacji i **nie pozwoli ci zweryfikować konta**.
{% endhint %}

### Eskalacja uprawnień / Aktualizacja atrybutów

Domyślnie użytkownik może **modyfikować wartość swoich atrybutów** za pomocą czegoś takiego jak:
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### Custom attribute privesc

{% hint style="danger" %}
Możesz znaleźć **niestandardowe atrybuty** używane (takie jak `isAdmin`), ponieważ domyślnie możesz **zmieniać wartości swoich własnych atrybutów**, możesz być w stanie **eskalować uprawnienia** zmieniając wartość samodzielnie!
{% endhint %}

#### Email/username modification privesc

Możesz użyć tego do **modyfikacji adresu email i numeru telefonu** użytkownika, ale wtedy, nawet jeśli konto pozostaje zweryfikowane, te atrybuty są **ustawione jako niezweryfikowane** (musisz je ponownie zweryfikować).

{% hint style="warning" %}
**Nie będziesz w stanie zalogować się za pomocą emaila lub numeru telefonu** dopóki ich nie zweryfikujesz, ale będziesz **mógł zalogować się za pomocą nazwy użytkownika**.\
Zauważ, że nawet jeśli email został zmodyfikowany i niezweryfikowany, pojawi się w Tokenie ID w polu **`email`** i pole **`email_verified`** będzie miało wartość **false**, ale jeśli aplikacja **tego nie sprawdza, możesz podszyć się pod innych użytkowników**.

Ponadto, zauważ, że możesz umieścić cokolwiek w polu **`name`** po prostu modyfikując **atrybut name**. Jeśli aplikacja **sprawdza** **to** pole z jakiegoś powodu **zamiast `email`** (lub jakiegokolwiek innego atrybutu), możesz być w stanie **podszyć się pod innych użytkowników**.
{% endhint %}

W każdym razie, jeśli z jakiegoś powodu zmieniłeś swój email na nowy, do którego masz dostęp, możesz **potwierdzić email za pomocą kodu, który otrzymałeś na ten adres email**:
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
Użyj **`phone_number`** zamiast **`email`** do zmiany/weryfikacji **nowego numeru telefonu**.

{% hint style="info" %}
Administrator może również włączyć opcję **logowania się za pomocą preferowanej nazwy użytkownika**. Zauważ, że nie będziesz mógł zmienić tej wartości na **dowolną nazwę użytkownika lub preferred\_username, która jest już używana**, aby podszyć się pod innego użytkownika.
{% endhint %}

### Odzyskiwanie/Zmiana Hasła

Możliwe jest odzyskanie hasła, mając tylko **nazwę użytkownika** (lub akceptowany jest email lub telefon) i mając do niego dostęp, ponieważ kod zostanie tam wysłany:
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
{% hint style="info" %}
Odpowiedź serwera zawsze będzie pozytywna, jakby nazwa użytkownika istniała. Nie możesz użyć tej metody do enumeracji użytkowników
{% endhint %}

Za pomocą kodu możesz zmienić hasło za pomocą:
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
Aby zmienić hasło, musisz **znać poprzednie hasło**:
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## Autoryzacja

Pula użytkowników obsługuje **różne sposoby autoryzacji**. Jeśli masz **nazwę użytkownika i hasło**, istnieją również **różne metody** logowania.\
Ponadto, gdy użytkownik jest uwierzytelniony w Puli, **wydawane są 3 rodzaje tokenów**: **ID Token**, **Access token** i **Refresh token**.

* [**ID Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html): Zawiera roszczenia dotyczące **tożsamości uwierzytelnionego użytkownika**, takie jak `name`, `email` i `phone_number`. ID token może być również używany do **uwierzytelniania użytkowników na serwerach zasobów lub aplikacjach serwerowych**. Musisz **zweryfikować** **podpis** ID tokena, zanim zaufasz jakimkolwiek roszczeniom zawartym w ID tokenie, jeśli używasz go w aplikacjach zewnętrznych.
* ID Token to token, który **zawiera wartości atrybutów użytkownika**, nawet te niestandardowe.
* [**Access Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html): Zawiera roszczenia dotyczące uwierzytelnionego użytkownika, listę **grup użytkownika i listę zakresów**. Celem access tokena jest **autoryzacja operacji API** w kontekście użytkownika w puli użytkowników. Na przykład, możesz użyć access tokena, aby **przyznać użytkownikowi dostęp** do dodawania, zmieniania lub usuwania atrybutów użytkownika.
* [**Refresh Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html): Dzięki refresh tokenom możesz **uzyskać nowe ID Tokeny i Access Tokeny** dla użytkownika, dopóki **refresh token nie stanie się nieważny**. **Domyślnie**, refresh token **wygasa 30 dni po** zalogowaniu się użytkownika do puli użytkowników. Tworząc aplikację dla swojej puli użytkowników, możesz ustawić czas wygaśnięcia refresh tokena na **dowolną wartość między 60 minutami a 10 latami**.

### ADMIN\_NO\_SRP\_AUTH & ADMIN\_USER\_PASSWORD\_AUTH

To jest przepływ autoryzacji po stronie serwera:

* Aplikacja po stronie serwera wywołuje operację API **`AdminInitiateAuth`** (zamiast `InitiateAuth`). Ta operacja wymaga poświadczeń AWS z uprawnieniami obejmującymi **`cognito-idp:AdminInitiateAuth`** i **`cognito-idp:AdminRespondToAuthChallenge`**. Operacja zwraca wymagane parametry autoryzacji.
* Po uzyskaniu przez aplikację po stronie serwera **parametrów autoryzacji**, wywołuje ona operację API **`AdminRespondToAuthChallenge`**. Operacja API `AdminRespondToAuthChallenge` kończy się sukcesem tylko wtedy, gdy dostarczysz poświadczenia AWS.

Ta **metoda NIE jest domyślnie włączona**.

Aby **zalogować się**, **musisz znać**:

* id puli użytkowników
* id klienta
* nazwę użytkownika
* hasło
* sekret klienta (tylko jeśli aplikacja jest skonfigurowana do używania sekretu)

{% hint style="info" %}
Aby **móc zalogować się tą metodą**, aplikacja musi umożliwiać logowanie za pomocą `ALLOW_ADMIN_USER_PASSWORD_AUTH`.\
Ponadto, aby wykonać tę akcję, potrzebujesz poświadczeń z uprawnieniami **`cognito-idp:AdminInitiateAuth`** i **`cognito-idp:AdminRespondToAuthChallenge`**
{% endhint %}
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>Kod do logowania</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_PASSWORD\_AUTH

Ta metoda to kolejny prosty i **tradycyjny przepływ uwierzytelniania użytkownika i hasła**. Zaleca się **migrację tradycyjnej** metody uwierzytelniania **do Cognito** i **następnie jej wyłączenie** oraz **użycie** metody **ALLOW\_USER\_SRP\_AUTH** (ponieważ ta nigdy nie wysyła hasła przez sieć).\
Ta **metoda NIE jest domyślnie włączona**.

Główna **różnica** w stosunku do **poprzedniej metody uwierzytelniania** w kodzie polega na tym, że **nie musisz znać ID puli użytkowników** i **nie potrzebujesz dodatkowych uprawnień** w Cognito User Pool.

Aby **zalogować się**, **musisz znać**:

* client id
* username
* password
* client secret (tylko jeśli aplikacja jest skonfigurowana do używania sekretu)

{% hint style="info" %}
Aby **móc zalogować się tą metodą**, aplikacja musi pozwalać na logowanie z ALLOW\_USER\_PASSWORD\_AUTH.
{% endhint %}
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>Python code to Login</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_SRP\_AUTH

Ten scenariusz jest podobny do poprzedniego, ale **zamiast wysyłania hasła** przez sieć do logowania, **wykonywane jest uwierzytelnianie wyzwania** (więc hasło nie jest przesyłane nawet zaszyfrowane przez sieć).\
Ta **metoda jest domyślnie włączona**.

Aby **zalogować się**, **musisz znać**:

* user pool id
* client id
* username
* password
* client secret (tylko jeśli aplikacja jest skonfigurowana do używania sekretu)

<details>

<summary>Kod do logowania</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

Ta **metoda zawsze będzie ważna** (nie można jej wyłączyć), ale musisz mieć ważny refresh token.
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>Kod do odświeżenia</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM\_AUTH

W tym przypadku **uwierzytelnianie** będzie przeprowadzane poprzez **wykonanie funkcji lambda**.

## Dodatkowe zabezpieczenia

### Zaawansowane zabezpieczenia

Domyślnie jest wyłączone, ale jeśli jest włączone, Cognito może być w stanie **wykryć przejęcia konta**. Aby zminimalizować prawdopodobieństwo, powinieneś logować się z **sieci w tym samym mieście, używając tego samego agenta użytkownika** (i jeśli to możliwe, tego samego IP).

### **MFA Zapamiętaj urządzenie**

Jeśli użytkownik loguje się z tego samego urządzenia, MFA może zostać pominięte, dlatego spróbuj zalogować się z tej samej przeglądarki z tymi samymi metadanymi (IP?), aby spróbować obejść ochronę MFA.

## Role IAM grup puli użytkowników

Możliwe jest dodanie **użytkowników do grup puli użytkowników** powiązanych z jedną **rolą IAM**.\
Ponadto, **użytkownicy** mogą być przypisani do **więcej niż jednej grupy z różnymi rolami IAM**.

Należy zauważyć, że nawet jeśli grupa jest wewnątrz grupy z przypisaną rolą IAM, aby móc uzyskać dostęp do poświadczeń IAM tej grupy, konieczne jest, aby **pula użytkowników była zaufana przez pulę tożsamości** (i znała szczegóły tej puli tożsamości).

Innym wymogiem, aby uzyskać **rolę IAM wskazaną w IdToken** podczas uwierzytelniania użytkownika w puli użytkowników (`aws cognito-idp initiate-auth...`), jest to, że **dostawca uwierzytelniania dostawcy tożsamości** musi wskazać, że **rola musi być wybrana z tokenu.**

<figure><img src="../../../../.gitbook/assets/image (250).png" alt=""><figcaption></figcaption></figure>

**Role**, do których użytkownik ma dostęp, są **wewnątrz `IdToken`**, a użytkownik może **wybrać, którą rolę chciałby uzyskać poświadczenia** za pomocą **`--custom-role-arn`** z `aws cognito-identity get-credentials-for-identity`.\
Jednakże, jeśli **domyślna opcja** jest **skonfigurowana** (`use default role`), i spróbujesz uzyskać dostęp do roli z IdToken, otrzymasz **błąd** (dlatego potrzebna jest wcześniejsza konfiguracja):

{% code overflow="wrap" %}
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
{% endcode %}

{% hint style="warning" %}
Zauważ, że rola przypisana do **User Pool Group** musi być **dostępna przez Identity Provider**, który **ufa User Pool** (ponieważ **poświadczenia sesji IAM role będą z niego uzyskiwane**).
{% endhint %}
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
{% hint style="success" %}
Ucz się i ćwicz AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Ucz się i ćwicz GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wspieraj HackTricks</summary>

* Sprawdź [**plany subskrypcji**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegram**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel się trikami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **repozytoriów na githubie**.

</details>
{% endhint %}
