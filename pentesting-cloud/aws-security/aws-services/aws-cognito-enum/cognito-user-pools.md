# Cognito User Pools

{% hint style="success" %}
Impara e pratica AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Impara e pratica GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repository github.

</details>
{% endhint %}

## Informazioni di base

Un user pool √® una directory utenti in Amazon Cognito. Con un user pool, i tuoi utenti possono **accedere alla tua app web o mobile** tramite Amazon Cognito, **o federarsi** tramite un **provider di identit√†** (IdP) di **terze parti**. Che i tuoi utenti accedano direttamente o tramite terze parti, tutti i membri dell'user pool hanno un profilo di directory a cui puoi accedere tramite un SDK.

Gli user pools forniscono:

* Servizi di registrazione e accesso.
* Una UI web integrata e personalizzabile per l'accesso degli utenti.
* Accesso social con Facebook, Google, Login con Amazon e Sign in con Apple, e tramite provider di identit√† SAML e OIDC dal tuo user pool.
* Gestione della directory utenti e profili utente.
* Funzionalit√† di sicurezza come l'autenticazione multi-fattore (MFA), controlli per credenziali compromesse, protezione dal takeover dell'account e verifica di telefono ed email.
* Workflow personalizzati e migrazione degli utenti tramite trigger AWS Lambda.

Il **codice sorgente** delle applicazioni di solito contiene anche l'**ID del user pool** e l'**ID dell'applicazione client**, (e a volte il **segreto dell'applicazione**?) che sono necessari per un **utente per accedere** a un Cognito User Pool.

### Potenziali attacchi

* **Registrazione**: Per impostazione predefinita, un utente pu√≤ registrarsi da solo, quindi potrebbe creare un utente per s√©.
* **Enumerazione utenti**: La funzionalit√† di registrazione pu√≤ essere utilizzata per trovare nomi utente gi√† esistenti. Queste informazioni possono essere utili per l'attacco brute-force.
* **Login brute-force**: Nella sezione [**Autenticazione**](cognito-user-pools.md#authentication) hai tutti i **metodi** che un utente ha per **accedere**, potresti provare a brute-forzare per **trovare credenziali valide**.

### Strumenti per pentesting

* [Pacu](https://github.com/RhinoSecurityLabs/pacu), il framework di sfruttamento AWS, ora include i moduli "cognito\_\_enum" e "cognito\_\_attack" che automatizzano l'enumerazione di tutte le risorse Cognito in un account e segnalano configurazioni deboli, attributi utente utilizzati per il controllo degli accessi, ecc., e automatizzano anche la creazione di utenti (incluso il supporto MFA) e l'escalation dei privilegi basata su attributi personalizzabili, credenziali di identity pool utilizzabili, ruoli assumibili nei token id, ecc.

Per una descrizione delle funzioni dei moduli, vedere la parte 2 del [post del blog](https://rhinosecuritylabs.com/aws/attacking-aws-cognito-with-pacu-p2). Per le istruzioni di installazione, vedere la pagina principale di [Pacu](https://github.com/RhinoSecurityLabs/pacu).

#### Utilizzo

Esempio di utilizzo di cognito\_\_attack per tentare la creazione di utenti e tutti i vettori di privesc contro un dato identity pool e client user pool:
```bash
Pacu (new:test) > run cognito__attack --username randomuser --email XX+sdfs2@gmail.com --identity_pools
us-east-2:a06XXXXX-c9XX-4aXX-9a33-9ceXXXXXXXXX --user_pool_clients
59f6tuhfXXXXXXXXXXXXXXXXXX@us-east-2_0aXXXXXXX
```
Esempio di utilizzo di cognito\_\_enum per raccogliere tutti i pool di utenti, i client dei pool di utenti, i pool di identit√†, gli utenti, ecc. visibili nell'account AWS corrente:
```bash
Pacu (new:test) > run cognito__enum
```
* [Cognito Scanner](https://github.com/padok-team/cognito-scanner) √® uno strumento CLI in python che implementa diversi attacchi su Cognito, inclusi la creazione indesiderata di account e l'oracolo degli account.

#### Installazione
```bash
$ pip install cognito-scanner
```
#### Utilizzo
```bash
$ cognito-scanner --help
```
Per maggiori informazioni controlla https://github.com/padok-team/cognito-scanner

## Registrazione

User Pools consente per **default** di **registrare nuovi utenti**.
```bash
aws cognito-idp sign-up --client-id <client-id> \
--username <username> --password <password> \
--region <region> --no-sign-request
```
#### Se chiunque pu√≤ registrarsi

Potresti trovare un errore che ti indica di **fornire pi√π dettagli** sull'utente:
```
An error occurred (InvalidParameterException) when calling the SignUp operation: Attributes did not conform to the schema: address: The attribute is required
```
Puoi fornire i dettagli necessari con un JSON come:
```json
--user-attributes '[{"Name": "email", "Value": "carlospolop@gmail.com"}, {"Name":"gender", "Value": "M"}, {"Name": "address", "Value": "street"}, {"Name": "custom:custom_name", "Value":"supername&\"*$"}]'
```
Puoi utilizzare questa funzionalit√† anche per **enumerare gli utenti esistenti.** Questo √® il messaggio di errore quando un utente esiste gi√† con quel nome:
```
An error occurred (UsernameExistsException) when calling the SignUp operation: User already exists
```
{% hint style="info" %}
Nota nel comando precedente come gli **attributi personalizzati iniziano con "custom:"**.\
Sappi anche che durante la registrazione **non puoi creare nuovi attributi personalizzati per l'utente**. Puoi solo assegnare un valore agli **attributi predefiniti** (anche se non sono obbligatori) e agli **attributi personalizzati specificati**.
{% endhint %}

Oppure solo per testare se un client id esiste. Questo √® l'errore se il client-id non esiste:
```
An error occurred (ResourceNotFoundException) when calling the SignUp operation: User pool client 3ig612gjm56p1ljls1prq2miut does not exist.
```
#### Se solo l'amministratore pu√≤ registrare gli utenti

Troverai questo errore e non sarai in grado di registrare o enumerare gli utenti:
```
An error occurred (NotAuthorizedException) when calling the SignUp operation: SignUp is not permitted for this user pool
```
### Verifying Registration

Cognito consente di **verificare un nuovo utente verificando la sua email o numero di telefono**. Pertanto, quando si crea un utente di solito saranno richiesti almeno il nome utente e la password e l'**email e/o il numero di telefono**. Basta impostare uno **che controlli** in modo da ricevere il codice per **verificare il tuo** account utente appena creato **in questo modo**:
```bash
aws cognito-idp confirm-sign-up --client-id <cliet_id> \
--username aasdasd2 --confirmation-code <conf_code> \
--no-sign-request --region us-east-1
```
{% hint style="warning" %}
Anche se **sembra che tu possa usare la stessa email** e numero di telefono, quando devi verificare l'utente creato, Cognito si lamenter√† dell'uso delle stesse informazioni e **non ti permetter√† di verificare l'account**.
{% endhint %}

### Escalation dei Privilegi / Aggiornamento degli Attributi

Per impostazione predefinita, un utente pu√≤ **modificare il valore dei suoi attributi** con qualcosa del genere:
```bash
aws cognito-idp update-user-attributes \
--region us-east-1 --no-sign-request \
--user-attributes Name=address,Value=street \
--access-token <access token>
```
#### Custom attribute privesc

{% hint style="danger" %}
Potresti trovare **attributi personalizzati** in uso (come `isAdmin`), poich√© per impostazione predefinita puoi **cambiare i valori dei tuoi attributi**, potresti essere in grado di **escalare i privilegi** cambiando il valore tu stesso!
{% endhint %}

#### Email/username modification privesc

Puoi usare questo per **modificare l'email e il numero di telefono** di un utente, ma poi, anche se l'account rimane verificato, quegli attributi sono **impostati in stato non verificato** (devi verificarli di nuovo).

{% hint style="warning" %}
Non **sarai in grado di accedere con email o numero di telefono** fino a quando non li verifichi, ma sarai **in grado di accedere con il nome utente**.\
Nota che anche se l'email √® stata modificata e non verificata, apparir√† nel Token ID all'interno del **campo** **`email`** e il campo **`email_verified`** sar√† **falso**, ma se l'app **non lo sta controllando potresti impersonare altri utenti**.

Inoltre, nota che puoi inserire qualsiasi cosa all'interno del campo **`name`** semplicemente modificando l'**attributo name**. Se un'app **sta controllando** **quel** campo per qualche motivo **invece dell'`email`** (o qualsiasi altro attributo) potresti essere in grado di **impersonare altri utenti**.
{% endhint %}

Comunque, se per qualche motivo hai cambiato la tua email ad esempio con una nuova a cui puoi accedere, puoi **confermare l'email con il codice che hai ricevuto in quell'indirizzo email**:
```bash
aws cognito-idp verify-user-attribute \
--access-token <access_token> \
--attribute-name email --code <code> \
--region <region> --no-sign-request
```
Usa **`phone_number`** invece di **`email`** per cambiare/verificare un **nuovo numero di telefono**.

{% hint style="info" %}
L'amministratore potrebbe anche abilitare l'opzione per **accedere con un nome utente preferito dall'utente**. Nota che non sar√† possibile cambiare questo valore in **qualsiasi nome utente o preferred\_username gi√† in uso** per impersonare un altro utente.
{% endhint %}

### Recuperare/Cambiare Password

√à possibile recuperare una password solo **conoscendo il nome utente** (o email o telefono √® accettato) e avendo accesso ad esso poich√© un codice verr√† inviato l√¨:
```bash
aws cognito-idp forgot-password \
--client-id <client_id> \
--username <username/email/phone> --region <region>
```
{% hint style="info" %}
La risposta del server sar√† sempre positiva, come se il nome utente esistesse. Non puoi usare questo metodo per enumerare gli utenti.
{% endhint %}

Con il codice puoi cambiare la password con:
```bash
aws cognito-idp confirm-forgot-password \
--client-id <client_id> \
--username <username> \
--confirmation-code <conf_code> \
--password <pwd> --region <region>
```
Per cambiare la password √® necessario **conoscere la password precedente**:
```bash
aws cognito-idp change-password \
--previous-password <value> \
--proposed-password <value> \
--access-token <value>
```
## Autenticazione

Un user pool supporta **diversi modi per autenticarsi**. Se hai un **username e una password** ci sono anche **diversi metodi** supportati per il login.\
Inoltre, quando un utente √® autenticato nel Pool vengono forniti **3 tipi di token**: Il **ID Token**, il **Access token** e il **Refresh token**.

* [**ID Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html): Contiene affermazioni sull'**identit√† dell'utente autenticato**, come `name`, `email`, e `phone_number`. Il ID token pu√≤ anche essere utilizzato per **autenticare gli utenti ai tuoi server di risorse o applicazioni server**. Devi **verificare** la **firma** del ID token prima di poter fidarti di qualsiasi affermazione all'interno del ID token se lo usi in applicazioni esterne.
* Il ID Token √® il token che **contiene i valori degli attributi dell'utente**, anche quelli personalizzati.
* [**Access Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html): Contiene affermazioni sull'utente autenticato, un elenco dei **gruppi dell'utente e un elenco di ambiti**. Lo scopo del access token √® di **autorizzare le operazioni API** nel contesto dell'utente nel user pool. Ad esempio, puoi utilizzare il access token per **concedere al tuo utente l'accesso** per aggiungere, modificare o eliminare attributi dell'utente.
* [**Refresh Token**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html): Con i refresh token puoi **ottenere nuovi ID Token e Access Token** per l'utente fino a quando il **refresh token non √® invalido**. Per **default**, il refresh token **scade 30 giorni dopo** che l'utente della tua applicazione ha effettuato l'accesso al tuo user pool. Quando crei un'applicazione per il tuo user pool, puoi impostare la scadenza del refresh token dell'applicazione su **qualsiasi valore tra 60 minuti e 10 anni**.

### ADMIN\_NO\_SRP\_AUTH & ADMIN\_USER\_PASSWORD\_AUTH

Questo √® il flusso di autenticazione lato server:

* L'app lato server chiama l'operazione API **`AdminInitiateAuth`** (invece di `InitiateAuth`). Questa operazione richiede credenziali AWS con permessi che includono **`cognito-idp:AdminInitiateAuth`** e **`cognito-idp:AdminRespondToAuthChallenge`**. L'operazione restituisce i parametri di autenticazione richiesti.
* Dopo che l'app lato server ha i **parametri di autenticazione**, chiama l'operazione API **`AdminRespondToAuthChallenge`**. L'operazione API `AdminRespondToAuthChallenge` ha successo solo quando fornisci credenziali AWS.

Questo **metodo NON √® abilitato** per default.

Per **effettuare il login** √® **necessario** conoscere:

* user pool id
* client id
* username
* password
* client secret (solo se l'app √® configurata per utilizzare un segreto)

{% hint style="info" %}
Per essere **in grado di effettuare il login con questo metodo** l'applicazione deve consentire il login con `ALLOW_ADMIN_USER_PASSWORD_AUTH`.\
Inoltre, per eseguire questa azione sono necessarie credenziali con i permessi **`cognito-idp:AdminInitiateAuth`** e **`cognito-idp:AdminRespondToAuthChallenge`**
{% endhint %}
```python
aws cognito-idp admin-initiate-auth \
--client-id <client-id> \
--auth-flow ADMIN_USER_PASSWORD_AUTH \
--region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'
--user-pool-id "<pool-id>"

# Check the python code to learn how to generate the hsecret_hash
```
<details>

<summary>Codice per Accedere</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.admin_initiate_auth(
UserPoolId=user_pool_id,
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_PASSWORD\_AUTH

Questo metodo √® un altro semplice e **tradizionale flusso di autenticazione utente e password**. √à consigliato **migrare un metodo di autenticazione tradizionale a Cognito** e poi **disabilitarlo** e **usare** il metodo **ALLOW\_USER\_SRP\_AUTH** invece (poich√© quest'ultimo non invia mai la password sulla rete).\
Questo **metodo NON √® abilitato** di default.

La principale **differenza** con il **metodo di autenticazione precedente** nel codice √® che **non √® necessario conoscere l'ID del pool di utenti** e che **non sono necessarie autorizzazioni extra** nel Cognito User Pool.

Per **accedere** √® **necessario** conoscere:

* client id
* username
* password
* client secret (solo se l'app √® configurata per usare un segreto)

{% hint style="info" %}
Per essere **in grado di accedere con questo metodo** l'applicazione deve consentire l'accesso con ALLOW\_USER\_PASSWORD\_AUTH.
{% endhint %}
```python
aws cognito-idp initiate-auth  --client-id <client-id> \
--auth-flow USER_PASSWORD_AUTH --region <region> \
--auth-parameters 'USERNAME=<username>,PASSWORD=<password>,SECRET_HASH=<hash_if_needed>'

# Check the python code to learn how to generate the secret_hash
```
<details>

<summary>Codice Python per il Login</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64


client_id = "<client-id>"
user_pool_id = "<user-pool-id>"
client_secret = "<client-secret>"
username = "<username>"
password = "<pwd>"

boto_client = boto3.client('cognito-idp', region_name='us-east-1')

def get_secret_hash(username, client_id, client_secret):
key = bytes(client_secret, 'utf-8')
message = bytes(f'{username}{client_id}', 'utf-8')
return base64.b64encode(hmac.new(key, message, digestmod=hashlib.sha256).digest()).decode()

# If the Client App isn't configured to use a secret
## just delete the line setting the SECRET_HASH
def login_user(username_or_alias, password, client_id, client_secret, user_pool_id):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='ADMIN_USER_PASSWORD_AUTH',
AuthParameters={
'USERNAME': username_or_alias,
'PASSWORD': password,
'SECRET_HASH': get_secret_hash(username_or_alias, client_id, client_secret)
}
)
except botocore.exceptions.ClientError as e:
return e.response

print(login_user(username, password, client_id, client_secret, user_pool_id))
```
</details>

### USER\_SRP\_AUTH

Questo scenario √® simile al precedente ma **invece di inviare la password** attraverso la rete per effettuare il login, viene eseguita una **challenge authentication** (quindi nessuna password naviga, anche se criptata, attraverso la rete).\
Questo **metodo √® abilitato** di default.

Per **effettuare il login** √® **necessario** conoscere:

* user pool id
* client id
* username
* password
* client secret (solo se l'app √® configurata per utilizzare un secret)

<details>

<summary>Codice per il login</summary>
```python
from warrant.aws_srp import AWSSRP
import os

USERNAME='xxx'
PASSWORD='yyy'
POOL_ID='us-east-1_zzzzz'
CLIENT_ID = '12xxxxxxxxxxxxxxxxxxxxxxx'
CLIENT_SECRET = 'secreeeeet'
os.environ["AWS_DEFAULT_REGION"] = "<region>"

aws = AWSSRP(username=USERNAME, password=PASSWORD, pool_id=POOL_ID,
client_id=CLIENT_ID, client_secret=CLIENT_SECRET)
tokens = aws.authenticate_user()
id_token = tokens['AuthenticationResult']['IdToken']
refresh_token = tokens['AuthenticationResult']['RefreshToken']
access_token = tokens['AuthenticationResult']['AccessToken']
token_type = tokens['AuthenticationResult']['TokenType']
```
</details>

### REFRESH\_TOKEN\_AUTH & REFRESH\_TOKEN

Questo **metodo sar√† sempre valido** (non pu√≤ essere disabilitato) ma √® necessario avere un refresh token valido.
```bash
aws cognito-idp initiate-auth \
--client-id 3ig6h5gjm56p1ljls1prq2miut \
--auth-flow REFRESH_TOKEN_AUTH \
--region us-east-1 \
--auth-parameters 'REFRESH_TOKEN=<token>'
```
<details>

<summary>Codice per aggiornare</summary>
```python
import boto3
import botocore
import hmac
import hashlib
import base64

client_id = "<client-id>"
token = '<token>'

boto_client = boto3.client('cognito-idp', region_name='<region>')

def refresh(client_id, refresh_token):
try:
return boto_client.initiate_auth(
ClientId=client_id,
AuthFlow='REFRESH_TOKEN_AUTH',
AuthParameters={
'REFRESH_TOKEN': refresh_token
}
)
except botocore.exceptions.ClientError as e:
return e.response


print(refresh(client_id, token))
```
</details>

### CUSTOM\_AUTH

In questo caso l'**autenticazione** verr√† eseguita tramite l'**esecuzione di una funzione lambda**.

## Sicurezza Extra

### Sicurezza Avanzata

Per impostazione predefinita √® disabilitata, ma se abilitata, Cognito potrebbe essere in grado di **trovare takeover di account**. Per minimizzare la probabilit√† dovresti effettuare il login da una **rete all'interno della stessa citt√†, utilizzando lo stesso user agent** (e IP se possibile)**.**

### **MFA Ricorda dispositivo**

Se l'utente effettua il login dallo stesso dispositivo, l'MFA potrebbe essere bypassato, quindi prova a effettuare il login dallo stesso browser con gli stessi metadati (IP?) per cercare di bypassare la protezione MFA.

## Ruoli IAM dei Gruppi del User Pool

√à possibile aggiungere **utenti ai gruppi del User Pool** che sono collegati a uno **IAM roles**.\
Inoltre, **gli utenti** possono essere assegnati a **pi√π di 1 gruppo con diversi IAM roles** collegati.

Nota che anche se un gruppo √® all'interno di un gruppo con un IAM role collegato, per poter accedere alle credenziali IAM di quel gruppo √® necessario che il **User Pool sia considerato attendibile da un Identity Pool** (e conoscere i dettagli di quell'Identity Pool).

Un altro requisito per ottenere il **IAM role indicato nell'IdToken** quando un utente √® autenticato nel User Pool (`aws cognito-idp initiate-auth...`) √® che il **Identity Provider Authentication provider** deve indicare che il **ruolo deve essere selezionato dal token.**

<figure><img src="../../../../.gitbook/assets/image (250).png" alt=""><figcaption></figcaption></figure>

I **ruoli** a cui un utente ha accesso sono **all'interno dell'`IdToken`**, e un utente pu√≤ **selezionare quale ruolo desidera ottenere le credenziali** con il **`--custom-role-arn`** da `aws cognito-identity get-credentials-for-identity`.\
Tuttavia, se l'**opzione predefinita** √® quella **configurata** (`use default role`), e provi ad accedere a un ruolo dall'IdToken, otterrai un **errore** (ecco perch√© √® necessaria la configurazione precedente):

{% code overflow="wrap" %}
```
An error occurred (InvalidParameterException) when calling the GetCredentialsForIdentity operation: Only SAML providers and providers with RoleMappings support custom role ARN.
```
{% endcode %}

{% hint style="warning" %}
Nota che il ruolo assegnato a un **User Pool Group** deve essere **accessibile dal Identity Provider** che **si fida del User Pool** (poich√© le **credenziali di sessione del ruolo IAM verranno ottenute da esso**).
{% endhint %}
```json
{
"Version": "2012-10-17",
"Statement": [
{
"Effect": "Allow",
"Principal": {
"Federated": "cognito-identity.amazonaws.com"
},
"Action": "sts:AssumeRoleWithWebIdentity",
"Condition": {
"StringEquals": {
"cognito-identity.amazonaws.com:aud": "us-east-1:2361092e-9db6-a876-1027-10387c9de439"
},
"ForAnyValue:StringLike": {
"cognito-identity.amazonaws.com:amr": "authenticated"
}
}
}
]
}js
```
{% hint style="success" %}
Impara e pratica AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Impara e pratica GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repository su github.

</details>
{% endhint %}
