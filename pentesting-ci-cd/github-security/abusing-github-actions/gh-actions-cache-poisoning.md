# GH Actions - Cache Poisoning

{% hint style="success" %}
Lerne & √ºbe AWS Hacking:<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="../../../.gitbook/assets/image (1).png" alt="" data-size="line">\
Lerne & √ºbe GCP Hacking: <img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="../../../.gitbook/assets/image (2).png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Support HackTricks</summary>

* √úberpr√ºfe die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teile Hacking-Tricks, indem du PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>
{% endhint %}

F√ºr weitere Details siehe den Originalbeitrag [https://scribesecurity.com/blog/github-cache-poisoning/](https://scribesecurity.com/blog/github-cache-poisoning/)

## Cache Poisoning

Die Git-Aktion [**action/cache**](https://github.com/actions/cache) f√ºhrt einen Caching-Mechanismus im Continuous Integration (CI)-Prozess ein, der zwei kritische Phasen umfasst:

1. **Run Action**: Diese Phase beinhaltet das Suchen und Abrufen von zwischengespeicherten Daten w√§hrend des CI-Laufs. Die Suche nutzt einen einzigartigen Cache-Schl√ºssel, was zu zwei Ergebnissen f√ºhrt:
* **Cache-hit**: Die angeforderten Daten werden im Cache gefunden und stehen somit sofort zur Verf√ºgung.
* **Cache-miss**: Es werden keine passenden Daten im Cache gefunden, was einen frischen Download der ben√∂tigten Dateien und Verzeichnisse erforderlich macht, √§hnlich einer Erstanfrage.
2. **Post Workflow Action**: Diese Phase ist der Zwischenspeicherung von Daten nach dem CI-Workflow gewidmet. Insbesondere, wenn w√§hrend der Run Action ein Cache-miss auftritt, wird der aktuelle Zustand der angegebenen Verzeichnisse mit dem bereitgestellten Schl√ºssel zwischengespeichert. Dieser Prozess ist automatisiert und erfordert keine explizite Aufforderung.

#### Sicherheitsma√ünahmen: Cache-Isolierung und Zugriffsrestriktionen

Um die Sicherheit zu gew√§hrleisten und die Cache-Isolierung aufrechtzuerhalten, werden Zugriffsrestriktionen durchgesetzt, die eine logische Trennung zwischen verschiedenen Branches schaffen. Beispielsweise ist ein Cache, der f√ºr den Branch **Feature-A** (mit seiner Basis im Hauptbranch) erstellt wurde, f√ºr einen Pull-Request f√ºr den Branch **Feature-B** (ebenfalls basierend auf dem Hauptbranch) nicht zug√§nglich.

Die Cache-Aktion folgt einer spezifischen Suchreihenfolge:

* Zuerst wird nach Cache-Hits im selben Branch wie der Workflow-Lauf gesucht.
* Wenn dies nicht erfolgreich ist, wird die Suche auf den √ºbergeordneten Branch und andere upstream Branches ausgeweitet.

Wichtig ist, dass der Cache-Zugriff branch-spezifisch ist und sich √ºber alle Workflows und L√§ufe eines bestimmten Branches erstreckt. Dar√ºber hinaus setzt GitHub eine schreibgesch√ºtzte Richtlinie f√ºr Cache-Eintr√§ge durch, sobald sie erstellt wurden, und verbietet jegliche √Ñnderungen.

#### Reale Auswirkungen: Vom Low- zu High-Permission Workflow-Angriff

Ein illustratives CI-Szenario zeigt, wie ein Angreifer Cache Poisoning nutzen k√∂nnte, um Privilegien von einem Workflow mit niedrigen Berechtigungen auf einen mit hohen Berechtigungen zu eskalieren:

* Der **Unit-test** Workflow, der f√ºr das Ausf√ºhren von Unit-Tests und Code-Coverage-Tools verantwortlich ist, wird angenommen, ein kompromittiertes oder anf√§lliges Tool zu verwenden. Dieser Workflow nutzt die **action/cache** Git-Aktion, wodurch der Cache f√ºr jeden Workflow zug√§nglich ist.
* Der **Release** Workflow, der f√ºr das Erstellen und Ver√∂ffentlichen des Anwendungsartefakts zust√§ndig ist, optimiert seine Abl√§ufe durch das Caching von Golang-Abh√§ngigkeiten.

In diesem Szenario f√ºhrt der Unit-test Workflow einen b√∂sartigen Cache-Eintrag ein, indem er eine legitime Golang-Logging-Bibliothek (\`go
